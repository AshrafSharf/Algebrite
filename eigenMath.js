// Generated by CoffeeScript 1.10.0
var ABS, ADD, ADJ, AND, ARCCOS, ARCCOSH, ARCSIN, ARCSINH, ARCTAN, ARCTANH, ARG, ATOMIZE, AUTOEXPAND, BAKE, BESSELJ, BESSELY, BINDING, BINOMIAL, BUF, C1, C2, C3, C4, C5, C6, CEILING, CHECK, CHOOSE, CIRCEXP, CLEAR, CLOCK, COEFF, COFACTOR, CONDENSE, CONJ, CONS, CONTRACT, COS, COSH, DECOMP, DEFINT, DEGREE, DENOMINATOR, DERIVATIVE, DET, DIM, DIRAC, DISPLAY, DIVISORS, DO, DOT, DOUBLE, DRAW, DRAWX, DSOLVE, E, EIGEN, EIGENVAL, EIGENVEC, ERF, ERFC, EVAL, EXP, EXPAND, EXPCOS, EXPSIN, Eval, Eval_Eval, Eval_binding, Eval_check, Eval_cons, Eval_det, Eval_dim, Eval_divisors, Eval_do, Eval_dsolve, Eval_exp, Eval_factorial, Eval_factorpoly, Eval_hermite, Eval_hilbert, Eval_index, Eval_inv, Eval_invg, Eval_isinteger, Eval_multiply, Eval_noexpand, Eval_number, Eval_operator, Eval_predicate, Eval_print, Eval_quote, Eval_rank, Eval_setq, Eval_sqrt, Eval_stop, Eval_subst, Eval_sym, Eval_unit, FACTOR, FACTORIAL, FACTORPOLY, FILTER, FLOATF, FLOOR, FOR, GAMMA, GCD, HERMITE, HILBERT, IMAG, INDEX, INNER, INTEGRAL, INV, INVG, ISINTEGER, ISPRIME, LAGUERRE, LAST, LCM, LEADING, LEGENDRE, LOG, MAG, MAXDIM, MAXPRIMETAB, MAX_PROGRAM_SIZE, MEQUAL, METAA, METAB, METAX, MLENGTH, MOD, MP_MAX_FREE, MP_MIN_SIZE, MSIGN, MULTIPLY, MZERO, NIL, NOT, NROOTS, NSYM, NUM, NUMBER, NUMERATOR, OPERATOR, OR, OUTER, PI, POLAR, POWER, PRIME, PRINT, PRODUCT, QUOTE, QUOTIENT, RANK, RATIONALIZE, REAL, ROOTS, SECRETX, SELFTEST, SETQ, SGN, SIMPLIFY, SIN, SINH, SQRT, STOP, STR, SUBST, SUM, SYM, SYMBOL_A, SYMBOL_B, SYMBOL_C, SYMBOL_D, SYMBOL_I, SYMBOL_J, SYMBOL_N, SYMBOL_R, SYMBOL_S, SYMBOL_T, SYMBOL_X, SYMBOL_Y, SYMBOL_Z, TAN, TANH, TAYLOR, TENSOR, TEST, TESTEQ, TESTGE, TESTGT, TESTLE, TESTLT, TOS, TRACE, TRANSPOSE, TTY, T_DOUBLE, T_EQ, T_FUNCTION, T_GTEQ, T_INTEGER, T_LTEQ, T_NEWLINE, T_STRING, T_SYMBOL, U, UNIT, USR_SYMBOLS, YYE, YYRECT, ZERO, __factorial, __is_radical_number, __normalize_radical_factors, add_numbers, arglist, bignum_factorial, bignum_float, bignum_power_number, bignum_scan_float, bignum_scan_integer, bignum_truncate, binding, build_tensor, caaddr, caadr, caar, cadaddr, cadadr, cadar, caddaddr, caddadr, caddar, caddddr, cadddr, caddr, cadr, car, cdaddr, cdadr, cdar, cddaddr, cddar, cdddaddr, cddddr, cdddr, cddr, cdr, check_esc_flag, check_stack, clear_symbols, combine_factors, combine_gammas, compare_numbers, compare_rationals, cons, convert_bignum_to_double, convert_rational_to_double, counter, defn, defn_str, display, divide, divide_numbers, draw_flag, draw_stop_return, dupl, echo_input, endian, equaln, equalq, error, esc_flag, expanding, fmt_index, fmt_level, fmt_x, frame, free_stack, gcd_numbers, ge, get_arglist, get_binding, get_next_token, get_printname, get_token, gp, imaginaryunit, init, input_str, inverse, invert_number, is_factor, isadd, isalnum, isalpha, iscomplexnumber, iscons, isdigit, isdouble, iseveninteger, isfactorial, isfloating, isfraction, isimaginarynumber, isimaginaryunit, isinteger, isintegerfactor, iskeyword, isminusone, isminusoneoversqrttwo, isnegative, isnegativenumber, isnegativeterm, isnonnegativeinteger, isnpi, isnum, isoneover, isoneoversqrttwo, isplusone, ispoly, ispoly_expr, ispoly_factor, ispoly_term, isposint, ispower, isquarterturn, isrational, isspace, isstr, issymbol, issymbolic, istensor, iszero, list, logbuf, mask, meta_mode, mfreecount, mp_clr_bit, mp_denominator, mp_numerator, mp_set_bit, mshiftright, mtotal, multiply, multiply_all, multiply_all_noexpand, multiply_noexpand, multiply_numbers, negate, negate_expand, negate_noexpand, negate_number, newline_flag, one, out_buf, out_count, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, parse_p1, parse_p2, pop, pop_double, pop_frame, pop_integer, primetab, print_double, print_number, program_buf, push, push_double, push_frame, push_integer, push_rational, push_symbol, rational, reciprocate, restore, run, s, save, scan, scan_expression, scan_factor, scan_function_call, scan_meta, scan_power, scan_relation, scan_stmt, scan_str, scan_string, scan_subexpr, scan_symbol, scan_term, scanned, set_binding, set_binding_and_arglist, setq_indexed, stack, std_symbol, stop, subtract_numbers, swap, symbol, symnum, symtab, tensor, testString, test_flag, test_scan, text_metric, token, token_buf, token_str, top_level_eval, tos, trigmode, update_token_buf, usr_symbol, verbosing, yymultiply, zero;

MP_MIN_SIZE = 2;

MP_MAX_FREE = 1000;

mtotal = 0;

mfreecount = 0;

free_stack = [];


/*
mnew = (n) ->
	if (n < MP_MIN_SIZE)
		n = MP_MIN_SIZE
	if (n == MP_MIN_SIZE && mfreecount)
		p = free_stack[--mfreecount]
	else
		p = [] #(unsigned int *) malloc((n + 3) * sizeof (int))
		#if (p == 0)
		 *	stop("malloc failure")
	p[0] = n
	mtotal += n
	return p[3]
 */


/*
mfree = (array, p) ->
	p -= 3
	mtotal -= array[p]
	if (array[p] == MP_MIN_SIZE && mfreecount < MP_MAX_FREE)
		free_stack[mfreecount++] = p
	else
		free(p)
 */


/*
mint = (n) ->
	p = mnew(1)
	if (n < 0)
		 * !!! this is FU
		 * MSIGN(p) = -1
		fu = true
	else
		 * !!! this is FU
		#MSIGN(p) = 1
		fu = true
	 * !!! this is FU
	#MLENGTH(p) = 1
	p[0] = Math.abs(n)
	return p
 */


/*
mcopy = (a) ->
	#unsigned int *b

	b = mnew(MLENGTH(a))

	 * !!! fu
	#MSIGN(b) = MSIGN(a)
	#MLENGTH(b) = MLENGTH(a)

	for i in [0...MLENGTH(a)]
		b[i] = a[i]

	return b
 */

ge = function(a, b, len) {
  debugger;
  var i, j, ref;
  for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    if (a[i] === b[i]) {
      continue;
    } else {
      break;
    }
  }
  if (a[i] >= b[i]) {
    return 1;
  } else {
    return 0;
  }
};

add_numbers = function() {
  var a, b, p1, p2;
  double(a, b);
  if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
    qadd();
    return;
  }
  save();
  p2 = pop();
  p1 = pop();
  if (isdouble(p1)) {
    a = p1.d;
  } else {
    a = convert_rational_to_double(p1);
  }
  if (isdouble(p2)) {
    b = p2.d;
  } else {
    b = convert_rational_to_double(p2);
  }
  push_double(a + b);
  return restore();
};

subtract_numbers = function() {
  var a, b, p1, p2;
  double(a, b);
  if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
    qsub();
    return;
  }
  save();
  p2 = pop();
  p1 = pop();
  if (isdouble(p1)) {
    a = p1.d;
  } else {
    a = convert_rational_to_double(p1);
  }
  if (isdouble(p2)) {
    b = p2.d;
  } else {
    b = convert_rational_to_double(p2);
  }
  push_double(a - b);
  return restore();
};

multiply_numbers = function() {
  var a, b, p1, p2;
  double(a, b);
  if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
    qmul();
    return;
  }
  save();
  p2 = pop();
  p1 = pop();
  if (isdouble(p1)) {
    a = p1.d;
  } else {
    a = convert_rational_to_double(p1);
  }
  if (isdouble(p2)) {
    b = p2.d;
  } else {
    b = convert_rational_to_double(p2);
  }
  push_double(a * b);
  return restore();
};

divide_numbers = function() {
  var a, b, p1, p2;
  a = 0.0;
  b = 0.0;
  if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
    qdiv();
    return;
  }
  save();
  p2 = pop();
  p1 = pop();
  if (iszero(p2)) {
    stop("divide by zero");
  }
  if (isdouble(p1)) {
    a = p1.d;
  } else {
    a = convert_rational_to_double(p1);
  }
  if (isdouble(p2)) {
    b = p2.d;
  } else {
    b = convert_rational_to_double(p2);
  }
  push_double(a / b);
  return restore();
};

invert_number = function() {
  var a, b, p1;
  save();
  p1 = pop();
  if (iszero(p1)) {
    stop("divide by zero");
  }
  if (isdouble(p1)) {
    push_double(1 / p1.d);
    restore();
    return;
  }
  a = bigInt(p1.q.a);
  b = bigInt(p1.q.b);
  p1 = new U();
  p1.k = NUM;
  p1.q.a = b;
  p1.q.b = a;
  push(p1);
  return restore();
};

compare_rationals = function(a, b) {
  var ab, ba, t;
  t = 0;
  ab = mmul(a.q.a, b.q.b);
  ba = mmul(a.q.b, b.q.a);
  t = mcmp(ab, ba);
  mfree(ab);
  mfree(ba);
  return t;
};

compare_numbers = function(a, b) {
  var x, y;
  x = 0.0;
  y = 0.0;
  if (isrational(a) && isrational(b)) {
    return compare_rationals(a, b);
  }
  if (isdouble(a)) {
    x = a.d;
  } else {
    x = convert_rational_to_double(a);
  }
  if (isdouble(b)) {
    y = b.d;
  } else {
    y = convert_rational_to_double(b);
  }
  if (x < y) {
    return -1;
  }
  if (x > y) {
    return 1;
  }
  return 0;
};

negate_number = function() {
  var p1, p2;
  save();
  p1 = pop();
  if (iszero(p1)) {
    push(p1);
    restore();
    return;
  }
  switch (p1.k) {
    case NUM:
      p2 = new U();
      p2.k = NUM;
      p2.q.a = bigInt(p1.q.a);
      p2.q.b = bigInt(p1.q.b);
      push(p2);
      break;
    case DOUBLE:
      push_double(-p1.d);
      break;
    default:
      stop("bug caught in mp_negate_number");
  }
  return restore();
};

bignum_truncate = function() {
  var a, p1;
  save();
  p1 = pop();
  a = mdiv(p1.q.a, p1.q.b);
  p1 = new U();
  p1.k = NUM;
  p1.q.a = a;
  p1.q.b = bigInt(1);
  push(p1);
  return restore();
};

mp_numerator = function() {
  var p1, p2;
  save();
  p1 = pop();
  if (p1.k !== NUM) {
    push(one);
    restore();
    return;
  }
  p2 = new U();
  p2.k = NUM;
  p2.q.a = bigInt(p1.q.a);
  p2.q.b = bigInt(1);
  push(p2);
  return restore();
};

mp_denominator = function() {
  var p1, p2;
  save();
  p1 = pop();
  if (p1.k !== NUM) {
    push(one);
    restore();
    return;
  }
  p2 = new U();
  p2.k = NUM;
  p2.q.a = bigInt(p1.q.b);
  p2.q.b = bigInt(1);
  push(p2);
  return restore();
};

bignum_power_number = function(expo) {
  var a, b, p1, t;
  save();
  p1 = pop();
  a = mpow(p1.q.a, abs(expo));
  b = mpow(p1.q.b, abs(expo));
  if (expo < 0) {
    t = a;
    a = b;
    b = t;
  }
  p1 = new U();
  p1.k = NUM;
  p1.q.a = a;
  p1.q.b = b;
  push(p1);
  return restore();
};

convert_bignum_to_double = function(p) {
  return p.toJSNumber();
};

convert_rational_to_double = function(p) {
  var a, b, i, j, l, m, n, na, nb, ref, ref1, ref2, ref3, ref4;
  console.log('!!!! convert_rational_to_double not properly translated due to MLENGTH');
  i = 0;
  n = 0;
  na = 0;
  nb = 0;
  a = 0.0;
  b = 0.0;
  na = MLENGTH(p.q.a);
  nb = MLENGTH(p.q.b);
  if (na < nb) {
    n = na;
  } else {
    n = nb;
  }
  for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    a = a / 4294967296.0 + p.q.a[i];
    b = b / 4294967296.0 + p.q.b[i];
  }
  if (na > nb) {
    for (i = l = ref1 = nb, ref2 = na; ref1 <= ref2 ? l < ref2 : l > ref2; i = ref1 <= ref2 ? ++l : --l) {
      a = a / 4294967296.0 + p.q.a[i];
      b = b / 4294967296.0;
    }
  }
  if (na < nb) {
    for (i = m = ref3 = na, ref4 = nb; ref3 <= ref4 ? m < ref4 : m > ref4; i = ref3 <= ref4 ? ++m : --m) {
      a = a / 4294967296.0;
      b = b / 4294967296.0 + p.q.b[i];
    }
  }
  if (MSIGN(p.q.a) === -1) {
    a = -a;
  }
  return a / b;
};

push_integer = function(n) {
  var p1;
  console.log("pushing integer " + n);
  save();
  p1 = new U();
  p1.k = NUM;
  p1.q.a = bigInt(n);
  p1.q.b = bigInt(1);
  push(p1);
  return restore();
};

push_double = function(d) {
  var p1;
  save();
  p1 = new U();
  p1.k = DOUBLE;
  p1.d = d;
  push(p1);
  return restore();
};

push_rational = function(a, b) {
  var p1;
  save();
  p1 = new U();
  p1.k = NUM;
  p1.q.a = bigInt(a);
  p1.q.b = bigInt(b);
  push(p1);
  return restore();
};

pop_integer = function() {
  var n, p1;
  n = 0;
  save();
  p1 = pop();
  switch (p1.k) {
    case NUM:
      if (isinteger(p1) && p1.q.a.isSmall()) {
        n = p1.q.a[0];
        if (n & 0x80000000) {
          n = 0x80000000;
        } else {
          n *= MSIGN(p1.q.a);
        }
      } else {
        n = 0x80000000;
      }
      break;
    case DOUBLE:
      n = Math.floor(p1.d);
      if (n !== p1.d) {
        n = 0x80000000;
      }
      break;
    default:
      n = 0x80000000;
  }
  restore();
  return n;
};

print_double = function(p, flag) {
  var buf;
  buf = "";
  buf = "" + p.d;
  if (flag === 1 && buf === '-') {
    return print_str(buf + 1);
  } else {
    return print_str(buf);
  }
};

bignum_scan_integer = function(s) {
  var a, p1, scounter, sign;
  save();
  scounter = 0;
  sign = s[scounter];
  if (sign === '+' || sign === '-') {
    scounter++;
  }
  a = bigInt(s.substring(scounter));
  p1 = new U();
  p1.k = NUM;
  p1.q.a = a;
  p1.q.b = bigInt(1);
  push(p1);
  if (sign === '-') {
    negate();
  }
  return restore();
};

bignum_scan_float = function(s) {
  return push_double(atof(s));
};

print_number = function(p) {
  var buf, s;
  s = "";
  buf = "";
  switch (p.k) {
    case NUM:
      s = mstr(p.q.a);
      if (s[0] === '+' || s[0] === '-') {
        s++;
      }
      print_str(s);
      if (isfraction(p)) {
        print_str("/");
        s = mstr(p.q.b);
        return print_str(s);
      }
      break;
    case DOUBLE:
      sprintf(buf, "%g", p.d);
      if (buf[0] === '+' || buf[0] === '-') {
        return print_str(buf + 1);
      } else {
        return print_str(buf);
      }
  }
};

gcd_numbers = function() {
  var p1, p2, p3;
  save();
  p2 = pop();
  p1 = pop();
  p3 = new U();
  p3.k = NUM;
  p3.q.a = mgcd(p1.q.a, p2.q.a);
  p3.q.b = mgcd(p1.q.b, p2.q.b);
  push(p3);
  return restore();
};

pop_double = function() {
  var d, p1;
  double(d);
  save();
  p1 = pop();
  switch (p1.k) {
    case NUM:
      d = convert_rational_to_double(p1);
      break;
    case DOUBLE:
      d = p1.d;
      break;
    default:
      d = 0.0;
  }
  restore();
  return d;
};

bignum_float = function() {
  var d;
  double(d);
  d = convert_rational_to_double(pop());
  return push_double(d);
};

bignum_factorial = function(n) {
  var p1;
  save();
  p1 = new U();
  p1.k = NUM;
  p1.q.a = __factorial(n);
  p1.q.b = bigInt(1);
  push(p1);
  return restore();
};

__factorial = function(n) {
  var a, b, i, j, ref, t;
  int(i);
  if (n === 0 || n === 1) {
    a = bigInt(1);
    return a;
  }
  a = bigInt(2);
  b = bigInt(0);
  for (i = j = 3, ref = n; 3 <= ref ? j <= ref : j >= ref; i = 3 <= ref ? ++j : --j) {
    b[0] = Math.floor(i);
    t = mmul(a, b);
    mfree(a);
    a = t;
  }
  mfree(b);
  return a;
};

mask = [0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080, 0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000, 0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000, 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000];

mp_set_bit = function(x, k) {
  return x[k / 32] |= mask[k % 32];
};

mp_clr_bit = function(x, k) {
  return x[k / 32] &= ~mask[k % 32];
};

mshiftright = function(a) {
  var c, fu, i, j, n, ref;
  n = MLENGTH(a);
  c = 0;
  for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    if (a[i] & 1) {
      a[i] = (a[i] >> 1) | c;
      c = 0x80000000;
    } else {
      a[i] = (a[i] >> 1) | c;
      c = 0;
    }
  }
  if (n > 1 && a[n - 1] === 0) {
    return fu = true;
  }
};

cons = function() {
  var p;
  p = new U();
  p.k = CONS;
  p.cons.cdr = pop();
  p.cons.car = pop();
  console.log("cons new cdr.k = " + p.cons.cdr.k);
  console.log("cons new car.k = " + p.cons.car.k);
  return push(p);
};

init = function() {
  var draw_flag, esc_flag, flag, frame, i, imaginaryunit, j, one, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, ref, tos, zero;
  i = 0;
  flag = 0;
  tos = 0;
  esc_flag = 0;
  draw_flag = 0;
  frame = stack + TOS;
  p0 = symbol(NIL);
  p1 = symbol(NIL);
  p2 = symbol(NIL);
  p3 = symbol(NIL);
  p4 = symbol(NIL);
  p5 = symbol(NIL);
  p6 = symbol(NIL);
  p7 = symbol(NIL);
  p8 = symbol(NIL);
  p9 = symbol(NIL);
  if (flag) {
    return;
  }
  flag = 1;
  for (i = j = 0, ref = NSYM; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    symtab[i].k = SYM;
    binding[i] = symtab + i;
    arglist[i] = symbol(NIL);
  }
  std_symbol("abs", ABS);
  std_symbol("add", ADD);
  std_symbol("adj", ADJ);
  std_symbol("and", AND);
  std_symbol("arccos", ARCCOS);
  std_symbol("arccosh", ARCCOSH);
  std_symbol("arcsin", ARCSIN);
  std_symbol("arcsinh", ARCSINH);
  std_symbol("arctan", ARCTAN);
  std_symbol("arctanh", ARCTANH);
  std_symbol("arg", ARG);
  std_symbol("atomize", ATOMIZE);
  std_symbol("besselj", BESSELJ);
  std_symbol("bessely", BESSELY);
  std_symbol("binding", BINDING);
  std_symbol("binomial", BINOMIAL);
  std_symbol("ceiling", CEILING);
  std_symbol("check", CHECK);
  std_symbol("choose", CHOOSE);
  std_symbol("circexp", CIRCEXP);
  std_symbol("clear", CLEAR);
  std_symbol("clock", CLOCK);
  std_symbol("coeff", COEFF);
  std_symbol("cofactor", COFACTOR);
  std_symbol("condense", CONDENSE);
  std_symbol("conj", CONJ);
  std_symbol("contract", CONTRACT);
  std_symbol("cos", COS);
  std_symbol("cosh", COSH);
  std_symbol("decomp", DECOMP);
  std_symbol("defint", DEFINT);
  std_symbol("deg", DEGREE);
  std_symbol("denominator", DENOMINATOR);
  std_symbol("det", DET);
  std_symbol("derivative", DERIVATIVE);
  std_symbol("dim", DIM);
  std_symbol("dirac", DIRAC);
  std_symbol("display", DISPLAY);
  std_symbol("divisors", DIVISORS);
  std_symbol("do", DO);
  std_symbol("dot", DOT);
  std_symbol("draw", DRAW);
  std_symbol("dsolve", DSOLVE);
  std_symbol("erf", ERF);
  std_symbol("erfc", ERFC);
  std_symbol("eigen", EIGEN);
  std_symbol("eigenval", EIGENVAL);
  std_symbol("eigenvec", EIGENVEC);
  std_symbol("eval", EVAL);
  std_symbol("exp", EXP);
  std_symbol("expand", EXPAND);
  std_symbol("expcos", EXPCOS);
  std_symbol("expsin", EXPSIN);
  std_symbol("factor", FACTOR);
  std_symbol("factorial", FACTORIAL);
  std_symbol("factorpoly", FACTORPOLY);
  std_symbol("filter", FILTER);
  std_symbol("float", FLOATF);
  std_symbol("floor", FLOOR);
  std_symbol("for", FOR);
  std_symbol("Gamma", GAMMA);
  std_symbol("gcd", GCD);
  std_symbol("hermite", HERMITE);
  std_symbol("hilbert", HILBERT);
  std_symbol("imag", IMAG);
  std_symbol("component", INDEX);
  std_symbol("inner", INNER);
  std_symbol("integral", INTEGRAL);
  std_symbol("inv", INV);
  std_symbol("invg", INVG);
  std_symbol("isinteger", ISINTEGER);
  std_symbol("isprime", ISPRIME);
  std_symbol("laguerre", LAGUERRE);
  std_symbol("lcm", LCM);
  std_symbol("leading", LEADING);
  std_symbol("legendre", LEGENDRE);
  std_symbol("log", LOG);
  std_symbol("mag", MAG);
  std_symbol("mod", MOD);
  std_symbol("multiply", MULTIPLY);
  std_symbol("not", NOT);
  std_symbol("nroots", NROOTS);
  std_symbol("number", NUMBER);
  std_symbol("numerator", NUMERATOR);
  std_symbol("operator", OPERATOR);
  std_symbol("or", OR);
  std_symbol("outer", OUTER);
  std_symbol("polar", POLAR);
  std_symbol("power", POWER);
  std_symbol("prime", PRIME);
  std_symbol("print", PRINT);
  std_symbol("product", PRODUCT);
  std_symbol("quote", QUOTE);
  std_symbol("quotient", QUOTIENT);
  std_symbol("rank", RANK);
  std_symbol("rationalize", RATIONALIZE);
  std_symbol("real", REAL);
  std_symbol("rect", YYRECT);
  std_symbol("roots", ROOTS);
  std_symbol("equals", SETQ);
  std_symbol("sgn", SGN);
  std_symbol("simplify", SIMPLIFY);
  std_symbol("sin", SIN);
  std_symbol("sinh", SINH);
  std_symbol("sqrt", SQRT);
  std_symbol("stop", STOP);
  std_symbol("subst", SUBST);
  std_symbol("sum", SUM);
  std_symbol("tan", TAN);
  std_symbol("tanh", TANH);
  std_symbol("taylor", TAYLOR);
  std_symbol("test", TEST);
  std_symbol("testeq", TESTEQ);
  std_symbol("testge", TESTGE);
  std_symbol("testgt", TESTGT);
  std_symbol("testle", TESTLE);
  std_symbol("testlt", TESTLT);
  std_symbol("transpose", TRANSPOSE);
  std_symbol("unit", UNIT);
  std_symbol("zero", ZERO);
  std_symbol("nil", NIL);
  std_symbol("autoexpand", AUTOEXPAND);
  std_symbol("bake", BAKE);
  std_symbol("last", LAST);
  std_symbol("trace", TRACE);
  std_symbol("tty", TTY);
  std_symbol("~", YYE);
  std_symbol("$DRAWX", DRAWX);
  std_symbol("$METAA", METAA);
  std_symbol("$METAB", METAB);
  std_symbol("$METAX", METAX);
  std_symbol("$SECRETX", SECRETX);
  std_symbol("pi", PI);
  std_symbol("a", SYMBOL_A);
  std_symbol("b", SYMBOL_B);
  std_symbol("c", SYMBOL_C);
  std_symbol("d", SYMBOL_D);
  std_symbol("i", SYMBOL_I);
  std_symbol("j", SYMBOL_J);
  std_symbol("n", SYMBOL_N);
  std_symbol("r", SYMBOL_R);
  std_symbol("s", SYMBOL_S);
  std_symbol("t", SYMBOL_T);
  std_symbol("x", SYMBOL_X);
  std_symbol("y", SYMBOL_Y);
  std_symbol("z", SYMBOL_Z);
  std_symbol("$C1", C1);
  std_symbol("$C2", C2);
  std_symbol("$C3", C3);
  std_symbol("$C4", C4);
  std_symbol("$C5", C5);
  std_symbol("$C6", C6);
  push_integer(0);
  zero = pop();
  push_integer(1);
  one = pop();
  push_symbol(POWER);
  push_integer(-1);
  push_rational(1, 2);
  list(3);
  imaginaryunit = pop();
  return defn();
};

defn_str = ["e=exp(1)", "i=sqrt(-1)", "autoexpand=1", "trange=(-pi,pi)", "xrange=(-10,10)", "yrange=(-10,10)", "last=0", "trace=0", "tty=0", "cross(u,v)=(u[2]*v[3]-u[3]*v[2],u[3]*v[1]-u[1]*v[3],u[1]*v[2]-u[2]*v[1])", "curl(v)=(d(v[3],y)-d(v[2],z),d(v[1],z)-d(v[3],x),d(v[2],x)-d(v[1],y))", "div(v)=d(v[1],x)+d(v[2],y)+d(v[3],z)", "ln(x)=log(x)"];

defn = function() {
  var i, j, n, ref, results;
  i = 0;
  n = 0;
  n = defn_str.length;
  results = [];
  for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    scan(defn_str[i]);
    eval();
    results.push(pop());
  }
  return results;
};

SELFTEST = 1;

NSYM = 1000;

rational = (function() {
  function rational() {}

  rational.prototype.a = null;

  rational.prototype.b = null;

  return rational;

})();

U = (function() {
  U.prototype.cons = {};

  U.prototype.printname = "";

  U.prototype.str = "";

  U.prototype.tensor = null;

  U.prototype.q = new rational();

  U.prototype.d = 0.0;

  U.prototype.k = 0;

  U.prototype.tag = 0;

  function U() {
    cons.car = null;
    cons.cdr = null;
  }

  return U;

})();

CONS = 0;

NUM = 1;

DOUBLE = 2;

STR = 3;

TENSOR = 4;

SYM = 5;

counter = 0;

ABS = counter++;

ADD = counter++;

ADJ = counter++;

AND = counter++;

ARCCOS = counter++;

ARCCOSH = counter++;

ARCSIN = counter++;

ARCSINH = counter++;

ARCTAN = counter++;

ARCTANH = counter++;

ARG = counter++;

ATOMIZE = counter++;

BESSELJ = counter++;

BESSELY = counter++;

BINDING = counter++;

BINOMIAL = counter++;

CEILING = counter++;

CHECK = counter++;

CHOOSE = counter++;

CIRCEXP = counter++;

CLEAR = counter++;

CLOCK = counter++;

COEFF = counter++;

COFACTOR = counter++;

CONDENSE = counter++;

CONJ = counter++;

CONTRACT = counter++;

COS = counter++;

COSH = counter++;

DECOMP = counter++;

DEFINT = counter++;

DEGREE = counter++;

DENOMINATOR = counter++;

DERIVATIVE = counter++;

DET = counter++;

DIM = counter++;

DIRAC = counter++;

DISPLAY = counter++;

DIVISORS = counter++;

DO = counter++;

DOT = counter++;

DRAW = counter++;

DSOLVE = counter++;

EIGEN = counter++;

EIGENVAL = counter++;

EIGENVEC = counter++;

ERF = counter++;

ERFC = counter++;

EVAL = counter++;

EXP = counter++;

EXPAND = counter++;

EXPCOS = counter++;

EXPSIN = counter++;

FACTOR = counter++;

FACTORIAL = counter++;

FACTORPOLY = counter++;

FILTER = counter++;

FLOATF = counter++;

FLOOR = counter++;

FOR = counter++;

GAMMA = counter++;

GCD = counter++;

HERMITE = counter++;

HILBERT = counter++;

IMAG = counter++;

INDEX = counter++;

INNER = counter++;

INTEGRAL = counter++;

INV = counter++;

INVG = counter++;

ISINTEGER = counter++;

ISPRIME = counter++;

LAGUERRE = counter++;

LCM = counter++;

LEADING = counter++;

LEGENDRE = counter++;

LOG = counter++;

MAG = counter++;

MOD = counter++;

MULTIPLY = counter++;

NOT = counter++;

NROOTS = counter++;

NUMBER = counter++;

NUMERATOR = counter++;

OPERATOR = counter++;

OR = counter++;

OUTER = counter++;

POLAR = counter++;

POWER = counter++;

PRIME = counter++;

PRINT = counter++;

PRODUCT = counter++;

QUOTE = counter++;

QUOTIENT = counter++;

RANK = counter++;

RATIONALIZE = counter++;

REAL = counter++;

YYRECT = counter++;

ROOTS = counter++;

SETQ = counter++;

SGN = counter++;

SIMPLIFY = counter++;

SIN = counter++;

SINH = counter++;

SQRT = counter++;

STOP = counter++;

SUBST = counter++;

SUM = counter++;

TAN = counter++;

TANH = counter++;

TAYLOR = counter++;

TEST = counter++;

TESTEQ = counter++;

TESTGE = counter++;

TESTGT = counter++;

TESTLE = counter++;

TESTLT = counter++;

TRANSPOSE = counter++;

UNIT = counter++;

ZERO = counter++;

NIL = counter++;

AUTOEXPAND = counter++;

BAKE = counter++;

LAST = counter++;

TRACE = counter++;

TTY = counter++;

YYE = counter++;

DRAWX = counter++;

METAA = counter++;

METAB = counter++;

METAX = counter++;

SECRETX = counter++;

PI = counter++;

SYMBOL_A = counter++;

SYMBOL_B = counter++;

SYMBOL_C = counter++;

SYMBOL_D = counter++;

SYMBOL_I = counter++;

SYMBOL_J = counter++;

SYMBOL_N = counter++;

SYMBOL_R = counter++;

SYMBOL_S = counter++;

SYMBOL_T = counter++;

SYMBOL_X = counter++;

SYMBOL_Y = counter++;

SYMBOL_Z = counter++;

C1 = counter++;

C2 = counter++;

C3 = counter++;

C4 = counter++;

C5 = counter++;

C6 = counter++;

USR_SYMBOLS = counter++;

E = YYE;

TOS = 100000;

BUF = 10000;

MAX_PROGRAM_SIZE = 100001;

MAXPRIMETAB = 10000;

MAXDIM = 24;

tensor = (function() {
  function tensor() {}

  tensor.prototype.ndim = 0;

  tensor.prototype.dim = (function() {
    var j, ref, results;
    results = [];
    for (j = 0, ref = MAXDIM; 0 <= ref ? j <= ref : j >= ref; 0 <= ref ? j++ : j--) {
      results.push(0);
    }
    return results;
  })();

  tensor.prototype.nelem = 0;

  tensor.prototype.elem = null;

  return tensor;

})();

display = (function() {
  function display() {}

  display.prototype.h = 0;

  display.prototype.w = 0;

  display.prototype.n = 0;

  display.prototype.a = [];

  return display;

})();

text_metric = (function() {
  function text_metric() {}

  text_metric.prototype.ascent = 0;

  text_metric.prototype.descent = 0;

  text_metric.prototype.width = 0;

  return text_metric;

})();

tos = 0;

expanding = 0;

fmt_x = 0;

fmt_index = 0;

fmt_level = 0;

verbosing = 0;

primetab = [];

primetab[MAXPRIMETAB] = 0;

esc_flag = 0;

draw_flag = 0;

mtotal = 0;

trigmode = 0;

logbuf = "";

program_buf = "";

symtab = [];

binding = [];

arglist = [];

stack = [];

frame = 0;

p0 = null;

p1 = null;

p2 = null;

p3 = null;

p4 = null;

p5 = null;

p6 = null;

p7 = null;

p8 = null;

p9 = null;

zero = null;

one = null;

imaginaryunit = null;

symtab = [];

out_buf = "";

out_count = 0;

test_flag = 0;

draw_stop_return = null;

endian = 0;

symbol = function(x) {
  return symtab[x];
};

iscons = function(p) {
  return p.k === CONS;
};

isrational = function(p) {
  return p.k === NUM;
};

isdouble = function(p) {
  return p.k === DOUBLE;
};

isnum = function(p) {
  return isrational(p) || isdouble(p);
};

isstr = function(p) {
  return p.k === STR;
};

istensor = function(p) {
  return p.k === TENSOR;
};

issymbol = function(p) {
  return p.k === SYM;
};

iskeyword = function(p) {
  return issymbol(p) && symnum(p) < NIL;
};

car = function(p) {
  if (iscons(p)) {
    return p.cons.car;
  } else {
    return symbol(NIL);
  }
};

cdr = function(p) {
  if (iscons(p)) {
    return p.cons.cdr;
  } else {
    return symbol(NIL);
  }
};

caar = function(p) {
  return car(car(p));
};

cadr = function(p) {
  return car(cdr(p));
};

cdar = function(p) {
  return cdr(car(p));
};

cddr = function(p) {
  return cdr(cdr(p));
};

caadr = function(p) {
  return car(car(cdr(p)));
};

caddr = function(p) {
  return car(cdr(cdr(p)));
};

cadar = function(p) {
  return car(cdr(car(p)));
};

cdadr = function(p) {
  return cdr(car(cdr(p)));
};

cddar = function(p) {
  return cdr(cdr(car(p)));
};

cdddr = function(p) {
  return cdr(cdr(cdr(p)));
};

caaddr = function(p) {
  return car(car(cdr(cdr(p))));
};

cadadr = function(p) {
  return car(cdr(car(cdr(p))));
};

caddar = function(p) {
  return car(cdr(cdr(car(p))));
};

cdaddr = function(p) {
  return cdr(car(cdr(cdr(p))));
};

cadddr = function(p) {
  return car(cdr(cdr(cdr(p))));
};

cddddr = function(p) {
  return cdr(cdr(cdr(cdr(p))));
};

caddddr = function(p) {
  return car(cdr(cdr(cdr(cdr(p)))));
};

cadaddr = function(p) {
  return car(cdr(car(cdr(cdr(p)))));
};

cddaddr = function(p) {
  return cdr(cdr(car(cdr(cdr(p)))));
};

caddadr = function(p) {
  return car(cdr(cdr(car(cdr(p)))));
};

cdddaddr = function(p) {
  return cdr(cdr(cdr(car(cdr(cdr(p))))));
};

caddaddr = function(p) {
  return car(cdr(cdr(car(cdr(cdr(p))))));
};

isadd = function(p) {
  return car(p) === symbol(ADD);
};

ispower = function(p) {
  return car(p) === symbol(POWER);
};

isfactorial = function(p) {
  return car(p) === symbol(FACTORIAL);
};

MSIGN = function(p) {
  if (p.isPositive()) {
    return 1;
  } else {
    return -1;
  }
};

MLENGTH = function(p) {
  return p[-1];
};

MZERO = function(p) {
  return p.isZero();
};

MEQUAL = function(p, n) {
  return p.equals(n);
};

Eval = function() {
  check_esc_flag();
  save();
  p1 = pop();
  switch (p1.k) {
    case CONS:
      Eval_cons();
      break;
    case NUM:
      push(p1);
      break;
    case DOUBLE:
      push(p1);
      break;
    case STR:
      push(p1);
      break;
    case TENSOR:
      Eval_tensor();
      break;
    case SYM:
      Eval_sym();
      break;
    default:
      stop("atom?");
  }
  return restore();
};

Eval_sym = function() {
  if (iskeyword(p1)) {
    push(p1);
    push(symbol(LAST));
    list(2);
    Eval();
    return;
  }
  p2 = get_binding(p1);
  push(p2);
  if (p1 !== p2) {
    return Eval();
  }
};

Eval_cons = function() {
  if (!issymbol(car(p1))) {
    stop("cons?");
  }
  switch (symnum(car(p1))) {
    case ABS:
      return Eval_abs();
    case ADD:
      return Eval_add();
    case ADJ:
      return Eval_adj();
    case AND:
      return Eval_and();
    case ARCCOS:
      return Eval_arccos();
    case ARCCOSH:
      return Eval_arccosh();
    case ARCSIN:
      return Eval_arcsin();
    case ARCSINH:
      return Eval_arcsinh();
    case ARCTAN:
      return Eval_arctan();
    case ARCTANH:
      return Eval_arctanh();
    case ARG:
      return Eval_arg();
    case ATOMIZE:
      return Eval_atomize();
    case BESSELJ:
      return Eval_besselj();
    case BESSELY:
      return Eval_bessely();
    case BINDING:
      return Eval_binding();
    case BINOMIAL:
      return Eval_binomial();
    case CEILING:
      return Eval_ceiling();
    case CHECK:
      return Eval_check();
    case CHOOSE:
      return Eval_choose();
    case CIRCEXP:
      return Eval_circexp();
    case CLEAR:
      return Eval_clear();
    case CLOCK:
      return Eval_clock();
    case COEFF:
      return Eval_coeff();
    case COFACTOR:
      return Eval_cofactor();
    case CONDENSE:
      return Eval_condense();
    case CONJ:
      return Eval_conj();
    case CONTRACT:
      return Eval_contract();
    case COS:
      return Eval_cos();
    case COSH:
      return Eval_cosh();
    case DECOMP:
      return Eval_decomp();
    case DEGREE:
      return Eval_degree();
    case DEFINT:
      return Eval_defint();
    case DENOMINATOR:
      return Eval_denominator();
    case DERIVATIVE:
      return Eval_derivative();
    case DET:
      return Eval_det();
    case DIM:
      return Eval_dim();
    case DIRAC:
      return Eval_dirac();
    case DISPLAY:
      return Eval_display();
    case DIVISORS:
      return Eval_divisors();
    case DO:
      return Eval_do();
    case DOT:
      return Eval_inner();
    case DRAW:
      return Eval_draw();
    case DSOLVE:
      return Eval_dsolve();
    case EIGEN:
      return Eval_eigen();
    case EIGENVAL:
      return Eval_eigenval();
    case EIGENVEC:
      return Eval_eigenvec();
    case ERF:
      return Eval_erf();
    case ERFC:
      return Eval_erfc();
    case EVAL:
      return Eval_Eval();
    case EXP:
      return Eval_exp();
    case EXPAND:
      return Eval_expand();
    case EXPCOS:
      return Eval_expcos();
    case EXPSIN:
      return Eval_expsin();
    case FACTOR:
      return Eval_factor();
    case FACTORIAL:
      return Eval_factorial();
    case FACTORPOLY:
      return Eval_factorpoly();
    case FILTER:
      return Eval_filter();
    case FLOATF:
      return Eval_float();
    case FLOOR:
      return Eval_floor();
    case FOR:
      return Eval_for();
    case GAMMA:
      return Eval_gamma();
    case GCD:
      return Eval_gcd();
    case HERMITE:
      return Eval_hermite();
    case HILBERT:
      return Eval_hilbert();
    case IMAG:
      return Eval_imag();
    case INDEX:
      return Eval_index();
    case INNER:
      return Eval_inner();
    case INTEGRAL:
      return Eval_integral();
    case INV:
      return Eval_inv();
    case INVG:
      return Eval_invg();
    case ISINTEGER:
      return Eval_isinteger();
    case ISPRIME:
      return Eval_isprime();
    case LAGUERRE:
      return Eval_laguerre();
    case LCM:
      return Eval_lcm();
    case LEADING:
      return Eval_leading();
    case LEGENDRE:
      return Eval_legendre();
    case LOG:
      return Eval_log();
    case MAG:
      return Eval_mag();
    case MOD:
      return Eval_mod();
    case MULTIPLY:
      return Eval_multiply();
    case NOT:
      return Eval_not();
    case NROOTS:
      return Eval_nroots();
    case NUMBER:
      return Eval_number();
    case NUMERATOR:
      return Eval_numerator();
    case OPERATOR:
      return Eval_operator();
    case OR:
      return Eval_or();
    case OUTER:
      return Eval_outer();
    case POLAR:
      return Eval_polar();
    case POWER:
      return Eval_power();
    case PRIME:
      return Eval_prime();
    case PRINT:
      return Eval_display();
    case PRODUCT:
      return Eval_product();
    case QUOTE:
      return Eval_quote();
    case QUOTIENT:
      return Eval_quotient();
    case RANK:
      return Eval_rank();
    case RATIONALIZE:
      return Eval_rationalize();
    case REAL:
      return Eval_real();
    case YYRECT:
      return Eval_rect();
    case ROOTS:
      return Eval_roots();
    case SETQ:
      return Eval_setq();
    case SGN:
      return Eval_sgn();
    case SIMPLIFY:
      return Eval_simplify();
    case SIN:
      return Eval_sin();
    case SINH:
      return Eval_sinh();
    case SQRT:
      return Eval_sqrt();
    case STOP:
      return Eval_stop();
    case SUBST:
      return Eval_subst();
    case SUM:
      return Eval_sum();
    case TAN:
      return Eval_tan();
    case TANH:
      return Eval_tanh();
    case TAYLOR:
      return Eval_taylor();
    case TEST:
      return Eval_test();
    case TESTEQ:
      return Eval_testeq();
    case TESTGE:
      return Eval_testge();
    case TESTGT:
      return Eval_testgt();
    case TESTLE:
      return Eval_testle();
    case TESTLT:
      return Eval_testlt();
    case TRANSPOSE:
      return Eval_transpose();
    case UNIT:
      return Eval_unit();
    case ZERO:
      return Eval_zero();
    default:
      return Eval_user_function();
  }
};

Eval_binding = function() {
  return push(get_binding(cadr(p1)));
};

Eval_check = function() {
  push(cadr(p1));
  Eval_predicate();
  p1 = pop();
  if (iszero(p1)) {
    stop("check(arg): arg is zero");
  }
  return push(symbol(NIL));
};

Eval_det = function() {
  push(cadr(p1));
  Eval();
  return det();
};

Eval_dim = function() {
  var n;
  push(cadr(p1));
  Eval();
  p2 = pop();
  if (iscons(cddr(p1))) {
    push(caddr(p1));
    Eval();
    n = pop_integer();
  } else {
    n = 1;
  }
  if (!istensor(p2)) {
    return push_integer(1);
  } else if (n < 1 || n > p2.tensor.ndim) {
    return push(p1);
  } else {
    return push_integer(p2.tensor.dim[n - 1]);
  }
};

Eval_divisors = function() {
  push(cadr(p1));
  Eval();
  return divisors();
};

Eval_do = function() {
  var results;
  push(car(p1));
  p1 = cdr(p1);
  results = [];
  while (iscons(p1)) {
    pop();
    push(car(p1));
    Eval();
    results.push(p1 = cdr(p1));
  }
  return results;
};

Eval_dsolve = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  push(cadddr(p1));
  Eval();
  return dsolve();
};

Eval_Eval = function() {
  push(cadr(p1));
  Eval();
  p1 = cddr(p1);
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    push(cadr(p1));
    Eval();
    subst();
    p1 = cddr(p1);
  }
  return Eval();
};

Eval_exp = function() {
  push(cadr(p1));
  Eval();
  return exponential();
};

Eval_factorial = function() {
  push(cadr(p1));
  Eval();
  return factorial();
};

Eval_factorpoly = function() {
  var results;
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  factorpoly();
  p1 = cdr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    factorpoly();
    results.push(p1 = cdr(p1));
  }
  return results;
};

Eval_hermite = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  return hermite();
};

Eval_hilbert = function() {
  push(cadr(p1));
  Eval();
  return hilbert();
};

Eval_index = function() {
  var h;
  h = tos;
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    p1 = cdr(p1);
  }
  return index_function(tos - h);
};

Eval_inv = function() {
  push(cadr(p1));
  Eval();
  return inv();
};

Eval_invg = function() {
  push(cadr(p1));
  Eval();
  return invg();
};

Eval_isinteger = function() {
  var n;
  push(cadr(p1));
  Eval();
  p1 = pop();
  if (isrational(p1)) {
    if (isinteger(p1)) {
      push(one);
    } else {
      push(zero);
    }
    return;
  }
  if (isdouble(p1)) {
    n = Math.floor(p1.d);
    if (n === p1.d) {
      push(one);
    } else {
      push(zero);
    }
    return;
  }
  push_symbol(ISINTEGER);
  push(p1);
  return list(2);
};

Eval_multiply = function() {
  var results;
  push(cadr(p1));
  Eval();
  p1 = cddr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    multiply();
    results.push(p1 = cdr(p1));
  }
  return results;
};

Eval_number = function() {
  push(cadr(p1));
  Eval();
  p1 = pop();
  if (p1.k === NUM || p1.k === DOUBLE) {
    return push_integer(1);
  } else {
    return push_integer(0);
  }
};

Eval_operator = function() {
  var h;
  h = tos;
  push_symbol(OPERATOR);
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    p1 = cdr(p1);
  }
  return list(tos - h);
};

Eval_print = function() {
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    if (equaln(get_binding(symbol(TTY)), 1)) {
      printline(pop());
    } else {
      display(pop());
    }
    p1 = cdr(p1);
  }
  return push(symbol(NIL));
};

Eval_quote = function() {
  return push(cadr(p1));
};

Eval_rank = function() {
  push(cadr(p1));
  Eval();
  p1 = pop();
  if (istensor(p1)) {
    return push_integer(p1.tensor.ndim);
  } else {
    return push(zero);
  }
};

setq_indexed = function() {
  var h;
  p4 = cadadr(p1);
  if (!issymbol(p4)) {
    stop("indexed assignment: error in symbol");
  }
  h = tos;
  push(caddr(p1));
  Eval();
  p2 = cdadr(p1);
  while (iscons(p2)) {
    push(car(p2));
    Eval();
    p2 = cdr(p2);
  }
  set_component(tos - h);
  p3 = pop();
  set_binding(p4, p3);
  return push(symbol(NIL));
};

Eval_setq = function() {
  if (caadr(p1) === symbol(INDEX)) {
    setq_indexed();
    return;
  }
  if (iscons(cadr(p1))) {
    define_user_function();
    return;
  }
  if (!issymbol(cadr(p1))) {
    stop("symbol assignment: error in symbol");
  }
  push(caddr(p1));
  Eval();
  p2 = pop();
  set_binding(cadr(p1), p2);
  return push(symbol(NIL));
};

Eval_sqrt = function() {
  push(cadr(p1));
  Eval();
  push_rational(1, 2);
  return power();
};

Eval_stop = function() {
  return stop("user stop");
};

Eval_subst = function() {
  push(cadddr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  push(cadr(p1));
  Eval();
  subst();
  return Eval();
};

Eval_unit = function() {
  var i, j, n, ref;
  push(cadr(p1));
  Eval();
  n = pop_integer();
  if (n < 2) {
    push(p1);
    return;
  }
  p1 = alloc_tensor(n * n);
  p1.tensor.ndim = 2;
  p1.tensor.dim[0] = n;
  p1.tensor.dim[1] = n;
  for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    p1.tensor.elem[n * i + i] = one;
  }
  return push(p1);
};

Eval_noexpand = function() {
  var x;
  x = expanding;
  expanding = 0;
  Eval();
  return expanding = x;
};

Eval_predicate = function() {
  save();
  p1 = pop();
  if (car(p1) === symbol(SETQ)) {
    Eval_testeq();
  } else {
    push(p1);
    Eval();
  }
  return restore();
};

init = function() {
  var flag, i, j, l, ref, ref1;
  i = 0;
  flag = 0;
  tos = 0;
  esc_flag = 0;
  draw_flag = 0;
  frame = TOS;
  if (flag) {
    return;
  }
  flag = 1;
  for (i = j = 0, ref = NSYM; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    symtab[i] = new U();
  }
  for (i = l = 0, ref1 = NSYM; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
    symtab[i].k = SYM;
    binding[i] = symtab[i];
    arglist[i] = symbol(NIL);
  }
  p0 = symbol(NIL);
  p1 = symbol(NIL);
  p2 = symbol(NIL);
  p3 = symbol(NIL);
  p4 = symbol(NIL);
  p5 = symbol(NIL);
  p6 = symbol(NIL);
  p7 = symbol(NIL);
  p8 = symbol(NIL);
  p9 = symbol(NIL);
  std_symbol("abs", ABS);
  std_symbol("add", ADD);
  std_symbol("adj", ADJ);
  std_symbol("and", AND);
  std_symbol("arccos", ARCCOS);
  std_symbol("arccosh", ARCCOSH);
  std_symbol("arcsin", ARCSIN);
  std_symbol("arcsinh", ARCSINH);
  std_symbol("arctan", ARCTAN);
  std_symbol("arctanh", ARCTANH);
  std_symbol("arg", ARG);
  std_symbol("atomize", ATOMIZE);
  std_symbol("besselj", BESSELJ);
  std_symbol("bessely", BESSELY);
  std_symbol("binding", BINDING);
  std_symbol("binomial", BINOMIAL);
  std_symbol("ceiling", CEILING);
  std_symbol("check", CHECK);
  std_symbol("choose", CHOOSE);
  std_symbol("circexp", CIRCEXP);
  std_symbol("clear", CLEAR);
  std_symbol("clock", CLOCK);
  std_symbol("coeff", COEFF);
  std_symbol("cofactor", COFACTOR);
  std_symbol("condense", CONDENSE);
  std_symbol("conj", CONJ);
  std_symbol("contract", CONTRACT);
  std_symbol("cos", COS);
  std_symbol("cosh", COSH);
  std_symbol("decomp", DECOMP);
  std_symbol("defint", DEFINT);
  std_symbol("deg", DEGREE);
  std_symbol("denominator", DENOMINATOR);
  std_symbol("det", DET);
  std_symbol("derivative", DERIVATIVE);
  std_symbol("dim", DIM);
  std_symbol("dirac", DIRAC);
  std_symbol("display", DISPLAY);
  std_symbol("divisors", DIVISORS);
  std_symbol("do", DO);
  std_symbol("dot", DOT);
  std_symbol("draw", DRAW);
  std_symbol("dsolve", DSOLVE);
  std_symbol("erf", ERF);
  std_symbol("erfc", ERFC);
  std_symbol("eigen", EIGEN);
  std_symbol("eigenval", EIGENVAL);
  std_symbol("eigenvec", EIGENVEC);
  std_symbol("eval", EVAL);
  std_symbol("exp", EXP);
  std_symbol("expand", EXPAND);
  std_symbol("expcos", EXPCOS);
  std_symbol("expsin", EXPSIN);
  std_symbol("factor", FACTOR);
  std_symbol("factorial", FACTORIAL);
  std_symbol("factorpoly", FACTORPOLY);
  std_symbol("filter", FILTER);
  std_symbol("float", FLOATF);
  std_symbol("floor", FLOOR);
  std_symbol("for", FOR);
  std_symbol("Gamma", GAMMA);
  std_symbol("gcd", GCD);
  std_symbol("hermite", HERMITE);
  std_symbol("hilbert", HILBERT);
  std_symbol("imag", IMAG);
  std_symbol("component", INDEX);
  std_symbol("inner", INNER);
  std_symbol("integral", INTEGRAL);
  std_symbol("inv", INV);
  std_symbol("invg", INVG);
  std_symbol("isinteger", ISINTEGER);
  std_symbol("isprime", ISPRIME);
  std_symbol("laguerre", LAGUERRE);
  std_symbol("lcm", LCM);
  std_symbol("leading", LEADING);
  std_symbol("legendre", LEGENDRE);
  std_symbol("log", LOG);
  std_symbol("mag", MAG);
  std_symbol("mod", MOD);
  std_symbol("multiply", MULTIPLY);
  std_symbol("not", NOT);
  std_symbol("nroots", NROOTS);
  std_symbol("number", NUMBER);
  std_symbol("numerator", NUMERATOR);
  std_symbol("operator", OPERATOR);
  std_symbol("or", OR);
  std_symbol("outer", OUTER);
  std_symbol("polar", POLAR);
  std_symbol("power", POWER);
  std_symbol("prime", PRIME);
  std_symbol("print", PRINT);
  std_symbol("product", PRODUCT);
  std_symbol("quote", QUOTE);
  std_symbol("quotient", QUOTIENT);
  std_symbol("rank", RANK);
  std_symbol("rationalize", RATIONALIZE);
  std_symbol("real", REAL);
  std_symbol("rect", YYRECT);
  std_symbol("roots", ROOTS);
  std_symbol("equals", SETQ);
  std_symbol("sgn", SGN);
  std_symbol("simplify", SIMPLIFY);
  std_symbol("sin", SIN);
  std_symbol("sinh", SINH);
  std_symbol("sqrt", SQRT);
  std_symbol("stop", STOP);
  std_symbol("subst", SUBST);
  std_symbol("sum", SUM);
  std_symbol("tan", TAN);
  std_symbol("tanh", TANH);
  std_symbol("taylor", TAYLOR);
  std_symbol("test", TEST);
  std_symbol("testeq", TESTEQ);
  std_symbol("testge", TESTGE);
  std_symbol("testgt", TESTGT);
  std_symbol("testle", TESTLE);
  std_symbol("testlt", TESTLT);
  std_symbol("transpose", TRANSPOSE);
  std_symbol("unit", UNIT);
  std_symbol("zero", ZERO);
  std_symbol("nil", NIL);
  std_symbol("autoexpand", AUTOEXPAND);
  std_symbol("bake", BAKE);
  std_symbol("last", LAST);
  std_symbol("trace", TRACE);
  std_symbol("tty", TTY);
  std_symbol("~", YYE);
  std_symbol("$DRAWX", DRAWX);
  std_symbol("$METAA", METAA);
  std_symbol("$METAB", METAB);
  std_symbol("$METAX", METAX);
  std_symbol("$SECRETX", SECRETX);
  std_symbol("pi", PI);
  std_symbol("a", SYMBOL_A);
  std_symbol("b", SYMBOL_B);
  std_symbol("c", SYMBOL_C);
  std_symbol("d", SYMBOL_D);
  std_symbol("i", SYMBOL_I);
  std_symbol("j", SYMBOL_J);
  std_symbol("n", SYMBOL_N);
  std_symbol("r", SYMBOL_R);
  std_symbol("s", SYMBOL_S);
  std_symbol("t", SYMBOL_T);
  std_symbol("x", SYMBOL_X);
  std_symbol("y", SYMBOL_Y);
  std_symbol("z", SYMBOL_Z);
  std_symbol("$C1", C1);
  std_symbol("$C2", C2);
  std_symbol("$C3", C3);
  std_symbol("$C4", C4);
  std_symbol("$C5", C5);
  std_symbol("$C6", C6);
  push_integer(0);
  zero = pop();
  push_integer(1);
  one = pop();
  push_symbol(POWER);
  push_integer(-1);
  push_rational(1, 2);
  list(3);
  imaginaryunit = pop();
  return defn();
};

defn_str = ["e=exp(1)", "i=sqrt(-1)", "autoexpand=1", "trange=(-pi,pi)", "xrange=(-10,10)", "yrange=(-10,10)", "last=0", "trace=0", "tty=0", "cross(u,v)=(u[2]*v[3]-u[3]*v[2],u[3]*v[1]-u[1]*v[3],u[1]*v[2]-u[2]*v[1])", "curl(v)=(d(v[3],y)-d(v[2],z),d(v[1],z)-d(v[3],x),d(v[2],x)-d(v[1],y))", "div(v)=d(v[1],x)+d(v[2],y)+d(v[3],z)", "ln(x)=log(x)"];

defn = function() {
  var i, j, n, ref, results;
  i = 0;
  n = 0;
  n = defn_str.length;
  results = [];
  for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    console.log("scanning " + defn_str[i]);
    scan(defn_str[i]);
    console.log("... evaling " + defn_str[i]);
    debugger;
    Eval();
    results.push(pop());
  }
  return results;
};

iszero = function(p) {
  var i, j, ref;
  switch (p.k) {
    case NUM:
      if (MZERO(p.q.a)) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d === 0.0) {
        return 1;
      }
      break;
    case TENSOR:
      for (i = j = 0, ref = p.tensor.nelem; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        if (!iszero(p.tensor.elem[i])) {
          return 0;
        }
      }
      return 1;
  }
  return 0;
};

isnegativenumber = function(p) {
  switch (p.k) {
    case NUM:
      if (MSIGN(p.q.a) === -1) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d < 0.0) {
        return 1;
      }
  }
  return 0;
};

isplusone = function(p) {
  switch (p.k) {
    case NUM:
      if (MEQUAL(p.q.a, 1) && MEQUAL(p.q.b, 1)) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d === 1.0) {
        return 1;
      }
  }
  return 0;
};

isminusone = function(p) {
  switch (p.k) {
    case NUM:
      if (MEQUAL(p.q.a, -1) && MEQUAL(p.q.b, 1)) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d === -1.0) {
        return 1;
      }
  }
  return 0;
};

isinteger = function(p) {
  if (p.k === NUM && MEQUAL(p.q.b, 1)) {
    return 1;
  } else {
    return 0;
  }
};

isnonnegativeinteger = function(p) {
  if (isrational(p) && MEQUAL(p.q.b, 1) && MSIGN(p.q.a) === 1) {
    return 1;
  } else {
    return 0;
  }
};

isposint = function(p) {
  if (isinteger(p) && MSIGN(p.q.a) === 1) {
    return 1;
  } else {
    return 0;
  }
};

ispoly = function(p, x) {
  if (find(p, x)) {
    return ispoly_expr(p, x);
  } else {
    return 0;
  }
};

ispoly_expr = function(p, x) {
  if (car(p) === symbol(ADD)) {
    p = cdr(p);
    while (iscons(p)) {
      if (!ispoly_term(car(p), x)) {
        return 0;
      }
      p = cdr(p);
    }
    return 1;
  } else {
    return ispoly_term(p, x);
  }
};

ispoly_term = function(p, x) {
  if (car(p) === symbol(MULTIPLY)) {
    p = cdr(p);
    while (iscons(p)) {
      if (!ispoly_factor(car(p), x)) {
        return 0;
      }
      p = cdr(p);
    }
    return 1;
  } else {
    return ispoly_factor(p, x);
  }
};

ispoly_factor = function(p, x) {
  if (equal(p, x)) {
    return 1;
  }
  if (car(p) === symbol(POWER) && equal(cadr(p), x)) {
    if (isposint(caddr(p))) {
      return 1;
    } else {
      return 0;
    }
  }
  if (find(p, x)) {
    return 0;
  } else {
    return 1;
  }
};

isnegativeterm = function(p) {
  if (isnegativenumber(p)) {
    return 1;
  } else if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {
    return 1;
  } else {
    return 0;
  }
};

isimaginarynumber = function(p) {
  if ((car(p) === symbol(MULTIPLY) && length(p) === 3 && isnum(cadr(p))('' && equal(caddr(p), imaginaryunit))) || equal(p, imaginaryunit)) {
    return 1;
  } else {
    return 0;
  }
};

iscomplexnumber = function(p) {
  if ((car(p) === symbol(ADD) && length(p) === 3 && isnum(cadr(p)) && isimaginarynumber(caddr(p))) || isimaginarynumber(p)) {
    return 1;
  } else {
    return 0;
  }
};

iseveninteger = function(p) {
  if (isinteger(p) && (p.q.a[0] & 1) === 0) {
    return 1;
  } else {
    return 0;
  }
};

isnegative = function(p) {
  if (car(p) === symbol(ADD) && isnegativeterm(cadr(p))) {
    return 1;
  } else if (isnegativeterm(p)) {
    return 1;
  } else {
    return 0;
  }
};

issymbolic = function(p) {
  if (issymbol(p)) {
    return 1;
  } else {
    while (iscons(p)) {
      if (issymbolic(car(p))) {
        return 1;
      }
      p = cdr(p);
    }
    return 0;
  }
};

isintegerfactor = function(p) {
  if (isinteger(p) || car(p) === symbol(POWER) && isinteger(cadr(p)) && isinteger(caddr(p))) {
    return 1;
  } else {
    return 0;
  }
};

isoneover = function(p) {
  if (car(p) === symbol(POWER) && isminusone(caddr(p))) {
    return 1;
  } else {
    return 0;
  }
};

isfraction = function(p) {
  if (p.k === NUM && !MEQUAL(p.q.b, 1)) {
    return 1;
  } else {
    return 0;
  }
};

equaln = function(p, n) {
  switch (p.k) {
    case NUM:
      if (MEQUAL(p.q.a, n) && MEQUAL(p.q.b, 1)) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d === n) {
        return 1;
      }
  }
  return 0;
};

equalq = function(p, a, b) {
  switch (p.k) {
    case NUM:
      if (MEQUAL(p.q.a, a) && MEQUAL(p.q.b, b)) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d === a / b) {
        return 1;
      }
  }
  return 0;
};

isoneoversqrttwo = function(p) {
  if (car(p) === symbol(POWER) && equaln(cadr(p), 2) && equalq(caddr(p), -1, 2)) {
    return 1;
  } else {
    return 0;
  }
};

isminusoneoversqrttwo = function(p) {
  if (car(p) === symbol(MULTIPLY) && equaln(cadr(p), -1) && isoneoversqrttwo(caddr(p)) && length(p) === 3) {
    return 1;
  } else {
    return 0;
  }
};

isfloating = function(p) {
  if (p.k === DOUBLE) {
    return 1;
  }
  while (iscons(p)) {
    if (isfloating(car(p))) {
      return 1;
    }
    p = cdr(p);
  }
  return 0;
};

isimaginaryunit = function(p) {
  if (equal(p, imaginaryunit)) {
    return 1;
  } else {
    return 0;
  }
};

isquarterturn = function(p) {
  var minussign, n;
  n = 0;
  minussign = 0;
  if (car(p) !== symbol(MULTIPLY)) {
    return 0;
  }
  if (equal(cadr(p), imaginaryunit)) {
    if (caddr(p) !== symbol(PI)) {
      return 0;
    }
    if (length(p) !== 3) {
      return 0;
    }
    return 2;
  }
  if (!isnum(cadr(p))) {
    return 0;
  }
  if (!equal(caddr(p), imaginaryunit)) {
    return 0;
  }
  if (cadddr(p) !== symbol(PI)) {
    return 0;
  }
  if (length(p) !== 4) {
    return 0;
  }
  push(cadr(p));
  push_integer(2);
  multiply();
  n = pop_integer();
  if (n === int(0x80000000)) {
    return 0;
  }
  if (n < 1) {
    minussign = 1;
    n = -n;
  }
  switch (n % 4) {
    case 0:
      n = 1;
      break;
    case 1:
      if (minussign) {
        n = 4;
      } else {
        n = 3;
      }
      break;
    case 2:
      n = 2;
      break;
    case 3:
      if (minussign) {
        n = 3;
      } else {
        n = 4;
      }
  }
  return n;
};

isnpi = function(p) {
  var doNothing, n;
  n = 0;
  if (p === symbol(PI)) {
    return 2;
  }
  if (car(p) === symbol(MULTIPLY) && isnum(cadr(p)) && caddr(p) === symbol(PI) && length(p) === 3) {
    doNothing = 0;
  } else {
    return 0;
  }
  push(cadr(p));
  push_integer(2);
  multiply();
  n = pop_integer();
  if (n === int(0x80000000)) {
    return 0;
  }
  if (n < 0) {
    n = 4 - (-n) % 4;
  } else {
    n = 1 + (n - 1) % 4;
  }
  return n;
};

list = function(n) {
  var i, j, ref, results;
  push(symbol(NIL));
  results = [];
  for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    results.push(cons());
  }
  return results;
};

multiply = function() {
  if (esc_flag) {
    stop("escape key stop");
  }
  if (isnum(stack[tos - 2]) && isnum(stack[tos - 1])) {
    return multiply_numbers();
  } else {
    save();
    yymultiply();
    return restore();
  }
};

yymultiply = function() {
  var h, i, j, n, ref, ref1;
  h = 0;
  i = 0;
  n = 0;
  p2 = pop();
  p1 = pop();
  h = tos;
  if (iszero(p1) || iszero(p2)) {
    push(zero);
    return;
  }
  if (expanding && isadd(p1)) {
    p1 = cdr(p1);
    push(zero);
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      multiply();
      add();
      p1 = cdr(p1);
    }
    return;
  }
  if (expanding && isadd(p2)) {
    p2 = cdr(p2);
    push(zero);
    while (iscons(p2)) {
      push(p1);
      push(car(p2));
      multiply();
      add();
      p2 = cdr(p2);
    }
    return;
  }
  if (!istensor(p1) && istensor(p2)) {
    push(p1);
    push(p2);
    scalar_times_tensor();
    return;
  }
  if (istensor(p1) && !istensor(p2)) {
    push(p1);
    push(p2);
    tensor_times_scalar();
    return;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    p1 = cdr(p1);
  } else {
    push(p1);
    list(1);
    p1 = pop();
  }
  if (car(p2) === symbol(MULTIPLY)) {
    p2 = cdr(p2);
  } else {
    push(p2);
    list(1);
    p2 = pop();
  }
  if (isnum(car(p1)) && isnum(car(p2))) {
    push(car(p1));
    push(car(p2));
    multiply_numbers();
    p1 = cdr(p1);
    p2 = cdr(p2);
  } else if (isnum(car(p1))) {
    push(car(p1));
    p1 = cdr(p1);
  } else if (isnum(car(p2))) {
    push(car(p2));
    p2 = cdr(p2);
  } else {
    push(one);
  }
  parse_p1();
  parse_p2();
  while (iscons(p1) && iscons(p2)) {
    if (caar(p1) === symbol(OPERATOR) && caar(p2) === symbol(OPERATOR)) {
      push_symbol(OPERATOR);
      push(cdar(p1));
      push(cdar(p2));
      append();
      cons();
      p1 = cdr(p1);
      p2 = cdr(p2);
      parse_p1();
      parse_p2();
      continue;
    }
    switch (cmp_expr(p3, p4)) {
      case -1:
        push(car(p1));
        p1 = cdr(p1);
        parse_p1();
        break;
      case 1:
        push(car(p2));
        p2 = cdr(p2);
        parse_p2();
        break;
      case 0:
        combine_factors(h);
        p1 = cdr(p1);
        p2 = cdr(p2);
        parse_p1();
        parse_p2();
        break;
      default:
        stop("internal error 2");
    }
  }
  while (iscons(p1)) {
    push(car(p1));
    p1 = cdr(p1);
  }
  while (iscons(p2)) {
    push(car(p2));
    p2 = cdr(p2);
  }
  __normalize_radical_factors(h);
  if (expanding) {
    for (i = j = ref = h, ref1 = tos; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
      if (isadd(stack[i])) {
        multiply_all(tos - h);
        return;
      }
    }
  }
  n = tos - h;
  if (n === 1) {
    return;
  }
  if (isrational(stack[h]) && equaln(stack[h], 1)) {
    if (n === 2) {
      p7 = pop();
      pop();
      push(p7);
    } else {
      stack[h] = symbol(MULTIPLY);
      list(n);
    }
    return;
  }
  list(n);
  p7 = pop();
  push_symbol(MULTIPLY);
  push(p7);
  return cons();
};

parse_p1 = function() {
  p3 = car(p1);
  p5 = one;
  if (car(p3) === symbol(POWER)) {
    p5 = caddr(p3);
    return p3 = cadr(p3);
  }
};

parse_p2 = function() {
  p4 = car(p2);
  p6 = one;
  if (car(p4) === symbol(POWER)) {
    p6 = caddr(p4);
    return p4 = cadr(p4);
  }
};

combine_factors = function(h) {
  push(p4);
  push(p5);
  push(p6);
  add();
  power();
  p7 = pop();
  if (isnum(p7)) {
    push(stack[h]);
    push(p7);
    multiply_numbers();
    return stack[h] = pop();
  } else if (car(p7) === symbol(MULTIPLY)) {
    if (isnum(cadr(p7)) && cdddr(p7) === symbol(NIL)) {
      push(stack[h]);
      push(cadr(p7));
      multiply_numbers();
      stack[h] = pop();
      return push(caddr(p7));
    } else {
      return push(p7);
    }
  } else {
    return push(p7);
  }
};

gp = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, -6, -7, -8, -3, -4, -5, 13, 14, 15, -16, 9, 10, 11, -12], [0, 0, 6, -1, -11, 10, -2, -15, 14, 12, -5, 4, -9, 16, -8, 7, -13], [0, 0, 7, 11, -1, -9, 15, -2, -13, 5, 12, -3, -10, 8, 16, -6, -14], [0, 0, 8, -10, 9, -1, -14, 13, -2, -4, 3, 12, -11, -7, 6, 16, -15], [0, 0, 3, 2, 15, -14, 1, 11, -10, 16, -8, 7, 13, 12, -5, 4, 9], [0, 0, 4, -15, 2, 13, -11, 1, 9, 8, 16, -6, 14, 5, 12, -3, 10], [0, 0, 5, 14, -13, 2, 10, -9, 1, -7, 6, 16, 15, -4, 3, 12, 11], [0, 0, 13, 12, -5, 4, 16, -8, 7, -1, -11, 10, -3, -2, -15, 14, -6], [0, 0, 14, 5, 12, -3, 8, 16, -6, 11, -1, -9, -4, 15, -2, -13, -7], [0, 0, 15, -4, 3, 12, -7, 6, 16, -10, 9, -1, -5, -14, 13, -2, -8], [0, 0, 16, -9, -10, -11, -13, -14, -15, -3, -4, -5, 1, -6, -7, -8, 2], [0, 0, 9, -16, 8, -7, -12, 5, -4, -2, -15, 14, 6, -1, -11, 10, 3], [0, 0, 10, -8, -16, 6, -5, -12, 3, 15, -2, -13, 7, 11, -1, -9, 4], [0, 0, 11, 7, -6, -16, 4, -3, -12, -14, 13, -2, 8, -10, 9, -1, 5], [0, 0, 12, 13, 14, 15, 9, 10, 11, -6, -7, -8, -2, -3, -4, -5, -1]];

combine_gammas = function(h) {
  var n;
  int(n);
  n = gp[Math.floor(p1.gamma)][Math.floor(p2.gamma)];
  if (n < 0) {
    n = -n;
    push(stack[h]);
    negate();
    stack[h] = pop();
  }
  if (n > 1) {
    return push(_gamma[n]);
  }
};

multiply_noexpand = function() {
  var x;
  int(x);
  x = expanding;
  expanding = 0;
  multiply();
  return expanding = x;
};

multiply_all = function(n) {
  var h, i, j, ref;
  int(h, i);
  if (n === 1) {
    return;
  }
  if (n === 0) {
    push(one);
    return;
  }
  h = tos - n;
  push(stack[h]);
  for (i = j = 1, ref = n; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
    push(stack[h + i]);
    multiply();
  }
  stack[h] = pop();
  return tos = h + 1;
};

multiply_all_noexpand = function(n) {
  var x;
  x = expanding;
  expanding = 0;
  multiply_all(n);
  return expanding = x;
};

divide = function() {
  if (isnum(stack[tos - 2]) && isnum(stack[tos - 1])) {
    return divide_numbers();
  } else {
    inverse();
    return multiply();
  }
};

inverse = function() {
  if (isnum(stack[tos - 1])) {
    return invert_number();
  } else {
    push_integer(-1);
    return power();
  }
};

reciprocate = function() {
  if (isnum(stack[tos - 1])) {
    return invert_number();
  } else {
    push_integer(-1);
    return power();
  }
};

negate = function() {
  if (isnum(stack[tos - 1])) {
    return negate_number();
  } else {
    push_integer(-1);
    return multiply();
  }
};

negate_expand = function() {
  var x;
  x = expanding;
  expanding = 1;
  negate();
  return expanding = x;
};

negate_noexpand = function() {
  var x;
  x = expanding;
  expanding = 0;
  negate();
  return expanding = x;
};

__normalize_radical_factors = function(h) {
  var i, j, l, m, ref, ref1, ref2, ref3, ref4, ref5;
  if (isplusone(stack[h]) || isminusone(stack[h]) || isdouble(stack[h])) {
    return;
  }
  for (i = j = ref = h + 1, ref1 = tos; ref <= ref1 ? j < ref1 : j > ref1; i = ref <= ref1 ? ++j : --j) {
    if (__is_radical_number(stack[i])) {
      break;
    }
  }
  if (i === tos) {
    return;
  }
  save();
  push(stack[h]);
  mp_numerator();
  p1 = pop();
  for (i = l = ref2 = h + 1, ref3 = tos; ref2 <= ref3 ? l < ref3 : l > ref3; i = ref2 <= ref3 ? ++l : --l) {
    if (isplusone(p1) || isminusone(p1)) {
      break;
    }
    if (!__is_radical_number(stack[i])) {
      continue;
    }
    p3 = cadr(stack[i]);
    p4 = caddr(stack[i]);
    if (!isnegativenumber(p4)) {
      continue;
    }
    push(p1);
    push(p3);
    divide();
    p5 = pop();
    if (!isinteger(p5)) {
      continue;
    }
    p1 = p5;
    push_symbol(POWER);
    push(p3);
    push(one);
    push(p4);
    add();
    list(3);
    stack[i] = pop();
  }
  push(stack[h]);
  mp_denominator();
  p2 = pop();
  for (i = m = ref4 = h + 1, ref5 = tos; ref4 <= ref5 ? m < ref5 : m > ref5; i = ref4 <= ref5 ? ++m : --m) {
    if (isplusone(p2)) {
      break;
    }
    if (!__is_radical_number(stack[i])) {
      continue;
    }
    p3 = cadr(stack[i]);
    p4 = caddr(stack[i]);
    if (isnegativenumber(p4)) {
      continue;
    }
    push(p2);
    push(p3);
    divide();
    p5 = pop();
    if (!isinteger(p5)) {
      continue;
    }
    p2 = p5;
    push_symbol(POWER);
    push(p3);
    push(p4);
    push(one);
    subtract();
    list(3);
    stack[i] = pop();
  }
  push(p1);
  push(p2);
  divide();
  stack[h] = pop();
  return restore();
};

__is_radical_number = function(p) {
  if (car(p) === symbol(POWER) && isnum(cadr(p)) && isnum(caddr(p)) && !isminusone(cadr(p))) {
    return 1;
  } else {
    return 0;
  }
};

s = ["0*a", "0", "a*0", "0", "1*a", "a", "a*1", "a", "a*a", "a^2", "a^2*a", "a^3", "a*a^2", "a^3", "a^2*a^2", "a^4", "2^a*2^(3-a)", "8", "sqrt(2)/2", "2^(-1/2)", "2/sqrt(2)", "2^(1/2)", "-sqrt(2)/2", "-1/(2^(1/2))", "2^(1/2-a)*2^a/10", "1/(5*2^(1/2))", "i/4", "1/4*i", "1/(4 i)", "-1/4*i", "1.0 pi 1/2", "0.5*pi", "1.0 1/2 pi", "0.5*pi"];

isspace = function(s) {
  return s === ' ' || s === '\t' || s === '\n' || s === '\v' || s === '\f' || s === '\r';
};

isdigit = function(str) {
  return /^\d+$/.test(str);
};

isalpha = function(str) {
  if (str == null) {
    debugger;
  }
  return str.search(/[^A-Za-z\s]/) === -1;
};

isalnum = function(str) {
  return isalpha(str) || isdigit(str);
};

stop = function(s) {
  debugger;
  console.log("Stop: ");
  console.log(s);
  return console.log("\n");
};

run = function(s) {
  var i, n, results;
  i = 0;
  n = 0;
  if (s === "selftest") {
    selftest();
    return;
  }
  init();
  results = [];
  while (1.) {
    n = scan(s);
    p1 = pop();
    check_stack();
    if (n === 0) {
      break;
    }
    s += n;
    push(p1);
    top_level_eval();
    p2 = pop();
    check_stack();
    if (p2 === symbol(NIL)) {
      continue;
    }
    if (isstr(p2)) {
      console.log(p2.str);
      console.log("\n");
      continue;
    }
    results.push(printline(p2));
  }
  return results;
};

check_stack = function() {
  if (tos !== 0) {
    stop("stack error");
  }
  if (frame !== TOS) {
    return stop("frame error");
  }
};

echo_input = function(s) {
  console.log(s);
  return console.log("\n");
};

top_level_eval = function() {
  var doNothing;
  save();
  trigmode = 0;
  p1 = symbol(AUTOEXPAND);
  if (iszero(get_binding(p1))) {
    expanding = 0;
  } else {
    expanding = 1;
  }
  p1 = pop();
  push(p1);
  Eval();
  p2 = pop();
  if (p2 === symbol(NIL)) {
    push(p2);
    restore();
    return;
  }
  set_binding(symbol(LAST), p2);
  if (!iszero(get_binding(symbol(BAKE)))) {
    push(p2);
    bake();
    p2 = pop();
  }
  if ((p1 === symbol(SYMBOL_I) || p1 === symbol(SYMBOL_J)) && isimaginaryunit(p2)) {
    doNothing = 0;
  } else if (isimaginaryunit(get_binding(symbol(SYMBOL_J)))) {
    push(p2);
    push(imaginaryunit);
    push_symbol(SYMBOL_J);
    subst();
    p2 = pop();
  } else if (isimaginaryunit(get_binding(symbol(SYMBOL_I)))) {
    push(p2);
    push(imaginaryunit);
    push_symbol(SYMBOL_I);
    subst();
    p2 = pop();
  }
  if (issymbol(p1) && !iskeyword(p1) && p1 !== p2 && test_flag === 0) {
    push_symbol(SETQ);
    push(p1);
    push(p2);
    list(3);
    p2 = pop();
  }
  push(p2);
  return restore();
};

check_esc_flag = function() {
  if (esc_flag) {
    return stop("esc key");
  }
};

T_INTEGER = 1001;

T_DOUBLE = 1002;

T_SYMBOL = 1003;

T_FUNCTION = 1004;

T_NEWLINE = 1006;

T_STRING = 1007;

T_GTEQ = 1008;

T_LTEQ = 1009;

T_EQ = 1010;

token = "";

newline_flag = 0;

meta_mode = 0;

input_str = 0;

scan_str = 0;

token_str = 0;

token_buf = 0;

scanned = "";

scan = function(s) {
  scanned = s;
  meta_mode = 0;
  expanding++;
  input_str = 0;
  scan_str = 0;
  get_next_token();
  if (token === "") {
    push(symbol(NIL));
    expanding--;
    return 0;
  }
  scan_stmt();
  expanding--;
  return token_str - input_str;
};

scan_meta = function(s) {
  meta_mode = 1;
  expanding++;
  input_str = 0;
  scan_str = 0;
  get_next_token();
  if (token === "") {
    push(symbol(NIL));
    expanding--;
    return 0;
  }
  scan_stmt();
  expanding--;
  return token_str - input_str;
};

scan_stmt = function() {
  scan_relation();
  if (token === '=') {
    get_next_token();
    push_symbol(SETQ);
    swap();
    scan_relation();
    return list(3);
  }
};

scan_relation = function() {
  scan_expression();
  switch (token) {
    case T_EQ:
      push_symbol(TESTEQ);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
    case T_LTEQ:
      push_symbol(TESTLE);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
    case T_GTEQ:
      push_symbol(TESTGE);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
    case '<':
      push_symbol(TESTLT);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
    case '>':
      push_symbol(TESTGT);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
  }
};

scan_expression = function() {
  var h;
  h = tos;
  switch (token) {
    case '+':
      get_next_token();
      scan_term();
      break;
    case '-':
      get_next_token();
      scan_term();
      negate();
      break;
    default:
      scan_term();
  }
  while (newline_flag === 0 && (token === '+' || token === '-')) {
    if (token === '+') {
      get_next_token();
      scan_term();
    } else {
      get_next_token();
      scan_term();
      negate();
    }
  }
  if (tos - h > 1) {
    list(tos - h);
    push_symbol(ADD);
    swap();
    return cons();
  }
};

is_factor = function() {
  switch (token) {
    case '*':
    case '/':
      return 1;
    case '(':
    case T_SYMBOL:
    case T_FUNCTION:
    case T_INTEGER:
    case T_DOUBLE:
    case T_STRING:
      if (newline_flag) {
        scan_str = token_str;
        return 0;
      } else {
        return 1;
      }
  }
  return 0;
};

scan_term = function() {
  var h;
  h = tos;
  scan_power();
  if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {
    pop();
  }
  while (is_factor()) {
    if (token === '*') {
      get_next_token();
      scan_power();
    } else if (token === '/') {
      get_next_token();
      scan_power();
      inverse();
    } else {
      scan_power();
    }
    if (tos > h + 1 && isnum(stack[tos - 2]) && isnum(stack[tos - 1])) {
      multiply();
    }
    if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {
      pop();
    }
  }
  if (h === tos) {
    return push_integer(1);
  } else if (tos - h > 1) {
    list(tos - h);
    push_symbol(MULTIPLY);
    swap();
    return cons();
  }
};

scan_power = function() {
  scan_factor();
  if (token === '^') {
    get_next_token();
    push_symbol(POWER);
    swap();
    scan_power();
    return list(3);
  }
};

scan_factor = function() {
  var h, results;
  h = tos;
  if (token === '(') {
    scan_subexpr();
  } else if (token === T_SYMBOL) {
    scan_symbol();
  } else if (token === T_FUNCTION) {
    scan_function_call();
  } else if (token === T_INTEGER) {
    bignum_scan_integer(token_buf);
    get_next_token();
  } else if (token === T_DOUBLE) {
    bignum_scan_float(token_buf);
    get_next_token();
  } else if (token === T_STRING) {
    scan_string();
  } else {
    error("syntax error");
  }
  if (token === '[') {
    get_next_token();
    push_symbol(INDEX);
    swap();
    scan_expression();
    while (token === ',') {
      get_next_token();
      scan_expression();
    }
    if (token !== ']') {
      error("] expected");
    }
    get_next_token();
    list(tos - h);
  }
  results = [];
  while (token === '!') {
    get_next_token();
    push_symbol(FACTORIAL);
    swap();
    results.push(list(2));
  }
  return results;
};

scan_symbol = function() {
  if (token !== T_SYMBOL) {
    error("symbol expected");
  }
  if (meta_mode && strlen(token_buf) === 1) {
    switch (token_buf[0]) {
      case 'a':
        push(symbol(METAA));
        break;
      case 'b':
        push(symbol(METAB));
        break;
      case 'x':
        push(symbol(METAX));
        break;
      default:
        push(usr_symbol(token_buf));
    }
  } else {
    push(usr_symbol(token_buf));
  }
  return get_next_token();
};

scan_string = function() {
  new_string(token_buf);
  return get_next_token();
};

scan_function_call = function() {
  var n, p;
  n = 1;
  p = new U();
  p = usr_symbol(token_buf);
  push(p);
  get_next_token();
  get_next_token();
  if (token !== ')') {
    scan_stmt();
    n++;
    while (token === ',') {
      get_next_token();
      scan_stmt();
      n++;
    }
  }
  if (token !== ')') {
    error(") expected");
  }
  get_next_token();
  return list(n);
};

scan_subexpr = function() {
  var n;
  n = 0;
  if (token !== '(') {
    error("( expected");
  }
  get_next_token();
  scan_stmt();
  if (token === ',') {
    n = 1;
    while (token === ',') {
      get_next_token();
      scan_stmt();
      n++;
    }
    build_tensor(n);
  }
  if (token !== ')') {
    error(") expected");
  }
  return get_next_token();
};

error = function(errmsg) {
  console.log('\n');
  while (input_str !== scan_str) {
    if ((scanned[input_str] === '\n' || scanned[input_str] === '\r') && input_str + 1 === scan_str) {
      break;
    }
    console.log(scanned[input_str++]);
  }
  console.log(" ? ");
  while (scanned[input_str] && (scanned[input_str] !== '\n' && scanned[input_str] !== '\r')) {
    console.log(scanned[input_str]);
  }
  console.log('\n');
  return stop(errmsg);
};

build_tensor = function(n) {
  var i, j, ref;
  console.log("build_tensor is not correct");
  i = 0;
  s = 0;
  save();
  s = stack + tos - n;
  p2 = alloc_tensor(n);
  p2.tensor.ndim = 1;
  p2.tensor.dim[0] = n;
  for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    p2.tensor.elem[i] = s[i];
  }
  tos -= n;
  push(p2);
  return restore();
};

get_next_token = function() {
  newline_flag = 0;
  while (1.) {
    get_token();
    if (token !== T_NEWLINE) {
      break;
    }
    newline_flag = 1;
  }
  console.log("get_next_token token: " + token);
  if (token === ')') {
    debugger;
  }
};

get_token = function() {
  while (isspace(scanned[scan_str])) {
    if (scanned[scan_str] === '\n' || scanned[scan_str] === '\r') {
      token = T_NEWLINE;
      scan_str++;
      return;
    }
    scan_str++;
  }
  token_str = scan_str;
  if (scan_str === scanned.length) {
    token = "";
    return;
  }
  if (isdigit(scanned[scan_str]) || scanned[scan_str] === '.') {
    while (isdigit(scanned[scan_str])) {
      scan_str++;
    }
    if (scanned[scan_str] === '.') {
      scan_str++;
      while (isdigit(scanned[scan_str])) {
        scan_str++;
      }
      if (scanned[scan_str] === 'e' && (scan_str[1] === '+' || scan_str[1] === '-' || isdigit(scan_str[1]))) {
        scan_str += 2;
        while (isdigit(scanned[scan_str])) {
          scan_str++;
        }
      }
      token = T_DOUBLE;
    } else {
      token = T_INTEGER;
    }
    update_token_buf(token_str, scan_str);
    return;
  }
  if (isalpha(scanned[scan_str])) {
    while (isalnum(scanned[scan_str])) {
      scan_str++;
    }
    if (scanned[scan_str] === '(') {
      token = T_FUNCTION;
    } else {
      token = T_SYMBOL;
    }
    update_token_buf(token_str, scan_str);
    return;
  }
  if (scanned[scan_str] === '"') {
    scan_str++;
    while (scanned[scan_str] !== '"') {
      if (scan_str === scanned.length || scanned[scan_str] === '\n' || scanned[scan_str] === '\r') {
        error("runaway string");
      }
      scan_str++;
    }
    scan_str++;
    token = T_STRING;
    update_token_buf(token_str + 1, scan_str - 1);
    return;
  }
  if (scanned[scan_str] === '#' || scanned[scan_str] === '-' && scan_str[1] === '-') {
    while (scanned[scan_str] && scanned[scan_str] !== '\n' && scanned[scan_str] !== '\r') {
      scan_str++;
    }
    if (scanned[scan_str]) {
      scan_str++;
    }
    token = T_NEWLINE;
    return;
  }
  if (scanned[scan_str] === '=' && scan_str[1] === '=') {
    scan_str += 2;
    token = T_EQ;
    return;
  }
  if (scanned[scan_str] === '<' && scan_str[1] === '=') {
    scan_str += 2;
    token = T_LTEQ;
    return;
  }
  if (scanned[scan_str] === '>' && scan_str[1] === '=') {
    scan_str += 2;
    token = T_GTEQ;
    return;
  }
  return token = scanned[scan_str++];
};

update_token_buf = function(a, b) {
  return token_buf = scanned.substring(a, b);
};

testString = ["a^^b", "a^^ ? b\nStop: syntax error", "(a+b", "(a+b ? \nStop: ) expected", "quote(1/(x*log(a*x)))", "1/(x*log(a*x))", "\"hello", "\"hello ? \nStop: runaway string", "a+\nb+\nc+", "a+\nb+\nc+ ? \nStop: syntax error", "2+2\n(3+3)", "4\n6", "1\n-1", "1\n-1", "1\n+1", "1\n1"];

test_scan = function() {
  var a;
  return a = 0;
};

tos = 0;

push = function(p) {
  if (tos >= frame) {
    stop("stack overflow");
  }
  return stack[tos++] = p;
};

pop = function() {
  var elementToBeReturned;
  if (tos === 0) {
    stop("stack underflow");
  }
  elementToBeReturned = stack[--tos];
  return elementToBeReturned;
};

push_frame = function(n) {
  var i, j, ref, results;
  i = 0;
  frame -= n;
  if (frame < tos) {
    debugger;
    stop("frame overflow, circular reference?");
  }
  results = [];
  for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    results.push(stack[frame + i] = symbol(NIL));
  }
  return results;
};

pop_frame = function(n) {
  frame += n;
  if (frame > TOS) {
    return stop("frame underflow");
  }
};

save = function() {
  frame -= 10;
  if (frame < tos) {
    debugger;
    stop("frame overflow, circular reference?");
  }
  stack[frame + 0] = p0;
  stack[frame + 1] = p1;
  stack[frame + 2] = p2;
  stack[frame + 3] = p3;
  stack[frame + 4] = p4;
  stack[frame + 5] = p5;
  stack[frame + 6] = p6;
  stack[frame + 7] = p7;
  stack[frame + 8] = p8;
  return stack[frame + 9] = p9;
};

restore = function() {
  if (frame > TOS - 10) {
    stop("frame underflow");
  }
  p0 = stack[frame + 0];
  p1 = stack[frame + 1];
  p2 = stack[frame + 2];
  p3 = stack[frame + 3];
  p4 = stack[frame + 4];
  p5 = stack[frame + 5];
  p6 = stack[frame + 6];
  p7 = stack[frame + 7];
  p8 = stack[frame + 8];
  p9 = stack[frame + 9];
  return frame += 10;
};

swap = function() {
  var p, q;
  p = pop();
  q = pop();
  push(p);
  return push(q);
};

dupl = function() {
  var p;
  p = pop();
  push(p);
  return push(p);
};

std_symbol = function(s, n) {
  var p;
  p = symtab[n];
  if (p == null) {
    debugger;
  }
  return p.printname = s;
};

usr_symbol = function(s) {
  var i, j, p, ref;
  for (i = j = 0, ref = NSYM; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    if (symtab[i].printname === "") {
      break;
    }
    if (s === symtab[i].printname) {
      return symtab[i];
    }
  }
  if (i === NSYM) {
    stop("symbol table overflow");
  }
  p = symtab[i];
  p.printname = s;
  return p;
};

get_printname = function(p) {
  if (p.k !== SYM) {
    stop("symbol error");
  }
  return p.printname;
};

set_binding = function(p, q) {
  var indexFound;
  if (p.k !== SYM) {
    stop("symbol error");
  }
  indexFound = symtab.indexOf(p);
  binding[indexFound] = q;
  return arglist[indexFound] = symbol(NIL);
};

get_binding = function(p) {
  var indexFound;
  if (p.k !== SYM) {
    stop("symbol error");
  }
  indexFound = symtab.indexOf(p);
  return binding[indexFound];
};

set_binding_and_arglist = function(p, q, r) {
  var indexFound;
  if (p.k !== SYM) {
    stop("symbol error");
  }
  indexFound = symtab.indexOf(p);
  binding[indexFound] = q;
  return arglist[indexFound] = r;
};

get_arglist = function(p) {
  var indexFound;
  if (p.k !== SYM) {
    stop("symbol error");
  }
  indexFound = symtab.indexOf(p);
  return arglist[indexFound];
};

symnum = function(p) {
  var indexFound;
  if (p.k !== SYM) {
    stop("symbol error");
  }
  indexFound = symtab.indexOf(p);
  return indexFound;
};

push_symbol = function(k) {
  return push(symtab[k]);
};

clear_symbols = function() {
  var i, j, ref, results;
  results = [];
  for (i = j = 0, ref = NSYM; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    binding[i] = symtab[i];
    results.push(arglist[i] = symbol(NIL));
  }
  return results;
};
