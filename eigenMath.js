// Generated by CoffeeScript 1.10.0
var ABS, ADD, ADJ, AND, ARCCOS, ARCCOSH, ARCSIN, ARCSINH, ARCTAN, ARCTANH, ARG, ATOMIZE, AUTOEXPAND, BAKE, BESSELJ, BESSELY, BINDING, BINOMIAL, BUF, C1, C2, C3, C4, C5, C6, CEILING, CHECK, CHOOSE, CIRCEXP, CLEAR, CLOCK, COEFF, COFACTOR, CONDENSE, CONJ, CONS, CONTRACT, COS, COSH, DEBUG, DECOMP, DEFINT, DEGREE, DENOMINATOR, DERIVATIVE, DET, DIM, DIRAC, DISPLAY, DIVISORS, DO, DOT, DOUBLE, DRAW, DRAWX, DSOLVE, E, EIGEN, EIGENVAL, EIGENVEC, ERF, ERFC, EVAL, EXP, EXPAND, EXPCOS, EXPSIN, Eval, Eval_Eval, Eval_abs, Eval_add, Eval_binding, Eval_check, Eval_clear, Eval_coeff, Eval_conj, Eval_cons, Eval_cos, Eval_derivative, Eval_det, Eval_dim, Eval_divisors, Eval_do, Eval_dsolve, Eval_exp, Eval_factor, Eval_factorial, Eval_factorpoly, Eval_hermite, Eval_hilbert, Eval_index, Eval_inner, Eval_inv, Eval_invg, Eval_isinteger, Eval_log, Eval_multiply, Eval_noexpand, Eval_number, Eval_operator, Eval_power, Eval_predicate, Eval_print, Eval_quote, Eval_rank, Eval_rationalize, Eval_setq, Eval_simplify, Eval_sin, Eval_sqrt, Eval_stop, Eval_subst, Eval_sym, Eval_tensor, Eval_unit, Eval_user_function, FACTOR, FACTORIAL, FACTORPOLY, FILTER, FLOATF, FLOOR, FOR, Find, GAMMA, GCD, HERMITE, HILBERT, IMAG, INDEX, INNER, INTEGRAL, INV, INVG, ISINTEGER, ISPRIME, LAGUERRE, LAST, LCM, LEADING, LEGENDRE, LOG, MAG, MAXDIM, MAXPRIMETAB, MAX_PROGRAM_SIZE, MEQUAL, METAA, METAB, METAX, MLENGTH, MOD, MP_MAX_FREE, MP_MIN_SIZE, MSIGN, MULTIPLY, MZERO, N, NIL, NOT, NROOTS, NSYM, NUM, NUMBER, NUMERATOR, OPERATOR, OR, OUTER, PI, POLAR, POWER, PRIME, PRINT, PRODUCT, QUOTE, QUOTIENT, RANK, RATIONALIZE, REAL, ROOTS, SECRETX, SELFTEST, SETQ, SGN, SIMPLIFY, SIN, SINH, SPACE_BETWEEN_COLUMNS, SPACE_BETWEEN_ROWS, SQRT, STOP, STR, SUBST, SUM, SYM, SYMBOL_A, SYMBOL_B, SYMBOL_C, SYMBOL_D, SYMBOL_I, SYMBOL_J, SYMBOL_N, SYMBOL_R, SYMBOL_S, SYMBOL_T, SYMBOL_X, SYMBOL_Y, SYMBOL_Z, TAN, TANH, TAYLOR, TENSOR, TEST, TESTEQ, TESTGE, TESTGT, TESTLE, TESTLT, TOS, TRACE, TRANSPOSE, TTY, T_DOUBLE, T_EQ, T_FUNCTION, T_GTEQ, T_INTEGER, T_LTEQ, T_NEWLINE, T_STRING, T_SYMBOL, U, UNIT, USR_SYMBOLS, YMAX, YYE, YYRECT, ZERO, __cmp, __emit_char, __emit_str, __factorial, __is_negative, __is_radical_number, __lcm, __normalize_radical_factors, __rationalize_tensor, absval, absval_tensor, add, add_all, add_numbers, add_terms, addf, alloc_tensor, allocatedId, any_denominators, arglist, bake, bake_poly, bake_poly_term, bignum_factorial, bignum_float, bignum_power_number, bignum_scan_float, bignum_scan_integer, bignum_truncate, binding, buffer, build_tensor, caaddr, caadr, caar, cadaddr, cadadr, cadar, caddaddr, caddadr, caddar, caddddr, cadddr, caddr, cadr, car, cdaddr, cdadr, cdar, cddaddr, cddar, cdddaddr, cddddr, cdddr, cddr, cdr, charTabIndex, chartab, check_esc_flag, check_stack, clear, clear_symbols, cmpGlyphs, cmp_expr, cmp_terms, coeff, combine_factors, combine_gammas, combine_terms, compare_numbers, compare_rationals, compare_tensors, compatible, conjugate, cons, consCount, convert_bignum_to_double, convert_rational_to_double, copy_tensor, cosine, cosine_of_angle, cosine_of_angle_sum, count, count_denominators, counter, d_scalar_scalar, d_scalar_scalar_1, d_scalar_tensor, d_tensor_scalar, d_tensor_tensor, dabs, darccos, darccosh, darcsin, darcsinh, darctan, darctanh, dbesselj0, dbesseljn, dbessely0, dbesselyn, dcos, dcosh, dd, define_user_function, defn, defn_str, derf, derfc, derivative, derivative_of_integral, dfunction, dhermite, display, display_flag, displaychar, divide, divide_numbers, dlog, dpower, dproduct, draw_flag, draw_stop_return, dsgn, dsin, dsinh, dsum, dtan, dtanh, dupl, echo_input, egcd, elelmIndex, elem, emit_denominator, emit_denominators, emit_expr, emit_factor, emit_factorial_function, emit_flat_tensor, emit_fraction, emit_function, emit_index_function, emit_multiply, emit_number, emit_numerators, emit_numerical_fraction, emit_power, emit_string, emit_subexpr, emit_symbol, emit_tensor, emit_tensor_inner, emit_term, emit_top_expr, emit_unsigned_expr, emit_x, endian, equal, equaln, equalq, error, esc_flag, expanding, exponential, expr_level, f1, f2, f3, f4, f5, f9, factor, factor_again, factor_small_number, factor_term, factorial, fill_buf, fixup_fraction, fixup_power, flag, fmt_index, fmt_level, fmt_x, frame, free_stack, gcd_numbers, ge, get_arglist, get_binding, get_next_token, get_printname, get_size, get_token, getdisplaystr, glyph, gp, guess, imaginaryunit, index_function, init, inited, inner, inner_f, input_str, inverse, invert_number, is_denominator, is_factor, is_small_integer, is_square_matrix, isadd, isalnum, isalpha, iscomplexnumber, iscons, isdenominator, isdigit, isdouble, iseveninteger, isfactor, isfactorial, isfloating, isfraction, isimaginarynumber, isimaginaryunit, isinteger, isintegerfactor, iskeyword, isminusone, isminusoneoversqrttwo, isnegative, isnegativenumber, isnegativeterm, isnonnegativeinteger, isnpi, isnum, isoneover, isoneoversqrttwo, isplusone, ispoly, ispoly_expr, ispoly_factor, ispoly_term, isposint, ispower, isquarterturn, isrational, isspace, isstr, issymbol, issymbolic, istensor, iszero, l, length, lessp, level, list, logarithm, logbuf, logout, lookupsTotal, madd, makePositive, makeSignSameAs, mask, mcmp, mcmpint, mdiv, meta_mode, mgcd, mint, mmod, mmul, move, mp_clr_bit, mp_denominator, mp_numerator, mp_set_bit, mpow, mprime, mroot, mshiftright, msub, mtotal, multinomial_sum, multiply, multiply_all, multiply_all_noexpand, multiply_denominators, multiply_denominators_factor, multiply_denominators_term, multiply_noexpand, multiply_numbers, negate, negate_expand, negate_noexpand, negate_number, new_string, newline_flag, normalize_angle, nterms, o, one, oneElement, out_buf, out_count, out_of_memory, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, parse_p1, parse_p2, peek, peek2, polyform, pop, pop_double, pop_frame, pop_integer, power, power_sum, power_tensor, primetab, print1, print_double, print_expr, print_factor, print_it, print_multiply_sign, print_number, print_str, print_term, printchar, printchar_nowrap, printline, program_buf, promote_tensor, push, push_cars, push_double, push_frame, push_identity_matrix, push_integer, push_rational, push_symbol, push_terms, push_zero_matrix, qadd, qdiv, qmul, qpow, qpowf, quickfactor, quickpower, rational, rationalize, reciprocate, ref, restore, rewrite_args, rewrite_args_tensor, run, s, save, scalar_times_tensor, scan, scan_expression, scan_factor, scan_function_call, scan_meta, scan_power, scan_relation, scan_stmt, scan_str, scan_string, scan_subexpr, scan_symbol, scan_term, scanned, selftest, setSignTo, set_binding, set_binding_and_arglist, set_component, setq_indexed, sfac_product, sfac_product_f, sign, sign_of_term, simplify, simplify_main, simplify_polar, simplify_tensor, simplify_trig, simplifyfactorials, sine, sine_of_angle, sine_of_angle_sum, sort_stack, square, ssqrt, stack, stackAddsCount, std_symbol, stop, subf, subst, subtract, subtract_numbers, swap, symbol, symnum, symtab, tensor, tensor_plus_tensor, tensor_times_scalar, test, testString, test_flag, test_low_level, test_madd, test_maddf, test_mdiv, test_mdivf, test_mgcd, test_mmod, test_mmodf, test_mmul, test_mmulf, test_mpow, test_mprime, test_mroot, test_msub, test_msubf, test_quickfactor, test_scan, text_metric, token, token_buf, token_str, top_level_eval, tos, trigmode, ucmp, unique, unique_f, update_token_buf, usr_symbol, verbosing, will_be_displayed_as_fraction, yindex, yyexpand, yylog, yymultiply, yypower, yyrationalize, zero;

SELFTEST = 1;

NSYM = 1000;

primetab = [];

rational = (function() {
  function rational() {}

  rational.prototype.a = null;

  rational.prototype.b = null;

  return rational;

})();

U = (function() {
  U.prototype.cons = null;

  U.prototype.printname = "";

  U.prototype.str = "";

  U.prototype.tensor = null;

  U.prototype.q = null;

  U.prototype.d = 0.0;

  U.prototype.k = 0;

  U.prototype.tag = 0;

  function U() {
    this.cons = {};
    this.cons.car = null;
    this.cons.cdr = null;
    this.q = new rational();
  }

  return U;

})();

CONS = 0;

NUM = 1;

DOUBLE = 2;

STR = 3;

TENSOR = 4;

SYM = 5;

counter = 0;

ABS = counter++;

ADD = counter++;

ADJ = counter++;

AND = counter++;

ARCCOS = counter++;

ARCCOSH = counter++;

ARCSIN = counter++;

ARCSINH = counter++;

ARCTAN = counter++;

ARCTANH = counter++;

ARG = counter++;

ATOMIZE = counter++;

BESSELJ = counter++;

BESSELY = counter++;

BINDING = counter++;

BINOMIAL = counter++;

CEILING = counter++;

CHECK = counter++;

CHOOSE = counter++;

CIRCEXP = counter++;

CLEAR = counter++;

CLOCK = counter++;

COEFF = counter++;

COFACTOR = counter++;

CONDENSE = counter++;

CONJ = counter++;

CONTRACT = counter++;

COS = counter++;

COSH = counter++;

DECOMP = counter++;

DEFINT = counter++;

DEGREE = counter++;

DENOMINATOR = counter++;

DERIVATIVE = counter++;

DET = counter++;

DIM = counter++;

DIRAC = counter++;

DISPLAY = counter++;

DIVISORS = counter++;

DO = counter++;

DOT = counter++;

DRAW = counter++;

DSOLVE = counter++;

EIGEN = counter++;

EIGENVAL = counter++;

EIGENVEC = counter++;

ERF = counter++;

ERFC = counter++;

EVAL = counter++;

EXP = counter++;

EXPAND = counter++;

EXPCOS = counter++;

EXPSIN = counter++;

FACTOR = counter++;

FACTORIAL = counter++;

FACTORPOLY = counter++;

FILTER = counter++;

FLOATF = counter++;

FLOOR = counter++;

FOR = counter++;

GAMMA = counter++;

GCD = counter++;

HERMITE = counter++;

HILBERT = counter++;

IMAG = counter++;

INDEX = counter++;

INNER = counter++;

INTEGRAL = counter++;

INV = counter++;

INVG = counter++;

ISINTEGER = counter++;

ISPRIME = counter++;

LAGUERRE = counter++;

LCM = counter++;

LEADING = counter++;

LEGENDRE = counter++;

LOG = counter++;

MAG = counter++;

MOD = counter++;

MULTIPLY = counter++;

NOT = counter++;

NROOTS = counter++;

NUMBER = counter++;

NUMERATOR = counter++;

OPERATOR = counter++;

OR = counter++;

OUTER = counter++;

POLAR = counter++;

POWER = counter++;

PRIME = counter++;

PRINT = counter++;

PRODUCT = counter++;

QUOTE = counter++;

QUOTIENT = counter++;

RANK = counter++;

RATIONALIZE = counter++;

REAL = counter++;

YYRECT = counter++;

ROOTS = counter++;

SETQ = counter++;

SGN = counter++;

SIMPLIFY = counter++;

SIN = counter++;

SINH = counter++;

SQRT = counter++;

STOP = counter++;

SUBST = counter++;

SUM = counter++;

TAN = counter++;

TANH = counter++;

TAYLOR = counter++;

TEST = counter++;

TESTEQ = counter++;

TESTGE = counter++;

TESTGT = counter++;

TESTLE = counter++;

TESTLT = counter++;

TRANSPOSE = counter++;

UNIT = counter++;

ZERO = counter++;

NIL = counter++;

AUTOEXPAND = counter++;

BAKE = counter++;

LAST = counter++;

TRACE = counter++;

TTY = counter++;

YYE = counter++;

DRAWX = counter++;

METAA = counter++;

METAB = counter++;

METAX = counter++;

SECRETX = counter++;

PI = counter++;

SYMBOL_A = counter++;

SYMBOL_B = counter++;

SYMBOL_C = counter++;

SYMBOL_D = counter++;

SYMBOL_I = counter++;

SYMBOL_J = counter++;

SYMBOL_N = counter++;

SYMBOL_R = counter++;

SYMBOL_S = counter++;

SYMBOL_T = counter++;

SYMBOL_X = counter++;

SYMBOL_Y = counter++;

SYMBOL_Z = counter++;

C1 = counter++;

C2 = counter++;

C3 = counter++;

C4 = counter++;

C5 = counter++;

C6 = counter++;

USR_SYMBOLS = counter++;

E = YYE;

TOS = 100000;

BUF = 10000;

MAX_PROGRAM_SIZE = 100001;

MAXPRIMETAB = 10000;

MAXDIM = 24;

tensor = (function() {
  tensor.prototype.ndim = 0;

  tensor.prototype.dim = null;

  tensor.prototype.nelem = 0;

  tensor.prototype.elem = null;

  function tensor() {
    this.dim = (function() {
      var l, ref, results;
      results = [];
      for (l = 0, ref = MAXDIM; 0 <= ref ? l <= ref : l >= ref; 0 <= ref ? l++ : l--) {
        results.push(0);
      }
      return results;
    })();
    this.elem = [];
  }

  return tensor;

})();

display = (function() {
  function display() {}

  display.prototype.h = 0;

  display.prototype.w = 0;

  display.prototype.n = 0;

  display.prototype.a = [];

  return display;

})();

text_metric = (function() {
  function text_metric() {}

  text_metric.prototype.ascent = 0;

  text_metric.prototype.descent = 0;

  text_metric.prototype.width = 0;

  return text_metric;

})();

tos = 0;

expanding = 0;

fmt_x = 0;

fmt_index = 0;

fmt_level = 0;

verbosing = 0;

primetab = [];

primetab[MAXPRIMETAB] = 0;

esc_flag = 0;

draw_flag = 0;

mtotal = 0;

trigmode = 0;

logbuf = "";

program_buf = "";

symtab = [];

binding = [];

arglist = [];

stack = [];

frame = 0;

p0 = null;

p1 = null;

p2 = null;

p3 = null;

p4 = null;

p5 = null;

p6 = null;

p7 = null;

p8 = null;

p9 = null;

zero = null;

one = null;

imaginaryunit = null;

symtab = [];

out_buf = "";

out_count = 0;

test_flag = 0;

draw_stop_return = null;

endian = 0;

symbol = function(x) {
  return symtab[x];
};

iscons = function(p) {
  return p.k === CONS;
};

isrational = function(p) {
  return p.k === NUM;
};

isdouble = function(p) {
  return p.k === DOUBLE;
};

isnum = function(p) {
  return isrational(p) || isdouble(p);
};

isstr = function(p) {
  return p.k === STR;
};

istensor = function(p) {
  if (p == null) {
    debugger;
  } else {
    return p.k === TENSOR;
  }
};

issymbol = function(p) {
  return p.k === SYM;
};

iskeyword = function(p) {
  return issymbol(p) && symnum(p) < NIL;
};

car = function(p) {
  if (iscons(p)) {
    return p.cons.car;
  } else {
    return symbol(NIL);
  }
};

cdr = function(p) {
  if (iscons(p)) {
    return p.cons.cdr;
  } else {
    return symbol(NIL);
  }
};

caar = function(p) {
  return car(car(p));
};

cadr = function(p) {
  return car(cdr(p));
};

cdar = function(p) {
  return cdr(car(p));
};

cddr = function(p) {
  return cdr(cdr(p));
};

caadr = function(p) {
  return car(car(cdr(p)));
};

caddr = function(p) {
  return car(cdr(cdr(p)));
};

cadar = function(p) {
  return car(cdr(car(p)));
};

cdadr = function(p) {
  return cdr(car(cdr(p)));
};

cddar = function(p) {
  return cdr(cdr(car(p)));
};

cdddr = function(p) {
  return cdr(cdr(cdr(p)));
};

caaddr = function(p) {
  return car(car(cdr(cdr(p))));
};

cadadr = function(p) {
  return car(cdr(car(cdr(p))));
};

caddar = function(p) {
  return car(cdr(cdr(car(p))));
};

cdaddr = function(p) {
  return cdr(car(cdr(cdr(p))));
};

cadddr = function(p) {
  return car(cdr(cdr(cdr(p))));
};

cddddr = function(p) {
  return cdr(cdr(cdr(cdr(p))));
};

caddddr = function(p) {
  return car(cdr(cdr(cdr(cdr(p)))));
};

cadaddr = function(p) {
  return car(cdr(car(cdr(cdr(p)))));
};

cddaddr = function(p) {
  return cdr(cdr(car(cdr(cdr(p)))));
};

caddadr = function(p) {
  return car(cdr(cdr(car(cdr(p)))));
};

cdddaddr = function(p) {
  return cdr(cdr(cdr(car(cdr(cdr(p))))));
};

caddaddr = function(p) {
  return car(cdr(cdr(car(cdr(cdr(p))))));
};

isadd = function(p) {
  return car(p) === symbol(ADD);
};

ispower = function(p) {
  return car(p) === symbol(POWER);
};

isfactorial = function(p) {
  return car(p) === symbol(FACTORIAL);
};

MSIGN = function(p) {
  if (p.isPositive()) {
    return 1;
  } else if (p.isZero()) {
    return 0;
  } else {
    return -1;
  }
};

MLENGTH = function(p) {
  return p.toString.length;
};

MZERO = function(p) {
  return p.isZero();
};

MEQUAL = function(p, n) {
  return p.equals(n);
};

Eval_abs = function() {
  push(cadr(p1));
  Eval();
  return absval();
};

absval = function() {
  var h;
  h = 0;
  save();
  p1 = pop();
  if (istensor(p1)) {
    absval_tensor();
    restore();
    return;
  }
  if (isnum(p1)) {
    push(p1);
    if (isnegativenumber(p1)) {
      negate();
    }
    restore();
    return;
  }
  if (iscomplexnumber(p1)) {
    push(p1);
    push(p1);
    conjugate();
    multiply();
    push_rational(1, 2);
    power();
    restore();
    return;
  }
  if (car(p1) === symbol(POWER) && isnegativeterm(caddr(p1))) {
    push(p1);
    reciprocate();
    absval();
    reciprocate();
    restore();
    return;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    h = tos;
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      absval();
      p1 = cdr(p1);
    }
    multiply_all(tos - h);
    restore();
    return;
  }
  if (isnegativeterm(p1) || (car(p1) === symbol(ADD) && isnegativeterm(cadr(p1)))) {
    push(p1);
    negate();
    p1 = pop();
  }
  push_symbol(ABS);
  push(p1);
  list(2);
  return restore();
};

absval_tensor = function() {
  if (p1.tensor.ndim !== 1) {
    stop("abs(tensor) with tensor rank > 1");
  }
  push(p1);
  push(p1);
  conjugate();
  inner();
  push_rational(1, 2);
  power();
  simplify();
  return Eval();
};

s = ["abs(2)", "2", "abs(2.0)", "2", "abs(-2)", "2", "abs(-2.0)", "2", "abs(a)", "abs(a)", "abs(-a)", "abs(a)", "abs(2*a)", "2*abs(a)", "abs(-2*a)", "2*abs(a)", "abs(2.0*a)", "2*abs(a)", "abs(-2.0*a)", "2*abs(a)", "abs(a-b)+abs(b-a)", "2*abs(a-b)", "abs(3 + 4 i)", "5", "abs((2,3,4))", "29^(1/2)", "abs(a*b)", "abs(a)*abs(b)", "abs(a/b)", "abs(a)/abs(b)", "abs(1/a^b)", "1/(abs(a^b))", "P=(u*cos(v),u*sin(v),v)", "", "abs(cross(d(P,u),d(P,v)))", "(1+u^2)^(1/2)"];


/*
void
test_abs(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}

#endif
 */


/*
 Symbolic addition

	Terms in a sum are combined if they are identical modulo rational
	coefficients.

	For example, A + 2A becomes 3A.

	However, the sum A + sqrt(2) A is not modified.

	Combining terms can lead to second-order effects.

	For example, consider the case of

		1/sqrt(2) A + 3/sqrt(2) A + sqrt(2) A

	The first two terms are combined to yield 2 sqrt(2) A.

	This result can now be combined with the third term to yield

		3 sqrt(2) A
 */

flag = 0;

Eval_add = function() {
  var h;
  h = tos;
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    p2 = pop();
    push_terms(p2);
    p1 = cdr(p1);
  }
  return add_terms(tos - h);
};

stackAddsCount = 0;

add_terms = function(n) {
  var ac, h, i, l, o, ref, ref1, results, subsetOfStack;
  stackAddsCount++;
  i = 0;
  h = tos - n;
  s = h;
  console.log("stack before adding terms");
  for (i = l = 0, ref = tos; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
    print1(stack[i]);
  }
  for (i = o = 0; o < 10; i = ++o) {
    if (n < 2) {
      break;
    }
    flag = 0;
    subsetOfStack = stack.slice(h, h + n);
    subsetOfStack.sort(cmp_terms);
    stack = stack.slice(0, h).concat(subsetOfStack).concat(stack.slice(h + n));
    if (flag === 0) {
      break;
    }
    n = combine_terms(h, n);
  }
  tos = h + n;
  switch (n) {
    case 0:
      push_integer(0);
      break;
    case 1:
      break;
    default:
      list(n);
      p1 = pop();
      push_symbol(ADD);
      push(p1);
      cons();
  }
  console.log("stack after adding terms #" + stackAddsCount);
  if (stackAddsCount === 28) {
    debugger;
  }
  results = [];
  for (i = ac = 0, ref1 = tos; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    results.push(print1(stack[i]));
  }
  return results;
};

cmp_terms = function(p1, p2) {
  var i, l, ref, t;
  i = 0;
  if (isnum(p1) && isnum(p2)) {
    flag = 1;
    console.log("cmp_terms returns 0");
    return 0;
  }
  if (istensor(p1) && istensor(p2)) {
    if (p1.tensor.ndim < p2.tensor.ndim) {
      console.log("cmp_terms returns -1");
      return -1;
    }
    if (p1.tensor.ndim > p2.tensor.ndim) {
      console.log("cmp_terms returns 1");
      return 1;
    }
    for (i = l = 0, ref = p1.tensor.ndim; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      if (p1.tensor.dim[i] < p2.tensor.dim[i]) {
        console.log("cmp_terms returns -1");
        return -1;
      }
      if (p1.tensor.dim[i] > p2.tensor.dim[i]) {
        console.log("cmp_terms returns 1");
        return 1;
      }
    }
    flag = 1;
    console.log("cmp_terms returns 0");
    return 0;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    p1 = cdr(p1);
    if (isnum(car(p1))) {
      p1 = cdr(p1);
      if (cdr(p1) === symbol(NIL)) {
        p1 = car(p1);
      }
    }
  }
  if (car(p2) === symbol(MULTIPLY)) {
    p2 = cdr(p2);
    if (isnum(car(p2))) {
      p2 = cdr(p2);
      if (cdr(p2) === symbol(NIL)) {
        p2 = car(p2);
      }
    }
  }
  t = cmp_expr(p1, p2);
  if (t === 0) {
    flag = 1;
  }
  console.log("cmp_terms returns " + t);
  return t;
};


/*
 Compare adjacent terms in s[] and combine if possible.

	Returns the number of terms remaining in s[].

	n	number of terms in s[] initially
 */

combine_terms = function(s, n) {
  var ac, ad, ae, i, j, l, o, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, t;
  i = 0;
  while (i < (n - 1)) {
    check_esc_flag();
    p3 = stack[s + i];
    p4 = stack[s + i + 1];
    if (istensor(p3) && istensor(p4)) {
      push(p3);
      push(p4);
      tensor_plus_tensor();
      p1 = pop();
      if (p1 !== symbol(NIL)) {
        stack[s + i] = p1;
        for (j = l = ref = i + 1, ref1 = n - 1; ref <= ref1 ? l < ref1 : l > ref1; j = ref <= ref1 ? ++l : --l) {
          stack[s + j] = stack[s + j + 1];
        }
        n--;
        i--;
      }
      i++;
      continue;
    }
    if (istensor(p3) || istensor(p4)) {
      i++;
      continue;
    }
    if (isnum(p3) && isnum(p4)) {
      push(p3);
      push(p4);
      add_numbers();
      p1 = pop();
      if (iszero(p1)) {
        for (j = o = ref2 = i, ref3 = n - 2; ref2 <= ref3 ? o < ref3 : o > ref3; j = ref2 <= ref3 ? ++o : --o) {
          stack[s + j] = stack[s + j + 2];
        }
        n -= 2;
      } else {
        stack[s + i] = p1;
        for (j = ac = ref4 = i + 1, ref5 = n - 1; ref4 <= ref5 ? ac < ref5 : ac > ref5; j = ref4 <= ref5 ? ++ac : --ac) {
          stack[s + j] = stack[s + j + 1];
        }
        n--;
      }
      i--;
      i++;
      continue;
    }
    if (isnum(p3) || isnum(p4)) {
      i++;
      continue;
    }
    p1 = one;
    p2 = one;
    t = 0;
    if (car(p3) === symbol(MULTIPLY)) {
      p3 = cdr(p3);
      t = 1;
      if (isnum(car(p3))) {
        p1 = car(p3);
        p3 = cdr(p3);
        if (cdr(p3) === symbol(NIL)) {
          p3 = car(p3);
          t = 0;
        }
      }
    }
    if (car(p4) === symbol(MULTIPLY)) {
      p4 = cdr(p4);
      if (isnum(car(p4))) {
        p2 = car(p4);
        p4 = cdr(p4);
        if (cdr(p4) === symbol(NIL)) {
          p4 = car(p4);
        }
      }
    }
    if (!equal(p3, p4)) {
      i++;
      continue;
    }
    push(p1);
    push(p2);
    add_numbers();
    p1 = pop();
    if (iszero(p1)) {
      for (j = ad = ref6 = i, ref7 = n - 2; ref6 <= ref7 ? ad < ref7 : ad > ref7; j = ref6 <= ref7 ? ++ad : --ad) {
        stack[s + j] = stack[s + j + 2];
      }
      n -= 2;
      i--;
      i++;
      continue;
    }
    push(p1);
    if (t) {
      push(symbol(MULTIPLY));
      push(p3);
      cons();
    } else {
      push(p3);
    }
    multiply();
    stack[s + i] = pop();
    for (j = ae = ref8 = i + 1, ref9 = n - 1; ref8 <= ref9 ? ae < ref9 : ae > ref9; j = ref8 <= ref9 ? ++ae : --ae) {
      stack[s + j] = stack[s + j + 1];
    }
    n--;
    i--;
    i++;
  }
  return n;
};

push_terms = function(p) {
  var results;
  if (car(p) === symbol(ADD)) {
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      push(car(p));
      results.push(p = cdr(p));
    }
    return results;
  } else if (!iszero(p)) {
    return push(p);
  }
};

add = function() {
  var h;
  save();
  p2 = pop();
  p1 = pop();
  h = tos;
  push_terms(p1);
  push_terms(p2);
  add_terms(tos - h);
  return restore();
};

add_all = function(k) {
  var h, i, l, ref;
  i = 0;
  save();
  s = tos - k;
  h = tos;
  for (i = l = 0, ref = k; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
    push_terms(stack[s + i]);
  }
  add_terms(tos - h);
  p1 = pop();
  tos -= k;
  push(p1);
  return restore();
};

subtract = function() {
  negate();
  return add();
};


/*
// up to 100 blocks of 100,000 atoms

#define M 100
#define N 100000

U *mem[M];
int mcount;

U *free_list;
int free_count;

U *
alloc(void)
{
	U *p;
	if (free_count == 0) {
		if (mcount == 0)
			alloc_mem();
		else {
			gc();
			if (free_count < N * mcount / 2)
				alloc_mem();
		}
		if (free_count == 0)
			stop("atom space exhausted");
	}
	p = free_list;
	free_list = free_list->u.cons.cdr;
	free_count--;
	return p;
}
 */

allocatedId = 0;

alloc_tensor = function(nelem) {
  var i, l, p, ref;
  i = 0;
  p = new U();
  p.k = TENSOR;
  p.tensor = new tensor();
  p.tensor.nelem = nelem;
  for (i = l = 0, ref = nelem; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
    p.tensor.elem[i] = zero;
  }
  p.tensor.allocatedId = allocatedId;
  if (allocatedId === 9) {
    debugger;
  }
  allocatedId++;
  if (p.tensor.nelem !== p.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  return p;
};


/*
// garbage collector

void
gc(void)
{
	int i, j;
	U *p;

	// tag everything

	for (i = 0; i < mcount; i++) {
		p = mem[i];
		for (j = 0; j < N; j++)
			p[j].tag = 1;
	}

	// untag what's used

	untag(p0);
	untag(p1);
	untag(p2);
	untag(p3);
	untag(p4);
	untag(p5);
	untag(p6);
	untag(p7);
	untag(p8);
	untag(p9);

	untag(one);
	untag(zero);
	untag(imaginaryunit);

	for (i = 0; i < NSYM; i++) {
		untag(binding[i]);
		untag(arglist[i]);
	}

	for (i = 0; i < tos; i++)
		untag(stack[i]);

	for (i = (int) (frame - stack); i < TOS; i++)
		untag(stack[i]);

	// collect everything that's still tagged

	free_count = 0;

	for (i = 0; i < mcount; i++) {
		p = mem[i];
		for (j = 0; j < N; j++) {
			if (p[j].tag == 0)
				continue;
			// still tagged so it's unused, put on free list
			switch (p[j].k) {
			case TENSOR:
				free(p[j].u.tensor);
				break;
			case STR:
				free(p[j].u.str);
				break;
			case NUM:
				mfree(p[j].u.q.a);
				mfree(p[j].u.q.b);
				break;
			}
			p[j].k = CONS; // so no double free occurs above
			p[j].u.cons.cdr = free_list;
			free_list = p + j;
			free_count++;
		}
	}
}

void
untag(U *p)
{
	int i;

	if (iscons(p)) {
		do {
			if (p->tag == 0)
				return;
			p->tag = 0;
			untag(p->u.cons.car);
			p = p->u.cons.cdr;
		} while (iscons(p));
		untag(p);
		return;
	}

	if (p->tag) {
		p->tag = 0;
 		if (istensor(p)) {
			for (i = 0; i < p->u.tensor->nelem; i++)
				untag(p->u.tensor->elem[i]);
		}
	}
}

// get memory for 100,000 atoms

void
alloc_mem(void)
{
	int i;
	U *p;
	if (mcount == M)
		return;
	p = (U *) malloc(N * sizeof (struct U));
	if (p == NULL)
		return;
	mem[mcount++] = p;
	for (i = 0; i < N; i++) {
		p[i].k = CONS; // so no free in gc
		p[i].u.cons.cdr = p + i + 1;
	}
	p[N - 1].u.cons.cdr = free_list;
	free_list = p;
	free_count += N;
}

void
print_mem_info(void)
{
	char buf[100];

	sprintf(buf, "%d blocks (%d bytes/block)\n", N * mcount, (int) sizeof (U));
	printstr(buf);

	sprintf(buf, "%d free\n", free_count);
	printstr(buf);

	sprintf(buf, "%d used\n", N * mcount - free_count);
	printstr(buf);
}
 */

bake = function() {
  var h, t, x, y, z;
  h = 0;
  s = 0;
  t = 0;
  x = 0;
  y = 0;
  z = 0;
  expanding++;
  save();
  p1 = pop();
  s = ispoly(p1, symbol(SYMBOL_S));
  t = ispoly(p1, symbol(SYMBOL_T));
  x = ispoly(p1, symbol(SYMBOL_X));
  y = ispoly(p1, symbol(SYMBOL_Y));
  z = ispoly(p1, symbol(SYMBOL_Z));
  if (s === 1 && t === 0 && x === 0 && y === 0 && z === 0) {
    p2 = symbol(SYMBOL_S);
    bake_poly();
  } else if (s === 0 && t === 1 && x === 0 && y === 0 && z === 0) {
    p2 = symbol(SYMBOL_T);
    bake_poly();
  } else if (s === 0 && t === 0 && x === 1 && y === 0 && z === 0) {
    p2 = symbol(SYMBOL_X);
    bake_poly();
  } else if (s === 0 && t === 0 && x === 0 && y === 1 && z === 0) {
    p2 = symbol(SYMBOL_Y);
    bake_poly();
  } else if (s === 0 && t === 0 && x === 0 && y === 0 && z === 1) {
    p2 = symbol(SYMBOL_Z);
    bake_poly();
  } else if (iscons(p1)) {
    h = tos;
    push(car(p1));
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      bake();
      p1 = cdr(p1);
    }
    list(tos - h);
  } else {
    push(p1);
  }
  restore();
  return expanding--;
};

polyform = function() {
  var h;
  h = 0;
  save();
  p2 = pop();
  p1 = pop();
  if (ispoly(p1, p2)) {
    bake_poly();
  } else if (iscons(p1)) {
    h = tos;
    push(car(p1));
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      polyform();
      p1 = cdr(p1);
    }
    list(tos - h);
  } else {
    push(p1);
  }
  return restore();
};

bake_poly = function() {
  var a, h, i, k, l, n, ref;
  h = 0;
  i = 0;
  k = 0;
  n = 0;
  a = tos;
  push(p1);
  push(p2);
  k = coeff();
  h = tos;
  for (i = l = ref = k - 1; l > 0; i = l += -1) {
    p1 = stack[a + i];
    bake_poly_term(i);
  }
  n = tos - h;
  if (n > 1) {
    list(n);
    push(symbol(ADD));
    swap();
    cons();
  }
  p1 = pop();
  tos -= k;
  return push(p1);
};

bake_poly_term = function(k) {
  var h, n;
  h = 0;
  n = 0;
  if (iszero(p1)) {
    return;
  }
  if (k === 0) {
    if (car(p1) === symbol(ADD)) {
      p1 = cdr(p1);
      while (iscons(p1)) {
        push(car(p1));
        p1 = cdr(p1);
      }
    } else {
      push(p1);
    }
    return;
  }
  h = tos;
  if (car(p1) === symbol(MULTIPLY)) {
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      p1 = cdr(p1);
    }
  } else if (!equaln(p1, 1)) {
    push(p1);
  }
  if (k === 1) {
    push(p2);
  } else {
    push(symbol(POWER));
    push(p2);
    push_integer(k);
    list(3);
  }
  n = tos - h;
  if (n > 1) {
    list(n);
    push(symbol(MULTIPLY));
    swap();
    return cons();
  }
};

s = ["(x+3)^3", "x^3+9*x^2+27*x+27", "factor", "(x+3)^3"];


/*
void
test_bake(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}
 */

MP_MIN_SIZE = 2;

MP_MAX_FREE = 1000;

mtotal = 0;

free_stack = [];

mint = function(a) {
  return bigInt(a);
};

setSignTo = function(a, b) {
  if (a.isPositive) {
    if (b < 0) {
      return a = a.multiply(bigInt(-1));
    }
  } else {
    if (b > 0) {
      return a = a.multiply(bigInt(-1));
    }
  }
};

makeSignSameAs = function(a, b) {
  if (a.isPositive) {
    if (b.isNegative) {
      return b = b.multiply(bigInt(-1));
    }
  } else {
    if (b.isPositive) {
      return b = b.multiply(bigInt(-1));
    }
  }
};

makePositive = function(a) {
  if (a.isNegative) {
    return a = a.multiply(bigInt(-1));
  }
};


/*
mnew = (n) ->
	if (n < MP_MIN_SIZE)
		n = MP_MIN_SIZE
	if (n == MP_MIN_SIZE && mfreecount)
		p = free_stack[--mfreecount]
	else
		p = [] #(unsigned int *) malloc((n + 3) * sizeof (int))
		#if (p == 0)
		 *	stop("malloc failure")
	p[0] = n
	mtotal += n
	return p[3]
 */


/*
mfree = (array, p) ->
	p -= 3
	mtotal -= array[p]
	if (array[p] == MP_MIN_SIZE && mfreecount < MP_MAX_FREE)
		free_stack[mfreecount++] = p
	else
		free(p)
 */


/*
mint = (n) ->
	p = mnew(1)
	if (n < 0)
		 * !!! this is FU
		 * MSIGN(p) = -1
		fu = true
	else
		 * !!! this is FU
		#MSIGN(p) = 1
		fu = true
	 * !!! this is FU
	#MLENGTH(p) = 1
	p[0] = Math.abs(n)
	return p
 */


/*
mcopy = (a) ->
	#unsigned int *b

	b = mnew(MLENGTH(a))

	 * !!! fu
	#MSIGN(b) = MSIGN(a)
	#MLENGTH(b) = MLENGTH(a)

	for i in [0...MLENGTH(a)]
		b[i] = a[i]

	return b
 */

ge = function(a, b, len) {
  var i, l, ref;
  i = 0;
  for (i = l = 0, ref = len; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
    if (a[i] === b[i]) {
      continue;
    } else {
      break;
    }
  }
  if (a[i] >= b[i]) {
    return 1;
  } else {
    return 0;
  }
};

add_numbers = function() {
  var a, b, theResult;
  a = 1.0;
  b = 1.0;
  console.log("add_numbers adding numbers: " + print1(stack[tos - 1], "") + " and " + print1(stack[tos - 2], ""));
  if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
    qadd();
    return;
  }
  save();
  p2 = pop();
  p1 = pop();
  if (isdouble(p1)) {
    a = p1.d;
  } else {
    a = convert_rational_to_double(p1);
  }
  if (isdouble(p2)) {
    b = p2.d;
  } else {
    b = convert_rational_to_double(p2);
  }
  theResult = a + b;
  push_double(theResult);
  return restore();
};

subtract_numbers = function() {
  var a, b;
  double(a, b);
  if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
    qsub();
    return;
  }
  save();
  p2 = pop();
  p1 = pop();
  if (isdouble(p1)) {
    a = p1.d;
  } else {
    a = convert_rational_to_double(p1);
  }
  if (isdouble(p2)) {
    b = p2.d;
  } else {
    b = convert_rational_to_double(p2);
  }
  push_double(a - b);
  return restore();
};

multiply_numbers = function() {
  var a, b;
  a = 0.0;
  b = 0.0;
  if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
    qmul();
    return;
  }
  save();
  p2 = pop();
  p1 = pop();
  if (isdouble(p1)) {
    a = p1.d;
  } else {
    a = convert_rational_to_double(p1);
  }
  if (isdouble(p2)) {
    b = p2.d;
  } else {
    b = convert_rational_to_double(p2);
  }
  push_double(a * b);
  return restore();
};

divide_numbers = function() {
  var a, b;
  a = 0.0;
  b = 0.0;
  if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
    qdiv();
    return;
  }
  save();
  p2 = pop();
  p1 = pop();
  if (iszero(p2)) {
    stop("divide by zero");
  }
  if (isdouble(p1)) {
    a = p1.d;
  } else {
    a = convert_rational_to_double(p1);
  }
  if (isdouble(p2)) {
    b = p2.d;
  } else {
    b = convert_rational_to_double(p2);
  }
  push_double(a / b);
  return restore();
};

invert_number = function() {
  var a, b;
  save();
  p1 = pop();
  if (iszero(p1)) {
    stop("divide by zero");
  }
  if (isdouble(p1)) {
    push_double(1 / p1.d);
    restore();
    return;
  }
  a = bigInt(p1.q.a);
  b = bigInt(p1.q.b);
  p1 = new U();
  p1.k = NUM;
  p1.q.a = b;
  p1.q.b = a;
  push(p1);
  return restore();
};

compare_rationals = function(a, b) {
  var ab, ba, t;
  t = 0;
  ab = mmul(a.q.a, b.q.b);
  ba = mmul(a.q.b, b.q.a);
  t = mcmp(ab, ba);
  return t;
};

compare_numbers = function(a, b) {
  var x, y;
  x = 0.0;
  y = 0.0;
  if (isrational(a) && isrational(b)) {
    return compare_rationals(a, b);
  }
  if (isdouble(a)) {
    x = a.d;
  } else {
    x = convert_rational_to_double(a);
  }
  if (isdouble(b)) {
    y = b.d;
  } else {
    y = convert_rational_to_double(b);
  }
  if (x < y) {
    return -1;
  }
  if (x > y) {
    return 1;
  }
  return 0;
};

negate_number = function() {
  save();
  p1 = pop();
  if (iszero(p1)) {
    push(p1);
    restore();
    return;
  }
  switch (p1.k) {
    case NUM:
      p2 = new U();
      p2.k = NUM;
      p2.q.a = bigInt(p1.q.a.multiply(bigInt.minusOne));
      p2.q.b = bigInt(p1.q.b);
      push(p2);
      break;
    case DOUBLE:
      push_double(-p1.d);
      break;
    default:
      stop("bug caught in mp_negate_number");
  }
  return restore();
};

bignum_truncate = function() {
  var a;
  save();
  p1 = pop();
  a = mdiv(p1.q.a, p1.q.b);
  p1 = new U();
  p1.k = NUM;
  p1.q.a = a;
  p1.q.b = bigInt(1);
  push(p1);
  return restore();
};

mp_numerator = function() {
  save();
  p1 = pop();
  if (p1.k !== NUM) {
    push(one);
    restore();
    return;
  }
  p2 = new U();
  p2.k = NUM;
  p2.q.a = bigInt(p1.q.a);
  p2.q.b = bigInt(1);
  push(p2);
  return restore();
};

mp_denominator = function() {
  save();
  p1 = pop();
  if (p1.k !== NUM) {
    push(one);
    restore();
    return;
  }
  p2 = new U();
  p2.k = NUM;
  p2.q.a = bigInt(p1.q.b);
  p2.q.b = bigInt(1);
  push(p2);
  return restore();
};

bignum_power_number = function(expo) {
  var a, b, t;
  save();
  p1 = pop();
  a = mpow(p1.q.a, Math.abs(expo));
  b = mpow(p1.q.b, Math.abs(expo));
  if (expo < 0) {
    t = a;
    a = b;
    b = t;
  }
  p1 = new U();
  p1.k = NUM;
  p1.q.a = a;
  p1.q.b = b;
  push(p1);
  return restore();
};

convert_bignum_to_double = function(p) {
  return p.toJSNumber();
};

convert_rational_to_double = function(p) {
  var quotientAndRemainder, result;
  quotientAndRemainder = p.q.a.divmod(p.q.b);
  result = quotientAndRemainder.quotient + quotientAndRemainder.remainder / p.q.b.toJSNumber();
  return result;
};

push_integer = function(n) {
  console.log("pushing integer " + n);
  save();
  p1 = new U();
  p1.k = NUM;
  p1.q.a = bigInt(n);
  p1.q.b = bigInt(1);
  push(p1);
  return restore();
};

push_double = function(d) {
  save();
  p1 = new U();
  p1.k = DOUBLE;
  p1.d = d;
  push(p1);
  return restore();
};

push_rational = function(a, b) {

  /*
  	save()
  	p1 = new U()
  	p1.k = NUM
  	p1.q.a = bigInt(a)
  	p1.q.b = bigInt(b)
  	## FIXME -- normalize ##
  	push(p1)
  	restore()
   */
  var p;
  p = new U();
  p.k = NUM;
  p.q.a = bigInt(a);
  p.q.b = bigInt(b);
  return push(p);
};

pop_integer = function() {
  var n;
  n = 0;
  save();
  p1 = pop();
  switch (p1.k) {
    case NUM:
      if (isinteger(p1) && p1.q.a.isSmall) {
        n = p1.q.a.toJSNumber();
      } else {
        n = 0x80000000;
      }
      break;
    case DOUBLE:
      n = Math.floor(p1.q.a);
      break;
    default:
      n = 0x80000000;
  }
  restore();
  return n;
};

print_double = function(p, flag) {
  var buf;
  buf = "";
  buf = "" + p.d;
  if (flag === 1 && buf === '-') {
    return print_str(buf + 1);
  } else {
    return print_str(buf);
  }
};

bignum_scan_integer = function(s) {
  var a, scounter, sign;
  save();
  scounter = 0;
  sign = s[scounter];
  if (sign === '+' || sign === '-') {
    scounter++;
  }
  a = bigInt(s.substring(scounter));
  p1 = new U();
  p1.k = NUM;
  p1.q.a = a;
  p1.q.b = bigInt(1);
  push(p1);
  if (sign === '-') {
    negate();
  }
  return restore();
};

bignum_scan_float = function(s) {
  return push_double(parseInt(s));
};

print_number = function(p, accumulator) {
  var buf, topLevelCall;
  topLevelCall = false;
  if (accumulator == null) {
    topLevelCall = true;
    accumulator = "";
  }
  s = "";
  buf = "";
  switch (p.k) {
    case NUM:
      accumulator += p.q.a.toString();
      if (isfraction(p)) {
        accumulator += "/";
        s = p.q.b.toString();
        accumulator += s;
      }
      break;
    case DOUBLE:
      accumulator += p.d;
  }
  if (topLevelCall) {
    return console.log(accumulator);
  } else {
    return accumulator;
  }
};

gcd_numbers = function() {
  save();
  p2 = pop();
  p1 = pop();
  p3 = new U();
  p3.k = NUM;
  p3.q.a = mgcd(p1.q.a, p2.q.a);
  p3.q.b = mgcd(p1.q.b, p2.q.b);
  push(p3);
  return restore();
};

pop_double = function() {
  var d;
  double(d);
  save();
  p1 = pop();
  switch (p1.k) {
    case NUM:
      d = convert_rational_to_double(p1);
      break;
    case DOUBLE:
      d = p1.d;
      break;
    default:
      d = 0.0;
  }
  restore();
  return d;
};

bignum_float = function() {
  var d;
  double(d);
  d = convert_rational_to_double(pop());
  return push_double(d);
};

bignum_factorial = function(n) {
  save();
  p1 = new U();
  p1.k = NUM;
  p1.q.a = __factorial(n);
  p1.q.b = bigInt(1);
  push(p1);
  return restore();
};

__factorial = function(n) {
  var a, b, i, l, ref, t;
  i = 0;
  if (n === 0 || n === 1) {
    a = bigInt(1);
    return a;
  }
  a = bigInt(2);
  b = bigInt(0);
  if (3 <= n) {
    for (i = l = 3, ref = n; 3 <= ref ? l <= ref : l >= ref; i = 3 <= ref ? ++l : --l) {
      b[0] = Math.floor(i);
      t = mmul(a, b);
      a = t;
    }
  }
  return a;
};

mask = [0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080, 0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000, 0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000, 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000];

mp_set_bit = function(x, k) {
  console.log("not implemented yet");
  debugger;
  return x[k / 32] |= mask[k % 32];
};

mp_clr_bit = function(x, k) {
  console.log("not implemented yet");
  debugger;
  return x[k / 32] &= ~mask[k % 32];
};

mshiftright = function(a) {
  return a = a.shiftRight();
};

Eval_clear = function() {
  clear_symbols();
  defn();
  return push(symbol(NIL));
};

clear = function() {
  return run("clear");
};

Eval_coeff = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  push(cadddr(p1));
  Eval();
  p3 = pop();
  p2 = pop();
  p1 = pop();
  if (p3 === symbol(NIL)) {
    p3 = p2;
    p2 = symbol(SYMBOL_X);
  }
  push(p1);
  push(p2);
  push(p3);
  power();
  divide();
  push(p2);
  return filter();
};

coeff = function() {
  var h, n;
  save();
  p2 = pop();
  p1 = pop();
  h = tos;
  while (1) {
    push(p1);
    push(p2);
    push(zero);
    subst();
    Eval();
    p3 = pop();
    push(p3);
    push(p1);
    push(p3);
    subtract();
    p1 = pop();
    if (equal(p1, zero)) {
      n = tos - h;
      restore();
      return n;
    }
    push(p1);
    push(p2);
    divide();
    p1 = pop();
  }
};

s = ["coeff(40*x^3+30*x^2+20*x+10,3)", "40", "coeff(40*x^3+30*x^2+20*x+10,2)", "30", "coeff(40*x^3+30*x^2+20*x+10,1)", "20", "coeff(40*x^3+30*x^2+20*x+10,0)", "10", "coeff(a*t^3+b*t^2+c*t+d,t,3)", "a", "coeff(a*t^3+b*t^2+c*t+d,t,2)", "b", "coeff(a*t^3+b*t^2+c*t+d,t,1)", "c", "coeff(a*t^3+b*t^2+c*t+d,t,0)", "d"];


/*
void
test_coeff(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}
 */

Eval_conj = function() {
  push(cadr(p1));
  Eval();
  p1 = pop();
  push(p1);
  if (!Find(p1, imaginaryunit)) {
    polar();
    conjugate();
    return clockform();
  } else {
    return conjugate();
  }
};

conjugate = function() {
  push(imaginaryunit);
  push(imaginaryunit);
  negate();
  subst();
  return Eval();
};

consCount = 0;

cons = function() {
  var p;
  consCount++;
  console.log("cons tos: " + tos + " # " + consCount);
  if (consCount === 1429) {
    debugger;
  }
  p = new U();
  p.k = CONS;
  p.cons.cdr = pop();
  if (p === p.cons.cdr) {
    debugger;
    console.log("something wrong p == its cdr");
  }
  p.cons.car = pop();

  /*
  	console.log "cons new cdr.k = " + p.cons.cdr.k + "\nor more in detail:"
  	print1 p.cons.cdr
  	console.log "cons new car.k = " + p.cons.car.k + "\nor more in detail:"
  	print1 p.cons.car
   */
  return push(p);
};

Eval_cos = function() {
  push(cadr(p1));
  Eval();
  return cosine();
};

cosine = function() {
  save();
  p1 = pop();
  if (car(p1) === symbol(ADD)) {
    cosine_of_angle_sum();
  } else {
    cosine_of_angle();
  }
  return restore();
};

cosine_of_angle_sum = function() {
  p2 = cdr(p1);
  while (iscons(p2)) {
    p4 = car(p2);
    if (isnpi(p4)) {
      push(p1);
      push(p4);
      subtract();
      p3 = pop();
      push(p3);
      cosine();
      push(p4);
      cosine();
      multiply();
      push(p3);
      sine();
      push(p4);
      sine();
      multiply();
      subtract();
      return;
    }
    p2 = cdr(p2);
  }
  return cosine_of_angle();
};

cosine_of_angle = function() {
  var d, n;
  if (car(p1) === symbol(ARCCOS)) {
    push(cadr(p1));
    return;
  }
  if (isdouble(p1)) {
    d = cos(p1.d);
    if (fabs(d) < 1e-10) {
      d = 0.0;
    }
    push_double(d);
    return;
  }
  if (isnegative(p1)) {
    push(p1);
    negate();
    p1 = pop();
  }
  if (car(p1) === symbol(ARCTAN)) {
    push_integer(1);
    push(cadr(p1));
    push_integer(2);
    power();
    add();
    push_rational(-1, 2);
    power();
    return;
  }
  push(p1);
  push_integer(180);
  multiply();
  push_symbol(PI);
  divide();
  n = pop_integer();
  if (n < 0) {
    push(symbol(COS));
    push(p1);
    list(2);
    return;
  }
  switch (n % 360) {
    case 90:
    case 270:
      return push_integer(0);
    case 60:
    case 300:
      return push_rational(1, 2);
    case 120:
    case 240:
      return push_rational(-1, 2);
    case 45:
    case 315:
      push_rational(1, 2);
      push_integer(2);
      push_rational(1, 2);
      power();
      return multiply();
    case 135:
    case 225:
      push_rational(-1, 2);
      push_integer(2);
      push_rational(1, 2);
      power();
      return multiply();
    case 30:
    case 330:
      push_rational(1, 2);
      push_integer(3);
      push_rational(1, 2);
      power();
      return multiply();
    case 150:
    case 210:
      push_rational(-1, 2);
      push_integer(3);
      push_rational(1, 2);
      power();
      return multiply();
    case 0:
      return push_integer(1);
    case 180:
      return push_integer(-1);
    default:
      push(symbol(COS));
      push(p1);
      return list(2);
  }
};

s = ["cos(x)", "cos(x)", "cos(-x)", "cos(x)", "cos(b-a)", "cos(a-b)", "f(a,x)=1+cos(float(a/360*2*pi))-float(x)+cos(a/360*2*pi)-x", "", "f(0,1)", "1", "f(90,0)", "1", "f(180,-1)", "1", "f(270,0)", "1", "f(360,1)", "1", "f(-90,0)", "1", "f(-180,-1)", "1", "f(-270,0)", "1", "f(-360,1)", "1", "f(45,sqrt(2)/2)", "1", "f(135,-sqrt(2)/2)", "1", "f(225,-sqrt(2)/2)", "1", "f(315,sqrt(2)/2)", "1", "f(-45,sqrt(2)/2)", "1", "f(-135,-sqrt(2)/2)", "1", "f(-225,-sqrt(2)/2)", "1", "f(-315,sqrt(2)/2)", "1", "f(30,sqrt(3)/2)", "1", "f(150,-sqrt(3)/2)", "1", "f(210,-sqrt(3)/2)", "1", "f(330,sqrt(3)/2)", "1", "f(-30,sqrt(3)/2)", "1", "f(-150,-sqrt(3)/2)", "1", "f(-210,-sqrt(3)/2)", "1", "f(-330,sqrt(3)/2)", "1", "f(60,1/2)", "1", "f(120,-1/2)", "1", "f(240,-1/2)", "1", "f(300,1/2)", "1", "f(-60,1/2)", "1", "f(-120,-1/2)", "1", "f(-240,-1/2)", "1", "f(-300,1/2)", "1", "f=quote(f)", "", "cos(arccos(x))", "x", "cos(1/12*pi)", "cos(1/12*pi)", "cos(arctan(4/3))", "3/5", "cos(-arctan(4/3))", "3/5", "cos(x-8/2*pi)", "cos(x)", "cos(x-7/2*pi)", "-sin(x)", "cos(x-6/2*pi)", "-cos(x)", "cos(x-5/2*pi)", "sin(x)", "cos(x-4/2*pi)", "cos(x)", "cos(x-3/2*pi)", "-sin(x)", "cos(x-2/2*pi)", "-cos(x)", "cos(x-1/2*pi)", "sin(x)", "cos(x+0/2*pi)", "cos(x)", "cos(x+1/2*pi)", "-sin(x)", "cos(x+2/2*pi)", "-cos(x)", "cos(x+3/2*pi)", "sin(x)", "cos(x+4/2*pi)", "cos(x)", "cos(x+5/2*pi)", "-sin(x)", "cos(x+6/2*pi)", "-cos(x)", "cos(x+7/2*pi)", "sin(x)", "cos(x+8/2*pi)", "cos(x)"];


/*
void
test_cos(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}

#endif
 */

init = function() {
  var i, l, ref;
  i = 0;
  flag = 0;
  tos = 0;
  esc_flag = 0;
  draw_flag = 0;
  frame = stack + TOS;
  p0 = symbol(NIL);
  p1 = symbol(NIL);
  p2 = symbol(NIL);
  p3 = symbol(NIL);
  p4 = symbol(NIL);
  p5 = symbol(NIL);
  p6 = symbol(NIL);
  p7 = symbol(NIL);
  p8 = symbol(NIL);
  p9 = symbol(NIL);
  if (flag) {
    return;
  }
  flag = 1;
  for (i = l = 0, ref = NSYM; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
    symtab[i].k = SYM;
    binding[i] = symtab + i;
    arglist[i] = symbol(NIL);
  }
  std_symbol("abs", ABS);
  std_symbol("add", ADD);
  std_symbol("adj", ADJ);
  std_symbol("and", AND);
  std_symbol("arccos", ARCCOS);
  std_symbol("arccosh", ARCCOSH);
  std_symbol("arcsin", ARCSIN);
  std_symbol("arcsinh", ARCSINH);
  std_symbol("arctan", ARCTAN);
  std_symbol("arctanh", ARCTANH);
  std_symbol("arg", ARG);
  std_symbol("atomize", ATOMIZE);
  std_symbol("besselj", BESSELJ);
  std_symbol("bessely", BESSELY);
  std_symbol("binding", BINDING);
  std_symbol("binomial", BINOMIAL);
  std_symbol("ceiling", CEILING);
  std_symbol("check", CHECK);
  std_symbol("choose", CHOOSE);
  std_symbol("circexp", CIRCEXP);
  std_symbol("clear", CLEAR);
  std_symbol("clock", CLOCK);
  std_symbol("coeff", COEFF);
  std_symbol("cofactor", COFACTOR);
  std_symbol("condense", CONDENSE);
  std_symbol("conj", CONJ);
  std_symbol("contract", CONTRACT);
  std_symbol("cos", COS);
  std_symbol("cosh", COSH);
  std_symbol("decomp", DECOMP);
  std_symbol("defint", DEFINT);
  std_symbol("deg", DEGREE);
  std_symbol("denominator", DENOMINATOR);
  std_symbol("det", DET);
  std_symbol("derivative", DERIVATIVE);
  std_symbol("dim", DIM);
  std_symbol("dirac", DIRAC);
  std_symbol("display", DISPLAY);
  std_symbol("divisors", DIVISORS);
  std_symbol("do", DO);
  std_symbol("dot", DOT);
  std_symbol("draw", DRAW);
  std_symbol("dsolve", DSOLVE);
  std_symbol("erf", ERF);
  std_symbol("erfc", ERFC);
  std_symbol("eigen", EIGEN);
  std_symbol("eigenval", EIGENVAL);
  std_symbol("eigenvec", EIGENVEC);
  std_symbol("eval", EVAL);
  std_symbol("exp", EXP);
  std_symbol("expand", EXPAND);
  std_symbol("expcos", EXPCOS);
  std_symbol("expsin", EXPSIN);
  std_symbol("factor", FACTOR);
  std_symbol("factorial", FACTORIAL);
  std_symbol("factorpoly", FACTORPOLY);
  std_symbol("filter", FILTER);
  std_symbol("float", FLOATF);
  std_symbol("floor", FLOOR);
  std_symbol("for", FOR);
  std_symbol("Gamma", GAMMA);
  std_symbol("gcd", GCD);
  std_symbol("hermite", HERMITE);
  std_symbol("hilbert", HILBERT);
  std_symbol("imag", IMAG);
  std_symbol("component", INDEX);
  std_symbol("inner", INNER);
  std_symbol("integral", INTEGRAL);
  std_symbol("inv", INV);
  std_symbol("invg", INVG);
  std_symbol("isinteger", ISINTEGER);
  std_symbol("isprime", ISPRIME);
  std_symbol("laguerre", LAGUERRE);
  std_symbol("lcm", LCM);
  std_symbol("leading", LEADING);
  std_symbol("legendre", LEGENDRE);
  std_symbol("log", LOG);
  std_symbol("mag", MAG);
  std_symbol("mod", MOD);
  std_symbol("multiply", MULTIPLY);
  std_symbol("not", NOT);
  std_symbol("nroots", NROOTS);
  std_symbol("number", NUMBER);
  std_symbol("numerator", NUMERATOR);
  std_symbol("operator", OPERATOR);
  std_symbol("or", OR);
  std_symbol("outer", OUTER);
  std_symbol("polar", POLAR);
  std_symbol("power", POWER);
  std_symbol("prime", PRIME);
  std_symbol("print", PRINT);
  std_symbol("product", PRODUCT);
  std_symbol("quote", QUOTE);
  std_symbol("quotient", QUOTIENT);
  std_symbol("rank", RANK);
  std_symbol("rationalize", RATIONALIZE);
  std_symbol("real", REAL);
  std_symbol("rect", YYRECT);
  std_symbol("roots", ROOTS);
  std_symbol("equals", SETQ);
  std_symbol("sgn", SGN);
  std_symbol("simplify", SIMPLIFY);
  std_symbol("sin", SIN);
  std_symbol("sinh", SINH);
  std_symbol("sqrt", SQRT);
  std_symbol("stop", STOP);
  std_symbol("subst", SUBST);
  std_symbol("sum", SUM);
  std_symbol("tan", TAN);
  std_symbol("tanh", TANH);
  std_symbol("taylor", TAYLOR);
  std_symbol("test", TEST);
  std_symbol("testeq", TESTEQ);
  std_symbol("testge", TESTGE);
  std_symbol("testgt", TESTGT);
  std_symbol("testle", TESTLE);
  std_symbol("testlt", TESTLT);
  std_symbol("transpose", TRANSPOSE);
  std_symbol("unit", UNIT);
  std_symbol("zero", ZERO);
  std_symbol("nil", NIL);
  std_symbol("autoexpand", AUTOEXPAND);
  std_symbol("bake", BAKE);
  std_symbol("last", LAST);
  std_symbol("trace", TRACE);
  std_symbol("tty", TTY);
  std_symbol("~", YYE);
  std_symbol("$DRAWX", DRAWX);
  std_symbol("$METAA", METAA);
  std_symbol("$METAB", METAB);
  std_symbol("$METAX", METAX);
  std_symbol("$SECRETX", SECRETX);
  std_symbol("pi", PI);
  std_symbol("a", SYMBOL_A);
  std_symbol("b", SYMBOL_B);
  std_symbol("c", SYMBOL_C);
  std_symbol("d", SYMBOL_D);
  std_symbol("i", SYMBOL_I);
  std_symbol("j", SYMBOL_J);
  std_symbol("n", SYMBOL_N);
  std_symbol("r", SYMBOL_R);
  std_symbol("s", SYMBOL_S);
  std_symbol("t", SYMBOL_T);
  std_symbol("x", SYMBOL_X);
  std_symbol("y", SYMBOL_Y);
  std_symbol("z", SYMBOL_Z);
  std_symbol("$C1", C1);
  std_symbol("$C2", C2);
  std_symbol("$C3", C3);
  std_symbol("$C4", C4);
  std_symbol("$C5", C5);
  std_symbol("$C6", C6);
  push_integer(0);
  zero = pop();
  push_integer(1);
  one = pop();
  push_symbol(POWER);
  push_integer(-1);
  push_rational(1, 2);
  list(3);
  imaginaryunit = pop();
  return defn();
};

defn_str = ["e=exp(1)", "i=sqrt(-1)", "autoexpand=1", "trange=(-pi,pi)", "xrange=(-10,10)", "yrange=(-10,10)", "last=0", "trace=0", "tty=0", "cross(u,v)=(u[2]*v[3]-u[3]*v[2],u[3]*v[1]-u[1]*v[3],u[1]*v[2]-u[2]*v[1])", "curl(v)=(d(v[3],y)-d(v[2],z),d(v[1],z)-d(v[3],x),d(v[2],x)-d(v[1],y))", "div(v)=d(v[1],x)+d(v[2],y)+d(v[3],z)", "ln(x)=log(x)"];

defn = function() {
  var i, l, n, ref, results;
  i = 0;
  n = 0;
  n = defn_str.length;
  results = [];
  for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
    scan(defn_str[i]);
    eval();
    results.push(pop());
  }
  return results;
};

define_user_function = function() {
  p3 = caadr(p1);
  p4 = cdadr(p1);
  p5 = caddr(p1);
  if (!issymbol(p3)) {
    stop("function name?");
  }
  if (car(p5) === symbol(EVAL)) {
    push(cadr(p5));
    Eval();
    p5 = pop();
  }
  set_binding_and_arglist(p3, p5, p4);
  return push_symbol(NIL);
};

Eval_derivative = function() {
  var doNothing, i, l, n, o, ref, ref1;
  i = 0;
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p2 = pop();
  if (p2 === symbol(NIL)) {
    guess();
    push(symbol(NIL));
  } else if (isnum(p2)) {
    guess();
    push(p2);
  } else {
    push(p2);
    p1 = cdr(p1);
    push(car(p1));
    Eval();
  }
  p5 = pop();
  p4 = pop();
  p3 = pop();
  while (1.) {
    if (isnum(p5)) {
      push(p5);
      n = pop_integer();
      if (n === 0x80000000) {
        stop("nth derivative: check n");
      }
    } else {
      n = 1;
    }
    push(p3);
    if (n >= 0) {
      for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        push(p4);
        derivative();
      }
    } else {
      n = -n;
      for (i = o = 0, ref1 = n; 0 <= ref1 ? o < ref1 : o > ref1; i = 0 <= ref1 ? ++o : --o) {
        push(p4);
        integral();
      }
    }
    p3 = pop();
    if (p5 === symbol(NIL)) {
      break;
    }
    if (isnum(p5)) {
      p1 = cdr(p1);
      push(car(p1));
      Eval();
      p5 = pop();
      if (p5 === symbol(NIL)) {
        break;
      }
      if (isnum(p5)) {
        doNothing = 1;
      } else {
        p4 = p5;
        p1 = cdr(p1);
        push(car(p1));
        Eval();
        p5 = pop();
      }
    } else {
      p4 = p5;
      p1 = cdr(p1);
      push(car(p1));
      Eval();
      p5 = pop();
    }
  }
  return push(p3);
};

derivative = function() {
  save();
  p2 = pop();
  p1 = pop();
  if (isnum(p2)) {
    stop("undefined function");
  }
  if (istensor(p1)) {
    if (istensor(p2)) {
      d_tensor_tensor();
    } else {
      d_tensor_scalar();
    }
  } else {
    if (istensor(p2)) {
      d_scalar_tensor();
    } else {
      d_scalar_scalar();
    }
  }
  return restore();
};

d_scalar_scalar = function() {
  if (issymbol(p2)) {
    return d_scalar_scalar_1();
  } else {
    push(p1);
    push(p2);
    push(symbol(SECRETX));
    subst();
    push(symbol(SECRETX));
    derivative();
    push(symbol(SECRETX));
    push(p2);
    return subst();
  }
};

d_scalar_scalar_1 = function() {
  if (equal(p1, p2)) {
    push(one);
    return;
  }
  if (!iscons(p1)) {
    push(zero);
    return;
  }
  if (isadd(p1)) {
    dsum();
    return;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    dproduct();
    return;
  }
  if (car(p1) === symbol(POWER)) {
    dpower();
    return;
  }
  if (car(p1) === symbol(DERIVATIVE)) {
    dd();
    return;
  }
  if (car(p1) === symbol(LOG)) {
    dlog();
    return;
  }
  if (car(p1) === symbol(SIN)) {
    dsin();
    return;
  }
  if (car(p1) === symbol(COS)) {
    dcos();
    return;
  }
  if (car(p1) === symbol(TAN)) {
    dtan();
    return;
  }
  if (car(p1) === symbol(ARCSIN)) {
    darcsin();
    return;
  }
  if (car(p1) === symbol(ARCCOS)) {
    darccos();
    return;
  }
  if (car(p1) === symbol(ARCTAN)) {
    darctan();
    return;
  }
  if (car(p1) === symbol(SINH)) {
    dsinh();
    return;
  }
  if (car(p1) === symbol(COSH)) {
    dcosh();
    return;
  }
  if (car(p1) === symbol(TANH)) {
    dtanh();
    return;
  }
  if (car(p1) === symbol(ARCSINH)) {
    darcsinh();
    return;
  }
  if (car(p1) === symbol(ARCCOSH)) {
    darccosh();
    return;
  }
  if (car(p1) === symbol(ARCTANH)) {
    darctanh();
    return;
  }
  if (car(p1) === symbol(ABS)) {
    dabs();
    return;
  }
  if (car(p1) === symbol(SGN)) {
    dsgn();
    return;
  }
  if (car(p1) === symbol(HERMITE)) {
    dhermite();
    return;
  }
  if (car(p1) === symbol(ERF)) {
    derf();
    return;
  }
  if (car(p1) === symbol(ERFC)) {
    derfc();
    return;
  }
  if (car(p1) === symbol(BESSELJ)) {
    if (iszero(caddr(p1))) {
      dbesselj0();
    } else {
      dbesseljn();
    }
    return;
  }
  if (car(p1) === symbol(BESSELY)) {
    if (iszero(caddr(p1))) {
      dbessely0();
    } else {
      dbesselyn();
    }
    return;
  }
  if (car(p1) === symbol(INTEGRAL) && caddr(p1) === p2) {
    derivative_of_integral();
    return;
  }
  return dfunction();
};

dsum = function() {
  var h;
  h = tos;
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    push(p2);
    derivative();
    p1 = cdr(p1);
  }
  return add_all(tos - h);
};

dproduct = function() {
  var i, j, l, n, o, ref, ref1;
  i = 0;
  j = 0;
  n = 0;
  n = length(p1) - 1;
  for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
    p3 = cdr(p1);
    for (j = o = 0, ref1 = n; 0 <= ref1 ? o < ref1 : o > ref1; j = 0 <= ref1 ? ++o : --o) {
      push(car(p3));
      if (i === j) {
        push(p2);
        derivative();
      }
      p3 = cdr(p3);
    }
    multiply_all(n);
  }
  return add_all(n);
};

dpower = function() {
  push(caddr(p1));
  push(cadr(p1));
  divide();
  push(cadr(p1));
  push(p2);
  derivative();
  multiply();
  push(cadr(p1));
  logarithm();
  push(caddr(p1));
  push(p2);
  derivative();
  multiply();
  add();
  push(p1);
  return multiply();
};

dlog = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  return divide();
};

dd = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  p3 = pop();
  if (car(p3) === symbol(DERIVATIVE)) {
    push_symbol(DERIVATIVE);
    push_symbol(DERIVATIVE);
    push(cadr(p3));
    if (lessp(caddr(p3), caddr(p1))) {
      push(caddr(p3));
      list(3);
      push(caddr(p1));
    } else {
      push(caddr(p1));
      list(3);
      push(caddr(p3));
    }
    return list(3);
  } else {
    push(p3);
    push(caddr(p1));
    return derivative();
  }
};

dfunction = function() {
  p3 = cdr(p1);
  if (p3 === symbol(NIL) || Find(p3, p2)) {
    push_symbol(DERIVATIVE);
    push(p1);
    push(p2);
    return list(3);
  } else {
    return push(zero);
  }
};

dsin = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  cosine();
  return multiply();
};

dcos = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  sine();
  multiply();
  return negate();
};

dtan = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  cosine();
  push_integer(-2);
  power();
  return multiply();
};

darcsin = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push_integer(1);
  push(cadr(p1));
  push_integer(2);
  power();
  subtract();
  push_rational(-1, 2);
  power();
  return multiply();
};

darccos = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push_integer(1);
  push(cadr(p1));
  push_integer(2);
  power();
  subtract();
  push_rational(-1, 2);
  power();
  multiply();
  return negate();
};

darctan = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push_integer(1);
  push(cadr(p1));
  push_integer(2);
  power();
  add();
  inverse();
  multiply();
  return simplify();
};

dsinh = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  ycosh();
  return multiply();
};

dcosh = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  ysinh();
  return multiply();
};

dtanh = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  ycosh();
  push_integer(-2);
  power();
  return multiply();
};

darcsinh = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  push_integer(2);
  power();
  push_integer(1);
  add();
  push_rational(-1, 2);
  power();
  return multiply();
};

darccosh = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  push_integer(2);
  power();
  push_integer(-1);
  add();
  push_rational(-1, 2);
  power();
  return multiply();
};

darctanh = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push_integer(1);
  push(cadr(p1));
  push_integer(2);
  power();
  subtract();
  inverse();
  return multiply();
};

dabs = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  sgn();
  return multiply();
};

dsgn = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  dirac();
  multiply();
  push_integer(2);
  return multiply();
};

dhermite = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push_integer(2);
  push(caddr(p1));
  multiply();
  multiply();
  push(cadr(p1));
  push(caddr(p1));
  push_integer(-1);
  add();
  hermite();
  return multiply();
};

derf = function() {
  push(cadr(p1));
  push_integer(2);
  power();
  push_integer(-1);
  multiply();
  exponential();
  push_symbol(PI);
  push_rational(-1, 2);
  power();
  multiply();
  push_integer(2);
  multiply();
  push(cadr(p1));
  push(p2);
  derivative();
  return multiply();
};

derfc = function() {
  push(cadr(p1));
  push_integer(2);
  power();
  push_integer(-1);
  multiply();
  exponential();
  push_symbol(PI);
  push_rational(-1, 2);
  power();
  multiply();
  push_integer(-2);
  multiply();
  push(cadr(p1));
  push(p2);
  derivative();
  return multiply();
};

dbesselj0 = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  push_integer(1);
  besselj();
  multiply();
  push_integer(-1);
  return multiply();
};

dbesseljn = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  push(caddr(p1));
  push_integer(-1);
  add();
  besselj();
  push(caddr(p1));
  push_integer(-1);
  multiply();
  push(cadr(p1));
  divide();
  push(cadr(p1));
  push(caddr(p1));
  besselj();
  multiply();
  add();
  return multiply();
};

dbessely0 = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  push_integer(1);
  besselj();
  multiply();
  push_integer(-1);
  return multiply();
};

dbesselyn = function() {
  push(cadr(p1));
  push(p2);
  derivative();
  push(cadr(p1));
  push(caddr(p1));
  push_integer(-1);
  add();
  bessely();
  push(caddr(p1));
  push_integer(-1);
  multiply();
  push(cadr(p1));
  divide();
  push(cadr(p1));
  push(caddr(p1));
  bessely();
  multiply();
  add();
  return multiply();
};

derivative_of_integral = function() {
  return push(cadr(p1));
};

s = ["x=quote(x)", "", "f=quote(f)", "", "g=quote(g)", "", "d(a,x)", "0", "d(x,x)", "1", "d(x^2,x)", "2*x", "d(log(x),x)", "1/x", "d(exp(x),x)", "exp(x)", "d(a^x,x)", "a^x*log(a)", "d(x^x,x)-(x^x+x^x*log(x))", "0", "d(log(x^2+5),x)-(2*x/(5+x^2))", "0", "d(d(f(x),x),y)", "0", "d(d(f(x),y),x)", "0", "d(d(f(y),x),y)", "0", "d(d(f(y),y),x)", "0", "d((x*y*z,y,x+z),(x,y,z))", "((y*z,x*z,x*y),(0,1,0),(1,0,1))", "d(x+z,(x,y,z))", "(1,0,1)", "d(cos(theta)^2,cos(theta))", "2*cos(theta)", "d(f())", "d(f(),x)", "d(x^2)", "2*x", "d(t^2)", "2*t", "d(t^2 x^2)", "2*t^2*x", "d(sin(x),x)-cos(x)", "0", "d(cos(x),x)+sin(x)", "0", "d(tan(x),x)-cos(x)^(-2)", "0", "d(arcsin(x),x)-1/sqrt(1-x^2)", "0", "d(arccos(x),x)+1/sqrt(1-x^2)", "0", "d(arctan(x),x)-1/(1+x^2)", "0", "d(arctan(y/x),x)", "-y/(x^2+y^2)", "d(arctan(y/x),y)", "x/(x^2+y^2)", "d(sinh(x),x)-cosh(x)", "0", "d(cosh(x),x)-sinh(x)", "0", "d(tanh(x),x)-cosh(x)^(-2)", "0", "d(arcsinh(x),x)-1/sqrt(x^2+1)", "0", "d(arccosh(x),x)-1/sqrt(x^2-1)", "0", "d(arctanh(x),x)-1/(1-x^2)", "0", "d(sin(cos(x)),x)+cos(cos(x))*sin(x)", "0", "d(sin(x)^2,x)-2*sin(x)*cos(x)", "0", "d(sin(cos(x)),cos(x))-cos(cos(x))", "0", "d(abs(x),x)", "sgn(x)", "d(sgn(x),x)", "2*dirac(x)", "d(f(),x)", "d(f(),x)", "d(f(x),x)", "d(f(x),x)", "d(f(y),x)", "0", "d(g(f(x)),f(x))", "d(g(f(x)),f(x))", "d(g(f(x)),x)", "d(g(f(x)),x)", "d(erf(x))-2*exp(-x^2)/sqrt(pi)", "0", "f=x^5*y^7", "", "d(f)", "5*x^4*y^7", "d(f,x)", "5*x^4*y^7", "d(f,x,0)", "x^5*y^7", "d(f,x,1)", "5*x^4*y^7", "d(f,x,2)", "20*x^3*y^7", "d(f,2)", "20*x^3*y^7", "d(f,2,y)", "140*x^3*y^6", "d(f,x,x,y,y)", "840*x^3*y^5", "f=quote(f)", ""];


/*
void
test_derivative(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}

#endif
 */

YMAX = 10000;

glyph = (function() {
  function glyph() {}

  glyph.prototype.c = 0;

  glyph.prototype.x = 0;

  glyph.prototype.y = 0;

  return glyph;

})();

chartab = [];

for (charTabIndex = l = 0, ref = YMAX; 0 <= ref ? l < ref : l > ref; charTabIndex = 0 <= ref ? ++l : --l) {
  chartab[charTabIndex] = new glyph();
}

yindex = 0;

level = 0;

emit_x = 0;

expr_level = 0;

display_flag = 0;

printchar_nowrap = function(character, accumulator) {
  var topLevelCall;
  if (accumulator == null) {
    topLevelCall = true;
    accumulator = "";
  }
  accumulator += character;
  return accumulator;
};

printchar = function(character, accumulator) {
  return printchar_nowrap(character, accumulator);
};

display = function(p) {
  debugger;
  var h, ref1, w, y;
  h = 0;
  w = 0;
  y = 0;
  save();
  yindex = 0;
  level = 0;
  emit_x = 0;
  emit_top_expr(p);
  ref1 = get_size(0, yindex), h = ref1[0], w = ref1[1], y = ref1[2];
  if (w > 100) {
    printline(p);
    restore();
    return;
  }
  print_it();
  return restore();
};

emit_top_expr = function(p) {
  if (car(p) === symbol(SETQ)) {
    emit_expr(cadr(p));
    __emit_str(" = ");
    emit_expr(caddr(p));
    return;
  }
  if (istensor(p)) {
    return emit_tensor(p);
  } else {
    return emit_expr(p);
  }
};

will_be_displayed_as_fraction = function(p) {
  if (level > 0) {
    return 0;
  }
  if (isfraction(p)) {
    return 1;
  }
  if (car(p) !== symbol(MULTIPLY)) {
    return 0;
  }
  if (isfraction(cadr(p))) {
    return 1;
  }
  while (iscons(p)) {
    if (isdenominator(car(p))) {
      return 1;
    }
    p = cdr(p);
  }
  return 0;
};

emit_expr = function(p) {
  expr_level++;
  if (car(p) === symbol(ADD)) {
    p = cdr(p);
    if (__is_negative(car(p))) {
      __emit_char('-');
      if (will_be_displayed_as_fraction(car(p))) {
        __emit_char(' ');
      }
    }
    emit_term(car(p));
    p = cdr(p);
    while (iscons(p)) {
      if (__is_negative(car(p))) {
        __emit_char(' ');
        __emit_char('-');
        __emit_char(' ');
      } else {
        __emit_char(' ');
        __emit_char('+');
        __emit_char(' ');
      }
      emit_term(car(p));
      p = cdr(p);
    }
  } else {
    if (__is_negative(p)) {
      __emit_char('-');
      if (will_be_displayed_as_fraction(p)) {
        __emit_char(' ');
      }
    }
    emit_term(p);
  }
  return expr_level--;
};

emit_unsigned_expr = function(p) {
  var results;
  if (car(p) === symbol(ADD)) {
    p = cdr(p);
    emit_term(car(p));
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      if (__is_negative(car(p))) {
        __emit_char(' ');
        __emit_char('-');
        __emit_char(' ');
      } else {
        __emit_char(' ');
        __emit_char('+');
        __emit_char(' ');
      }
      emit_term(car(p));
      results.push(p = cdr(p));
    }
    return results;
  } else {
    return emit_term(p);
  }
};

__is_negative = function(p) {
  if (isnegativenumber(p)) {
    return 1;
  }
  if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {
    return 1;
  }
  return 0;
};

emit_term = function(p) {
  var n;
  if (car(p) === symbol(MULTIPLY)) {
    n = count_denominators(p);
    if (n && level === 0) {
      return emit_fraction(p, n);
    } else {
      return emit_multiply(p, n);
    }
  } else {
    return emit_factor(p);
  }
};

isdenominator = function(p) {
  if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && __is_negative(caddr(p))) {
    return 1;
  } else {
    return 0;
  }
};

count_denominators = function(p) {
  var count, q;
  count = 0;
  p = cdr(p);
  while (iscons(p)) {
    q = car(p);
    if (isdenominator(q)) {
      count++;
    }
    p = cdr(p);
  }
  return count;
};

emit_multiply = function(p, n) {
  var results;
  if (n === 0) {
    p = cdr(p);
    if (isplusone(car(p)) || isminusone(car(p))) {
      p = cdr(p);
    }
    emit_factor(car(p));
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      __emit_char(' ');
      emit_factor(car(p));
      results.push(p = cdr(p));
    }
    return results;
  } else {
    emit_numerators(p);
    __emit_char('/');
    if (n > 1 || isfraction(cadr(p))) {
      __emit_char('(');
      emit_denominators(p);
      return __emit_char(')');
    } else {
      return emit_denominators(p);
    }
  }
};

emit_fraction = function(p, d) {
  var count, doNothing, k1, k2, n, x;
  count = 0;
  k1 = 0;
  k2 = 0;
  n = 0;
  x = 0;
  save();
  p3 = one;
  p4 = one;
  if (isrational(cadr(p))) {
    push(cadr(p));
    mp_numerator();
    absval();
    p3 = pop();
    push(cadr(p));
    mp_denominator();
    p4 = pop();
  }
  if (isdouble(cadr(p))) {
    push(cadr(p));
    absval();
    p3 = pop();
  }
  if (isplusone(p3)) {
    n = 0;
  } else {
    n = 1;
  }
  p1 = cdr(p);
  if (isnum(car(p1))) {
    p1 = cdr(p1);
  }
  while (iscons(p1)) {
    p2 = car(p1);
    if (isdenominator(p2)) {
      doNothing = 1;
    } else {
      n++;
    }
    p1 = cdr(p1);
  }
  x = emit_x;
  k1 = yindex;
  count = 0;
  if (!isplusone(p3)) {
    emit_number(p3, 0);
    count++;
  }
  p1 = cdr(p);
  if (isnum(car(p1))) {
    p1 = cdr(p1);
  }
  while (iscons(p1)) {
    p2 = car(p1);
    if (isdenominator(p2)) {
      doNothing = 1;
    } else {
      if (count > 0) {
        __emit_char(' ');
      }
      if (n === 1) {
        emit_expr(p2);
      } else {
        emit_factor(p2);
      }
      count++;
    }
    p1 = cdr(p1);
  }
  if (count === 0) {
    __emit_char('1');
  }
  k2 = yindex;
  count = 0;
  if (!isplusone(p4)) {
    emit_number(p4, 0);
    count++;
    d++;
  }
  p1 = cdr(p);
  if (isrational(car(p1))) {
    p1 = cdr(p1);
  }
  while (iscons(p1)) {
    p2 = car(p1);
    if (isdenominator(p2)) {
      if (count > 0) {
        __emit_char(' ');
      }
      emit_denominator(p2, d);
      count++;
    }
    p1 = cdr(p1);
  }
  fixup_fraction(x, k1, k2);
  return restore();
};

emit_numerators = function(p) {
  var doNothing, n;
  int(n);
  save();
  p1 = one;
  p = cdr(p);
  if (isrational(car(p))) {
    push(car(p));
    mp_numerator();
    absval();
    p1 = pop();
    p = cdr(p);
  } else if (isdouble(car(p))) {
    push(car(p));
    absval();
    p1 = pop();
    p = cdr(p);
  }
  n = 0;
  if (!isplusone(p1)) {
    emit_number(p1, 0);
    n++;
  }
  while (iscons(p)) {
    if (isdenominator(car(p))) {
      doNothing = 1;
    } else {
      if (n > 0) {
        __emit_char(' ');
      }
      emit_factor(car(p));
      n++;
    }
    p = cdr(p);
  }
  if (n === 0) {
    __emit_char('1');
  }
  return restore();
};

emit_denominators = function(p) {
  var n;
  int(n);
  save();
  n = 0;
  p = cdr(p);
  if (isfraction(car(p))) {
    push(car(p));
    mp_denominator();
    p1 = pop();
    emit_number(p1, 0);
    n++;
    p = cdr(p);
  }
  while (iscons(p)) {
    if (isdenominator(car(p))) {
      if (n > 0) {
        __emit_char(' ');
      }
      emit_denominator(car(p), 0);
      n++;
    }
    p = cdr(p);
  }
  return restore();
};

emit_factor = function(p) {
  if (istensor(p)) {
    if (level === 0) {
      emit_flat_tensor(p);
    } else {
      emit_flat_tensor(p);
    }
    return;
  }
  if (isdouble(p)) {
    emit_number(p, 0);
    return;
  }
  if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY)) {
    emit_subexpr(p);
    return;
  }
  if (car(p) === symbol(POWER)) {
    emit_power(p);
    return;
  }
  if (iscons(p)) {
    emit_function(p);
    return;
  }
  if (isnum(p)) {
    if (level === 0) {
      emit_numerical_fraction(p);
    } else {
      emit_number(p, 0);
    }
    return;
  }
  if (issymbol(p)) {
    emit_symbol(p);
    return;
  }
  if (isstr(p)) {
    emit_string(p);
  }
};

emit_numerical_fraction = function(p) {
  var k1, k2, x;
  k1 = 0;
  k2 = 0;
  x = 0;
  save();
  push(p);
  mp_numerator();
  absval();
  p3 = pop();
  push(p);
  mp_denominator();
  p4 = pop();
  if (isplusone(p4)) {
    emit_number(p3, 0);
    restore();
    return;
  }
  x = emit_x;
  k1 = yindex;
  emit_number(p3, 0);
  k2 = yindex;
  emit_number(p4, 0);
  fixup_fraction(x, k1, k2);
  return restore();
};

isfactor = function(p) {
  if (iscons(p) && car(p) !== symbol(ADD) && car(p) !== symbol(MULTIPLY) && car(p) !== symbol(POWER)) {
    return 1;
  }
  if (issymbol(p)) {
    return 1;
  }
  if (isfraction(p)) {
    return 0;
  }
  if (isnegativenumber(p)) {
    return 0;
  }
  if (isnum(p)) {
    return 1;
  }
  return 0;
};

emit_power = function(p) {
  var k1, k2, x;
  k1 = 0;
  k2 = 0;
  x = 0;
  if (cadr(p) === symbol(E)) {
    __emit_str("exp(");
    emit_expr(caddr(p));
    __emit_char(')');
    return;
  }
  if (level > 0) {
    if (isminusone(caddr(p))) {
      __emit_char('1');
      __emit_char('/');
      if (isfactor(cadr(p))) {
        emit_factor(cadr(p));
      } else {
        emit_subexpr(cadr(p));
      }
    } else {
      if (isfactor(cadr(p))) {
        emit_factor(cadr(p));
      } else {
        emit_subexpr(cadr(p));
      }
      __emit_char('^');
      if (isfactor(caddr(p))) {
        emit_factor(caddr(p));
      } else {
        emit_subexpr(caddr(p));
      }
    }
    return;
  }
  if (__is_negative(caddr(p))) {
    x = emit_x;
    k1 = yindex;
    __emit_char('1');
    k2 = yindex;
    emit_denominator(p, 1);
    fixup_fraction(x, k1, k2);
    return;
  }
  k1 = yindex;
  if (isfactor(cadr(p))) {
    emit_factor(cadr(p));
  } else {
    emit_subexpr(cadr(p));
  }
  k2 = yindex;
  level++;
  emit_expr(caddr(p));
  level--;
  return fixup_power(k1, k2);
};

emit_denominator = function(p, n) {
  var k1, k2;
  k1 = 0;
  k2 = 0;
  if (isminusone(caddr(p))) {
    if (n === 1) {
      emit_expr(cadr(p));
    } else {
      emit_factor(cadr(p));
    }
    return;
  }
  k1 = yindex;
  if (isfactor(cadr(p))) {
    emit_factor(cadr(p));
  } else {
    emit_subexpr(cadr(p));
  }
  k2 = yindex;
  level++;
  emit_unsigned_expr(caddr(p));
  level--;
  return fixup_power(k1, k2);
};

emit_function = function(p) {
  if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {
    emit_index_function(p);
    return;
  }
  if (car(p) === symbol(FACTORIAL)) {
    emit_factorial_function(p);
    return;
  }
  if (car(p) === symbol(DERIVATIVE)) {
    __emit_char('d');
  } else {
    emit_symbol(car(p));
  }
  __emit_char('(');
  p = cdr(p);
  if (iscons(p)) {
    emit_expr(car(p));
    p = cdr(p);
    while (iscons(p)) {
      __emit_char(',');
      emit_expr(car(p));
      p = cdr(p);
    }
  }
  return __emit_char(')');
};

emit_index_function = function(p) {
  p = cdr(p);
  if (caar(p) === symbol(ADD) || caar(p) === symbol(MULTIPLY) || caar(p) === symbol(POWER) || caar(p) === symbol(FACTORIAL)) {
    emit_subexpr(car(p));
  } else {
    emit_expr(car(p));
  }
  __emit_char('[');
  p = cdr(p);
  if (iscons(p)) {
    emit_expr(car(p));
    p = cdr(p);
    while (iscons(p)) {
      __emit_char(',');
      emit_expr(car(p));
      p = cdr(p);
    }
  }
  return __emit_char(']');
};

emit_factorial_function = function(p) {
  p = cadr(p);
  if (car(p) === symbol(ADD) || car(p) === symbol(MULTIPLY) || car(p) === symbol(POWER) || car(p) === symbol(FACTORIAL)) {
    emit_subexpr(p);
  } else {
    emit_expr(p);
  }
  return __emit_char('!');
};

emit_subexpr = function(p) {
  __emit_char('(');
  emit_expr(p);
  return __emit_char(')');
};

emit_symbol = function(p) {
  var i, o, ref1, results;
  i = 0;
  if (p === symbol(E)) {
    __emit_str("exp(1)");
    return;
  }
  s = get_printname(p);
  results = [];
  for (i = o = 0, ref1 = s.length; 0 <= ref1 ? o < ref1 : o > ref1; i = 0 <= ref1 ? ++o : --o) {
    results.push(__emit_char(s[i]));
  }
  return results;
};

emit_string = function(p) {
  var i, o, ref1, results;
  i = 0;
  s = p.str;
  results = [];
  for (i = o = 0, ref1 = s.length; 0 <= ref1 ? o < ref1 : o > ref1; i = 0 <= ref1 ? ++o : --o) {
    results.push(__emit_char(s[i]));
  }
  return results;
};

fixup_fraction = function(x, k1, k2) {
  var dx, dy, h1, h2, i, o, ref1, ref2, ref3, results, w, w1, w2, y, y1, y2;
  dx = 0;
  dy = 0;
  i = 0;
  w = 0;
  y = 0;
  h1 = 0;
  w1 = 0;
  y1 = 0;
  h2 = 0;
  w2 = 0;
  y2 = 0;
  ref1 = get_size(k1, k2), h1 = ref1[0], w1 = ref1[1], y1 = ref1[2];
  ref2 = get_size(k2, yindex), h2 = ref2[0], w2 = ref2[1], y2 = ref2[2];
  if (w2 > w1) {
    dx = (w2 - w1) / 2;
  } else {
    dx = 0;
  }
  dx++;
  y = y1 + h1 - 1;
  dy = -y - 1;
  move(k1, k2, dx, dy);
  if (w2 > w1) {
    dx = -w1;
  } else {
    dx = -w1 + (w1 - w2) / 2;
  }
  dx++;
  dy = -y2 + 1;
  move(k2, yindex, dx, dy);
  if (w2 > w1) {
    w = w2;
  } else {
    w = w1;
  }
  w += 2;
  emit_x = x;
  results = [];
  for (i = o = 0, ref3 = w; 0 <= ref3 ? o < ref3 : o > ref3; i = 0 <= ref3 ? ++o : --o) {
    results.push(__emit_char('-'));
  }
  return results;
};

fixup_power = function(k1, k2) {
  var dy, h1, h2, ref1, ref2, w1, w2, y1, y2;
  dy = 0;
  h1 = 0;
  w1 = 0;
  y1 = 0;
  h2 = 0;
  w2 = 0;
  y2 = 0;
  ref1 = get_size(k1, k2), h1 = ref1[0], w1 = ref1[1], y1 = ref1[2];
  ref2 = get_size(k2, yindex), h2 = ref2[0], w2 = ref2[1], y2 = ref2[2];
  dy = -y2 - h2 + 1;
  dy += y1 - 1;
  return move(k2, yindex, 0, dy);
};

move = function(j, k, dx, dy) {
  var i, o, ref1, ref2, results;
  i = 0;
  results = [];
  for (i = o = ref1 = j, ref2 = k; ref1 <= ref2 ? o < ref2 : o > ref2; i = ref1 <= ref2 ? ++o : --o) {
    chartab[i].x += dx;
    results.push(chartab[i].y += dy);
  }
  return results;
};

get_size = function(j, k) {
  var h, i, max_x, max_y, min_x, min_y, o, ref1, ref2, w, y;
  i = 0;
  min_x = chartab[j].x;
  max_x = chartab[j].x;
  min_y = chartab[j].y;
  max_y = chartab[j].y;
  for (i = o = ref1 = j + 1, ref2 = k; ref1 <= ref2 ? o < ref2 : o > ref2; i = ref1 <= ref2 ? ++o : --o) {
    if (chartab[i].x < min_x) {
      min_x = chartab[i].x;
    }
    if (chartab[i].x > max_x) {
      max_x = chartab[i].x;
    }
    if (chartab[i].y < min_y) {
      min_y = chartab[i].y;
    }
    if (chartab[i].y > max_y) {
      max_y = chartab[i].y;
    }
  }
  h = max_y - min_y + 1;
  w = max_x - min_x + 1;
  y = min_y;
  return [h, w, y];
};

displaychar = function(c) {
  return __emit_char(c);
};

__emit_char = function(c) {
  if (yindex === YMAX) {
    return;
  }
  if (chartab[yindex] == null) {
    debugger;
  }
  chartab[yindex].c = c;
  chartab[yindex].x = emit_x;
  chartab[yindex].y = 0;
  yindex++;
  return emit_x++;
};

__emit_str = function(s) {
  var i, o, ref1, results;
  i = 0;
  results = [];
  for (i = o = 0, ref1 = s.length; 0 <= ref1 ? o < ref1 : o > ref1; i = 0 <= ref1 ? ++o : --o) {
    results.push(__emit_char(s[i]));
  }
  return results;
};

emit_number = function(p, emit_sign) {
  var ac, ad, i, o, ref1, ref2, ref3, results, results1;
  i = 0;
  switch (p.k) {
    case NUM:
      s = p.q.a.toString();
      if (s[0] === '-' && emit_sign === 0) {
        s = s.substring(1);
      }
      for (i = o = 0, ref1 = s.length; 0 <= ref1 ? o < ref1 : o > ref1; i = 0 <= ref1 ? ++o : --o) {
        __emit_char(s[i]);
      }
      s = p.q.b.toString();
      if (s === "1") {
        break;
      }
      __emit_char('/');
      results = [];
      for (i = ac = 0, ref2 = s.length; 0 <= ref2 ? ac < ref2 : ac > ref2; i = 0 <= ref2 ? ++ac : --ac) {
        results.push(__emit_char(s[i]));
      }
      return results;
      break;
    case DOUBLE:
      s = p.d.toString();
      if (s[0] === '-' && emit_sign === 0) {
        s = s.substring(1);
      }
      results1 = [];
      for (i = ad = 0, ref3 = s.length; 0 <= ref3 ? ad < ref3 : ad > ref3; i = 0 <= ref3 ? ++ad : --ad) {
        results1.push(__emit_char(s[i]));
      }
      return results1;
  }
};

cmpGlyphs = function(a, b) {
  if (a.y < b.y) {
    return -1;
  }
  if (a.y > b.y) {
    return 1;
  }
  if (a.x < b.x) {
    return -1;
  }
  if (a.x > b.x) {
    return 1;
  }
  return 0;
};

print_it = function() {
  var accumulatedPrint, i, o, ref1, subsetOfStack, x, y;
  i = 0;
  accumulatedPrint = "";
  subsetOfStack = chartab.slice(0, yindex);
  subsetOfStack.sort(cmpGlyphs);
  chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));
  x = 0;
  y = chartab[0].y;
  for (i = o = 0, ref1 = yindex; 0 <= ref1 ? o < ref1 : o > ref1; i = 0 <= ref1 ? ++o : --o) {
    while (chartab[i].y > y) {
      accumulatedPrint = printchar('\n', accumulatedPrint);
      x = 0;
      y++;
    }
    while (chartab[i].x > x) {
      accumulatedPrint = printchar_nowrap(' ', accumulatedPrint);
      x++;
    }
    accumulatedPrint = printchar_nowrap(chartab[i].c, accumulatedPrint);
    x++;
  }
  return console.log(accumulatedPrint);
};

buffer = "";

getdisplaystr = function() {
  yindex = 0;
  level = 0;
  emit_x = 0;
  emit_expr(pop());
  fill_buf();
  return buffer;
};

fill_buf = function() {
  var i, o, ref1, sIndex, subsetOfStack, x, y;
  s = buffer;
  sIndex = 0;
  i = 0;
  subsetOfStack = chartab.slice(0, yindex);
  subsetOfStack.sort(cmpGlyphs);
  chartab = [].concat(subsetOfStack).concat(chartab.slice(yindex));
  x = 0;
  y = chartab[0].y;
  for (i = o = 0, ref1 = yindex; 0 <= ref1 ? o < ref1 : o > ref1; i = 0 <= ref1 ? ++o : --o) {
    while (chartab[i].y > y) {
      s[sIndex++] = '\n';
      x = 0;
      y++;
    }
    while (chartab[i].x > x) {
      s[sIndex++] = ' ';
      x++;
    }
    s[sIndex++] = chartab[i].c;
    x++;
  }
  return s[sIndex++] = '\n';
};

N = 100;

oneElement = (function() {
  function oneElement() {}

  oneElement.prototype.x = 0;

  oneElement.prototype.y = 0;

  oneElement.prototype.h = 0;

  oneElement.prototype.w = 0;

  oneElement.prototype.index = 0;

  oneElement.prototype.count = 0;

  return oneElement;

})();

elem = [];

for (elelmIndex = o = 0; o < 10000; elelmIndex = ++o) {
  elem[elelmIndex] = new oneElement;
}

SPACE_BETWEEN_COLUMNS = 3;

SPACE_BETWEEN_ROWS = 1;

emit_tensor = function(p) {
  var ac, ad, ae, af, col, dx, dy, eh, ew, h, i, n, ncol, nrow, ref1, ref2, ref3, ref4, ref5, row, w, x, y;
  i = 0;
  n = 0;
  nrow = 0;
  ncol = 0;
  x = 0;
  y = 0;
  h = 0;
  w = 0;
  dx = 0;
  dy = 0;
  eh = 0;
  ew = 0;
  row = 0;
  col = 0;
  if (p.tensor.ndim > 2) {
    emit_flat_tensor(p);
    return;
  }
  nrow = p.tensor.dim[0];
  if (p.tensor.ndim === 2) {
    ncol = p.tensor.dim[1];
  } else {
    ncol = 1;
  }
  n = nrow * ncol;
  if (n > N) {
    emit_flat_tensor(p);
    return;
  }
  x = emit_x;
  for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    elem[i].index = yindex;
    elem[i].x = emit_x;
    emit_expr(p.tensor.elem[i]);
    elem[i].count = yindex - elem[i].index;
    ref2 = get_size(elem[i].index, yindex), elem[i].h = ref2[0], elem[i].w = ref2[1], elem[i].y = ref2[2];
  }
  eh = 0;
  ew = 0;
  for (i = ad = 0, ref3 = n; 0 <= ref3 ? ad < ref3 : ad > ref3; i = 0 <= ref3 ? ++ad : --ad) {
    if (elem[i].h > eh) {
      eh = elem[i].h;
    }
    if (elem[i].w > ew) {
      ew = elem[i].w;
    }
  }
  h = nrow * eh + (nrow - 1) * SPACE_BETWEEN_ROWS;
  w = ncol * ew + (ncol - 1) * SPACE_BETWEEN_COLUMNS;
  y = -(h / 2);
  for (row = ae = 0, ref4 = nrow; 0 <= ref4 ? ae < ref4 : ae > ref4; row = 0 <= ref4 ? ++ae : --ae) {
    for (col = af = 0, ref5 = ncol; 0 <= ref5 ? af < ref5 : af > ref5; col = 0 <= ref5 ? ++af : --af) {
      i = row * ncol + col;
      dx = x - elem[i].x;
      dy = y - elem[i].y;
      move(elem[i].index, elem[i].index + elem[i].count, dx, dy);
      dx = 0;
      if (col > 0) {
        dx = col * (ew + SPACE_BETWEEN_COLUMNS);
      }
      dy = 0;
      if (row > 0) {
        dy = row * (eh + SPACE_BETWEEN_ROWS);
      }
      dx += (ew - elem[i].w) / 2;
      dy += (eh - elem[i].h) / 2;
      move(elem[i].index, elem[i].index + elem[i].count, dx, dy);
    }
  }
  return emit_x = x + w;

  /*
  	if 0
  
  		 * left brace
  
  		for (i = 0; i < h; i++) {
  			if (yindex == YMAX)
  				break;
  			chartab[yindex].c = '|';
  			chartab[yindex].x = x - 2;
  			chartab[yindex].y = y + i;
  			yindex++;
  		}
  
  		 * right brace
  
  		emit_x++;
  
  		for (i = 0; i < h; i++) {
  			if (yindex == YMAX)
  				break;
  			chartab[yindex].c = '|';
  			chartab[yindex].x = emit_x;
  			chartab[yindex].y = y + i;
  			yindex++;
  		}
  
  		emit_x++;
  
  	endif
   */
};

emit_flat_tensor = function(p) {
  return emit_tensor_inner(p, 0, 0);
};

emit_tensor_inner = function(p, j, k) {
  var ac, i, ref1;
  i = 0;
  __emit_char('(');
  for (i = ac = 0, ref1 = p.tensor.dim[j]; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    if (j + 1 === p.tensor.ndim) {
      emit_expr(p.tensor.elem[k]);
      k = k + 1;
    } else {
      k = emit_tensor_inner(p, j + 1, k);
    }
    if (i + 1 < p.tensor.dim[j]) {
      __emit_char(',');
    }
  }
  __emit_char(')');
  return k;
};

s = ["format=1", "", "((a,b),(c,d))", "a   b\n", "\n", "c   d", "1/sqrt(-15)", "       i\n", "- -----------\n", "    1/2  1/2\n", "   3    5", "x^(1/a)", " 1/a\n", "x", "x^(a/b)", " a/b\n", "x", "x^(a/2)", " 1/2 a\n", "x", "x^(1/(a+b))", " 1/(a + b)\n", "x"];


/*
void
test_display(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}

#endif
 */

Eval = function() {
  check_esc_flag();
  save();
  p1 = pop();
  if (p1 == null) {
    debugger;
  }
  switch (p1.k) {
    case CONS:
      Eval_cons();
      break;
    case NUM:
      push(p1);
      break;
    case DOUBLE:
      push(p1);
      break;
    case STR:
      push(p1);
      break;
    case TENSOR:
      Eval_tensor();
      break;
    case SYM:
      Eval_sym();
      break;
    default:
      stop("atom?");
  }
  return restore();
};

Eval_sym = function() {
  if (iskeyword(p1)) {
    push(p1);
    push(symbol(LAST));
    list(2);
    Eval();
    return;
  }
  p2 = get_binding(p1);
  push(p2);
  if (p1 !== p2) {
    return Eval();
  }
};

Eval_cons = function() {
  if (!issymbol(car(p1))) {
    stop("cons?");
  }
  switch (symnum(car(p1))) {
    case ABS:
      return Eval_abs();
    case ADD:
      return Eval_add();
    case ADJ:
      return Eval_adj();
    case AND:
      return Eval_and();
    case ARCCOS:
      return Eval_arccos();
    case ARCCOSH:
      return Eval_arccosh();
    case ARCSIN:
      return Eval_arcsin();
    case ARCSINH:
      return Eval_arcsinh();
    case ARCTAN:
      return Eval_arctan();
    case ARCTANH:
      return Eval_arctanh();
    case ARG:
      return Eval_arg();
    case ATOMIZE:
      return Eval_atomize();
    case BESSELJ:
      return Eval_besselj();
    case BESSELY:
      return Eval_bessely();
    case BINDING:
      return Eval_binding();
    case BINOMIAL:
      return Eval_binomial();
    case CEILING:
      return Eval_ceiling();
    case CHECK:
      return Eval_check();
    case CHOOSE:
      return Eval_choose();
    case CIRCEXP:
      return Eval_circexp();
    case CLEAR:
      return Eval_clear();
    case CLOCK:
      return Eval_clock();
    case COEFF:
      return Eval_coeff();
    case COFACTOR:
      return Eval_cofactor();
    case CONDENSE:
      return Eval_condense();
    case CONJ:
      return Eval_conj();
    case CONTRACT:
      return Eval_contract();
    case COS:
      return Eval_cos();
    case COSH:
      return Eval_cosh();
    case DECOMP:
      return Eval_decomp();
    case DEGREE:
      return Eval_degree();
    case DEFINT:
      return Eval_defint();
    case DENOMINATOR:
      return Eval_denominator();
    case DERIVATIVE:
      return Eval_derivative();
    case DET:
      return Eval_det();
    case DIM:
      return Eval_dim();
    case DIRAC:
      return Eval_dirac();
    case DISPLAY:
      return Eval_display();
    case DIVISORS:
      return Eval_divisors();
    case DO:
      return Eval_do();
    case DOT:
      return Eval_inner();
    case DRAW:
      return Eval_draw();
    case DSOLVE:
      return Eval_dsolve();
    case EIGEN:
      return Eval_eigen();
    case EIGENVAL:
      return Eval_eigenval();
    case EIGENVEC:
      return Eval_eigenvec();
    case ERF:
      return Eval_erf();
    case ERFC:
      return Eval_erfc();
    case EVAL:
      return Eval_Eval();
    case EXP:
      return Eval_exp();
    case EXPAND:
      return Eval_expand();
    case EXPCOS:
      return Eval_expcos();
    case EXPSIN:
      return Eval_expsin();
    case FACTOR:
      return Eval_factor();
    case FACTORIAL:
      return Eval_factorial();
    case FACTORPOLY:
      return Eval_factorpoly();
    case FILTER:
      return Eval_filter();
    case FLOATF:
      return Eval_float();
    case FLOOR:
      return Eval_floor();
    case FOR:
      return Eval_for();
    case GAMMA:
      return Eval_gamma();
    case GCD:
      return Eval_gcd();
    case HERMITE:
      return Eval_hermite();
    case HILBERT:
      return Eval_hilbert();
    case IMAG:
      return Eval_imag();
    case INDEX:
      return Eval_index();
    case INNER:
      return Eval_inner();
    case INTEGRAL:
      return Eval_integral();
    case INV:
      return Eval_inv();
    case INVG:
      return Eval_invg();
    case ISINTEGER:
      return Eval_isinteger();
    case ISPRIME:
      return Eval_isprime();
    case LAGUERRE:
      return Eval_laguerre();
    case LCM:
      return Eval_lcm();
    case LEADING:
      return Eval_leading();
    case LEGENDRE:
      return Eval_legendre();
    case LOG:
      return Eval_log();
    case MAG:
      return Eval_mag();
    case MOD:
      return Eval_mod();
    case MULTIPLY:
      return Eval_multiply();
    case NOT:
      return Eval_not();
    case NROOTS:
      return Eval_nroots();
    case NUMBER:
      return Eval_number();
    case NUMERATOR:
      return Eval_numerator();
    case OPERATOR:
      return Eval_operator();
    case OR:
      return Eval_or();
    case OUTER:
      return Eval_outer();
    case POLAR:
      return Eval_polar();
    case POWER:
      return Eval_power();
    case PRIME:
      return Eval_prime();
    case PRINT:
      return Eval_display();
    case PRODUCT:
      return Eval_product();
    case QUOTE:
      return Eval_quote();
    case QUOTIENT:
      return Eval_quotient();
    case RANK:
      return Eval_rank();
    case RATIONALIZE:
      return Eval_rationalize();
    case REAL:
      return Eval_real();
    case YYRECT:
      return Eval_rect();
    case ROOTS:
      return Eval_roots();
    case SETQ:
      return Eval_setq();
    case SGN:
      return Eval_sgn();
    case SIMPLIFY:
      return Eval_simplify();
    case SIN:
      return Eval_sin();
    case SINH:
      return Eval_sinh();
    case SQRT:
      return Eval_sqrt();
    case STOP:
      return Eval_stop();
    case SUBST:
      return Eval_subst();
    case SUM:
      return Eval_sum();
    case TAN:
      return Eval_tan();
    case TANH:
      return Eval_tanh();
    case TAYLOR:
      return Eval_taylor();
    case TEST:
      return Eval_test();
    case TESTEQ:
      return Eval_testeq();
    case TESTGE:
      return Eval_testge();
    case TESTGT:
      return Eval_testgt();
    case TESTLE:
      return Eval_testle();
    case TESTLT:
      return Eval_testlt();
    case TRANSPOSE:
      return Eval_transpose();
    case UNIT:
      return Eval_unit();
    case ZERO:
      return Eval_zero();
    default:
      return Eval_user_function();
  }
};

Eval_binding = function() {
  return push(get_binding(cadr(p1)));
};

Eval_check = function() {
  push(cadr(p1));
  Eval_predicate();
  p1 = pop();
  if (iszero(p1)) {
    stop("check(arg): arg is zero");
  }
  return push(symbol(NIL));
};

Eval_det = function() {
  push(cadr(p1));
  Eval();
  return det();
};

Eval_dim = function() {
  var n;
  push(cadr(p1));
  Eval();
  p2 = pop();
  if (iscons(cddr(p1))) {
    push(caddr(p1));
    Eval();
    n = pop_integer();
  } else {
    n = 1;
  }
  if (!istensor(p2)) {
    return push_integer(1);
  } else if (n < 1 || n > p2.tensor.ndim) {
    return push(p1);
  } else {
    return push_integer(p2.tensor.dim[n - 1]);
  }
};

Eval_divisors = function() {
  push(cadr(p1));
  Eval();
  return divisors();
};

Eval_do = function() {
  var results;
  push(car(p1));
  p1 = cdr(p1);
  results = [];
  while (iscons(p1)) {
    pop();
    push(car(p1));
    Eval();
    results.push(p1 = cdr(p1));
  }
  return results;
};

Eval_dsolve = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  push(cadddr(p1));
  Eval();
  return dsolve();
};

Eval_Eval = function() {
  push(cadr(p1));
  Eval();
  p1 = cddr(p1);
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    push(cadr(p1));
    Eval();
    subst();
    p1 = cddr(p1);
  }
  return Eval();
};

Eval_exp = function() {
  push(cadr(p1));
  Eval();
  return exponential();
};

Eval_factorial = function() {
  push(cadr(p1));
  Eval();
  return factorial();
};

Eval_factorpoly = function() {
  var results;
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  factorpoly();
  p1 = cdr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    factorpoly();
    results.push(p1 = cdr(p1));
  }
  return results;
};

Eval_hermite = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  return hermite();
};

Eval_hilbert = function() {
  push(cadr(p1));
  Eval();
  return hilbert();
};

Eval_index = function() {
  var h;
  h = tos;
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    p1 = cdr(p1);
  }
  return index_function(tos - h);
};

Eval_inv = function() {
  push(cadr(p1));
  Eval();
  return inv();
};

Eval_invg = function() {
  push(cadr(p1));
  Eval();
  return invg();
};

Eval_isinteger = function() {
  var n;
  push(cadr(p1));
  Eval();
  p1 = pop();
  if (isrational(p1)) {
    if (isinteger(p1)) {
      push(one);
    } else {
      push(zero);
    }
    return;
  }
  if (isdouble(p1)) {
    n = Math.floor(p1.d);
    if (n === p1.d) {
      push(one);
    } else {
      push(zero);
    }
    return;
  }
  push_symbol(ISINTEGER);
  push(p1);
  return list(2);
};

Eval_multiply = function() {
  var results;
  push(cadr(p1));
  Eval();
  p1 = cddr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    multiply();
    results.push(p1 = cdr(p1));
  }
  return results;
};

Eval_number = function() {
  push(cadr(p1));
  Eval();
  p1 = pop();
  if (p1.k === NUM || p1.k === DOUBLE) {
    return push_integer(1);
  } else {
    return push_integer(0);
  }
};

Eval_operator = function() {
  var h;
  h = tos;
  push_symbol(OPERATOR);
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    p1 = cdr(p1);
  }
  return list(tos - h);
};

Eval_print = function() {
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    if (equaln(get_binding(symbol(TTY)), 1)) {
      printline(pop());
    } else {
      display(pop());
    }
    p1 = cdr(p1);
  }
  return push(symbol(NIL));
};

Eval_quote = function() {
  return push(cadr(p1));
};

Eval_rank = function() {
  push(cadr(p1));
  Eval();
  p1 = pop();
  if (istensor(p1)) {
    return push_integer(p1.tensor.ndim);
  } else {
    return push(zero);
  }
};

setq_indexed = function() {
  var h;
  p4 = cadadr(p1);
  if (!issymbol(p4)) {
    stop("indexed assignment: error in symbol");
  }
  h = tos;
  push(caddr(p1));
  Eval();
  p2 = cdadr(p1);
  while (iscons(p2)) {
    push(car(p2));
    Eval();
    p2 = cdr(p2);
  }
  set_component(tos - h);
  p3 = pop();
  set_binding(p4, p3);
  return push(symbol(NIL));
};

Eval_setq = function() {
  if (caadr(p1) === symbol(INDEX)) {
    setq_indexed();
    return;
  }
  if (iscons(cadr(p1))) {
    define_user_function();
    return;
  }
  if (!issymbol(cadr(p1))) {
    stop("symbol assignment: error in symbol");
  }
  push(caddr(p1));
  Eval();
  p2 = pop();
  set_binding(cadr(p1), p2);
  return push(symbol(NIL));
};

Eval_sqrt = function() {
  push(cadr(p1));
  Eval();
  push_rational(1, 2);
  return power();
};

Eval_stop = function() {
  return stop("user stop");
};

Eval_subst = function() {
  push(cadddr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  push(cadr(p1));
  Eval();
  subst();
  return Eval();
};

Eval_unit = function() {
  var ac, i, n, ref1;
  i = 0;
  n = 0;
  push(cadr(p1));
  Eval();
  n = pop_integer();
  if (n < 2) {
    push(p1);
    return;
  }
  p1 = alloc_tensor(n * n);
  p1.tensor.ndim = 2;
  p1.tensor.dim[0] = n;
  p1.tensor.dim[1] = n;
  for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    p1.tensor.elem[n * i + i] = one;
  }
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  return push(p1);
};

Eval_noexpand = function() {
  var x;
  x = expanding;
  expanding = 0;
  Eval();
  return expanding = x;
};

Eval_predicate = function() {
  save();
  p1 = pop();
  if (car(p1) === symbol(SETQ)) {
    Eval_testeq();
  } else {
    push(p1);
    Eval();
  }
  return restore();
};

Eval_factor = function() {
  var results;
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  p2 = pop();
  if (p2 === symbol(NIL)) {
    guess();
  } else {
    push(p2);
  }
  factor();
  p1 = cdddr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    factor_again();
    results.push(p1 = cdr(p1));
  }
  return results;
};

factor_again = function() {
  var h, n;
  save();
  p2 = pop();
  p1 = pop();
  h = tos;
  if (car(p1) === symbol(MULTIPLY)) {
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      factor_term();
      p1 = cdr(p1);
    }
  } else {
    push(p1);
    push(p2);
    factor_term();
  }
  n = tos - h;
  if (n > 1) {
    multiply_all_noexpand(n);
  }
  return restore();
};

factor_term = function() {
  save();
  factorpoly();
  p1 = pop();
  if (car(p1) === symbol(MULTIPLY)) {
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      p1 = cdr(p1);
    }
  } else {
    push(p1);
  }
  return restore();
};

factor = function() {
  save();
  p2 = pop();
  p1 = pop();
  if (isinteger(p1)) {
    push(p1);
    factor_number();
  } else {
    push(p1);
    push(p2);
    factorpoly();
  }
  return restore();
};

factor_small_number = function() {
  debugger;
  var ac, d, expo, i, n, ref1;
  i = 0;
  save();
  n = pop_integer();
  if (n === 0x80000000) {
    stop("number too big to factor");
  }
  if (n < 0) {
    n = -n;
  }
  for (i = ac = 0, ref1 = MAXPRIMETAB; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    d = primetab[i];
    if (d > n / d) {
      break;
    }
    expo = 0;
    while (n % d === 0) {
      n /= d;
      expo++;
    }
    if (expo) {
      push_integer(d);
      push_integer(expo);
    }
  }
  if (n > 1) {
    push_integer(n);
    push_integer(1);
  }
  return restore();
};

s = ["factor(0)", "0", "factor(1)", "1", "factor(2)", "2", "factor(3)", "3", "factor(4)", "2^2", "factor(5)", "5", "factor(6)", "2*3", "factor(7)", "7", "factor(8)", "2^3", "factor(9)", "3^2", "factor(10)", "2*5", "factor(100!)", "2^97*3^48*5^24*7^16*11^9*13^7*17^5*19^5*23^4*29^3*31^3*37^2*41^2*43^2*47^2*53*59*61*67*71*73*79*83*89*97", "factor(2*(2^30-35))", "2*1073741789", "a=104729", "", "factor(2*(a^2+6))", "2*10968163447", "factor((a^2+6)^2)", "10968163447*10968163447", "factor((a^2+6)*(a^2+60))", "10968163501*10968163447", "f=(x+1)(x+2)(y+3)(y+4)", "", "factor(f,x,y)", "(x+1)*(x+2)*(y+3)*(y+4)", "factor(f,y,x)", "(x+1)*(x+2)*(y+3)*(y+4)", "f=(x+1)(x+1)(y+2)(y+2)", "", "factor(f,x,y)", "(x+1)^2*(y+2)^2", "factor(f,y,x)", "(x+1)^2*(y+2)^2"];


/*
void
test_factor_number(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}

#endif
 */

factorial = function() {
  var n;
  n = 0;
  save();
  p1 = pop();
  push(p1);
  n = pop_integer();
  if (n < 0 || n === 0x80000000) {
    push_symbol(FACTORIAL);
    push(p1);
    list(2);
    restore();
    return;
  }
  bignum_factorial(n);
  return restore();
};

simplifyfactorials = function() {
  var x;
  x = 0;
  save();
  x = expanding;
  expanding = 0;
  p1 = pop();
  if (car(p1) === symbol(ADD)) {
    push(zero);
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      simplifyfactorials();
      add();
      p1 = cdr(p1);
    }
    expanding = x;
    restore();
    return;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    sfac_product();
    expanding = x;
    restore();
    return;
  }
  push(p1);
  expanding = x;
  return restore();
};

sfac_product = function() {
  var ac, ad, ae, i, j, n, ref1, ref2, ref3, ref4;
  i = 0;
  j = 0;
  n = 0;
  s = tos;
  p1 = cdr(p1);
  n = 0;
  while (iscons(p1)) {
    push(car(p1));
    p1 = cdr(p1);
    n++;
  }
  for (i = ac = 0, ref1 = n - 1; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    if (stack[s + i] === symbol(NIL)) {
      continue;
    }
    for (j = ad = ref2 = i + 1, ref3 = n; ref2 <= ref3 ? ad < ref3 : ad > ref3; j = ref2 <= ref3 ? ++ad : --ad) {
      if (stack[s + j] === symbol(NIL)) {
        continue;
      }
      sfac_product_f(s, i, j);
    }
  }
  push(one);
  for (i = ae = 0, ref4 = n; 0 <= ref4 ? ae < ref4 : ae > ref4; i = 0 <= ref4 ? ++ae : --ae) {
    if (stack[s + i] === symbol(NIL)) {
      continue;
    }
    push(stack[s + i]);
    multiply();
  }
  p1 = pop();
  tos -= n;
  return push(p1);
};

sfac_product_f = function(s, a, b) {
  var ac, i, n, ref1;
  i = 0;
  n = 0;
  p1 = stack[s + a];
  p2 = stack[s + b];
  if (ispower(p1)) {
    p3 = caddr(p1);
    p1 = cadr(p1);
  } else {
    p3 = one;
  }
  if (ispower(p2)) {
    p4 = caddr(p2);
    p2 = cadr(p2);
  } else {
    p4 = one;
  }
  if (isfactorial(p1) && isfactorial(p2)) {
    push(p3);
    push(p4);
    add();
    yyexpand();
    n = pop_integer();
    if (n !== 0) {
      return;
    }
    push(cadr(p1));
    push(cadr(p2));
    subtract();
    yyexpand();
    n = pop_integer();
    if (n === 0 || n === 0x80000000) {
      return;
    }
    if (n < 0) {
      n = -n;
      p5 = p1;
      p1 = p2;
      p2 = p5;
      p5 = p3;
      p3 = p4;
      p4 = p5;
    }
    push(one);
    for (i = ac = 1, ref1 = n; 1 <= ref1 ? ac <= ref1 : ac >= ref1; i = 1 <= ref1 ? ++ac : --ac) {
      push(cadr(p2));
      push_integer(i);
      add();
      push(p3);
      power();
      multiply();
    }
    stack[s + a] = pop();
    return stack[s + b] = symbol(NIL);
  }
};

Find = function(p, q) {
  var ac, i, ref1;
  i = 0;
  if (equal(p, q)) {
    return 1;
  }
  if (istensor(p)) {
    for (i = ac = 0, ref1 = p.tensor.nelem; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      if (Find(p.tensor.elem[i], q)) {
        return 1;
      }
    }
    return 0;
  }
  while (iscons(p)) {
    if (Find(car(p), q)) {
      return 1;
    }
    p = cdr(p);
  }
  return 0;
};

guess = function() {
  var p;
  p = pop();
  push(p);
  if (Find(p, symbol(SYMBOL_X))) {
    return push_symbol(SYMBOL_X);
  } else if (Find(p, symbol(SYMBOL_Y))) {
    return push_symbol(SYMBOL_Y);
  } else if (Find(p, symbol(SYMBOL_Z))) {
    return push_symbol(SYMBOL_Z);
  } else if (Find(p, symbol(SYMBOL_T))) {
    return push_symbol(SYMBOL_T);
  } else if (Find(p, symbol(SYMBOL_S))) {
    return push_symbol(SYMBOL_S);
  } else {
    return push_symbol(SYMBOL_X);
  }
};

index_function = function(n) {
  var ac, ad, ae, af, ag, i, k, m, ndim, nelem, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, t;
  i = 0;
  k = 0;
  m = 0;
  ndim = 0;
  nelem = 0;
  t = 0;
  save();
  s = tos - n;
  p1 = stack[s];
  if (!istensor(p1)) {
    tos -= n;
    push(p1);
    restore();
    return;
  }
  ndim = p1.tensor.ndim;
  m = n - 1;
  if (m > ndim) {
    stop("too many indices for tensor");
  }
  k = 0;
  for (i = ac = 0, ref1 = m; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    push(stack[s + i + 1]);
    t = pop_integer();
    if (t < 1 || t > p1.tensor.dim[i]) {
      stop("index out of range");
    }
    k = k * p1.tensor.dim[i] + t - 1;
  }
  if (ndim === m) {
    tos -= n;
    push(p1.tensor.elem[k]);
    restore();
    return;
  }
  for (i = ad = ref2 = m, ref3 = ndim; ref2 <= ref3 ? ad < ref3 : ad > ref3; i = ref2 <= ref3 ? ++ad : --ad) {
    k = k * p1.tensor.dim[i] + 0;
  }
  nelem = 1;
  for (i = ae = ref4 = m, ref5 = ndim; ref4 <= ref5 ? ae < ref5 : ae > ref5; i = ref4 <= ref5 ? ++ae : --ae) {
    nelem *= p1.tensor.dim[i];
  }
  p2 = alloc_tensor(nelem);
  p2.tensor.ndim = ndim - m;
  for (i = af = ref6 = m, ref7 = ndim; ref6 <= ref7 ? af < ref7 : af > ref7; i = ref6 <= ref7 ? ++af : --af) {
    p2.tensor.dim[i - m] = p1.tensor.dim[i];
  }
  for (i = ag = 0, ref8 = nelem; 0 <= ref8 ? ag < ref8 : ag > ref8; i = 0 <= ref8 ? ++ag : --ag) {
    p2.tensor.elem[i] = p1.tensor.elem[k + i];
  }
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  if (p2.tensor.nelem !== p2.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  tos -= n;
  push(p2);
  return restore();
};

set_component = function(n) {
  var ac, ad, ae, af, ag, ah, i, k, m, ndim, ref1, ref2, ref3, ref4, ref5, ref6, ref7, t;
  i = 0;
  k = 0;
  m = 0;
  ndim = 0;
  t = 0;
  save();
  if (n < 3) {
    stop("error in indexed assign");
  }
  s = tos - n;
  p2 = stack[s];
  p1 = stack[s + 1];
  if (!istensor(p1)) {
    stop("error in indexed assign");
  }
  ndim = p1.tensor.ndim;
  m = n - 2;
  if (m > ndim) {
    stop("error in indexed assign");
  }
  k = 0;
  for (i = ac = 0, ref1 = m; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    push(stack[s + i + 2]);
    t = pop_integer();
    if (t < 1 || t > p1.tensor.dim[i]) {
      stop("error in indexed assign\n");
    }
    k = k * p1.tensor.dim[i] + t - 1;
  }
  for (i = ad = ref2 = m, ref3 = ndim; ref2 <= ref3 ? ad < ref3 : ad > ref3; i = ref2 <= ref3 ? ++ad : --ad) {
    k = k * p1.tensor.dim[i] + 0;
  }
  p3 = alloc_tensor(p1.tensor.nelem);
  p3.tensor.ndim = p1.tensor.ndim;
  for (i = ae = 0, ref4 = p1.tensor.ndim; 0 <= ref4 ? ae < ref4 : ae > ref4; i = 0 <= ref4 ? ++ae : --ae) {
    p3.tensor.dim[i] = p1.tensor.dim[i];
  }
  for (i = af = 0, ref5 = p1.tensor.nelem; 0 <= ref5 ? af < ref5 : af > ref5; i = 0 <= ref5 ? ++af : --af) {
    p3.tensor.elem[i] = p1.tensor.elem[i];
  }
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  if (p3.tensor.nelem !== p3.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  p1 = p3;
  if (ndim === m) {
    if (istensor(p2)) {
      stop("error in indexed assign");
    }
    p1.tensor.elem[k] = p2;
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    tos -= n;
    push(p1);
    restore();
    return;
  }
  if (!istensor(p2)) {
    stop("error in indexed assign");
  }
  if (ndim - m !== p2.tensor.ndim) {
    stop("error in indexed assign");
  }
  for (i = ag = 0, ref6 = p2.tensor.ndim; 0 <= ref6 ? ag < ref6 : ag > ref6; i = 0 <= ref6 ? ++ag : --ag) {
    if (p1.tensor.dim[m + i] !== p2.tensor.dim[i]) {
      stop("error in indexed assign");
    }
  }
  for (i = ah = 0, ref7 = p2.tensor.nelem; 0 <= ref7 ? ah < ref7 : ah > ref7; i = 0 <= ref7 ? ++ah : --ah) {
    p1.tensor.elem[k + i] = p2.tensor.elem[i];
  }
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  if (p2.tensor.nelem !== p2.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  tos -= n;
  push(p1);
  return restore();
};

s = ["A=((A11,A12),(A21,A22))", "", "A[1,1]", "A11", "A[1,2]", "A12", "A[2,1]", "A21", "A[2,2]", "A22", "A[1]", "(A11,A12)", "A[2]", "(A21,A22)", "A[1]=(B11,B12)", "", "A", "((B11,B12),(A21,A22))", "A[2]=(B21,B22)", "", "A", "((B11,B12),(B21,B22))", "A=((0,0),(0,0))", "", "A[1,1]", "0", "1[2]", "1"];


/*
void
test_index(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}

#endif
 */

init = function() {
  var ac, ad, i, ref1, ref2;
  i = 0;
  flag = 0;
  tos = 0;
  esc_flag = 0;
  draw_flag = 0;
  frame = TOS;
  if (flag) {
    return;
  }
  flag = 1;
  for (i = ac = 0, ref1 = NSYM; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    symtab[i] = new U();
  }
  for (i = ad = 0, ref2 = NSYM; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
    symtab[i].k = SYM;
    binding[i] = symtab[i];
    arglist[i] = symbol(NIL);
  }
  p0 = symbol(NIL);
  p1 = symbol(NIL);
  p2 = symbol(NIL);
  p3 = symbol(NIL);
  p4 = symbol(NIL);
  p5 = symbol(NIL);
  p6 = symbol(NIL);
  p7 = symbol(NIL);
  p8 = symbol(NIL);
  p9 = symbol(NIL);
  std_symbol("abs", ABS);
  std_symbol("add", ADD);
  std_symbol("adj", ADJ);
  std_symbol("and", AND);
  std_symbol("arccos", ARCCOS);
  std_symbol("arccosh", ARCCOSH);
  std_symbol("arcsin", ARCSIN);
  std_symbol("arcsinh", ARCSINH);
  std_symbol("arctan", ARCTAN);
  std_symbol("arctanh", ARCTANH);
  std_symbol("arg", ARG);
  std_symbol("atomize", ATOMIZE);
  std_symbol("besselj", BESSELJ);
  std_symbol("bessely", BESSELY);
  std_symbol("binding", BINDING);
  std_symbol("binomial", BINOMIAL);
  std_symbol("ceiling", CEILING);
  std_symbol("check", CHECK);
  std_symbol("choose", CHOOSE);
  std_symbol("circexp", CIRCEXP);
  std_symbol("clear", CLEAR);
  std_symbol("clock", CLOCK);
  std_symbol("coeff", COEFF);
  std_symbol("cofactor", COFACTOR);
  std_symbol("condense", CONDENSE);
  std_symbol("conj", CONJ);
  std_symbol("contract", CONTRACT);
  std_symbol("cos", COS);
  std_symbol("cosh", COSH);
  std_symbol("decomp", DECOMP);
  std_symbol("defint", DEFINT);
  std_symbol("deg", DEGREE);
  std_symbol("denominator", DENOMINATOR);
  std_symbol("det", DET);
  std_symbol("derivative", DERIVATIVE);
  std_symbol("dim", DIM);
  std_symbol("dirac", DIRAC);
  std_symbol("display", DISPLAY);
  std_symbol("divisors", DIVISORS);
  std_symbol("do", DO);
  std_symbol("dot", DOT);
  std_symbol("draw", DRAW);
  std_symbol("dsolve", DSOLVE);
  std_symbol("erf", ERF);
  std_symbol("erfc", ERFC);
  std_symbol("eigen", EIGEN);
  std_symbol("eigenval", EIGENVAL);
  std_symbol("eigenvec", EIGENVEC);
  std_symbol("eval", EVAL);
  std_symbol("exp", EXP);
  std_symbol("expand", EXPAND);
  std_symbol("expcos", EXPCOS);
  std_symbol("expsin", EXPSIN);
  std_symbol("factor", FACTOR);
  std_symbol("factorial", FACTORIAL);
  std_symbol("factorpoly", FACTORPOLY);
  std_symbol("filter", FILTER);
  std_symbol("float", FLOATF);
  std_symbol("floor", FLOOR);
  std_symbol("for", FOR);
  std_symbol("Gamma", GAMMA);
  std_symbol("gcd", GCD);
  std_symbol("hermite", HERMITE);
  std_symbol("hilbert", HILBERT);
  std_symbol("imag", IMAG);
  std_symbol("component", INDEX);
  std_symbol("inner", INNER);
  std_symbol("integral", INTEGRAL);
  std_symbol("inv", INV);
  std_symbol("invg", INVG);
  std_symbol("isinteger", ISINTEGER);
  std_symbol("isprime", ISPRIME);
  std_symbol("laguerre", LAGUERRE);
  std_symbol("lcm", LCM);
  std_symbol("leading", LEADING);
  std_symbol("legendre", LEGENDRE);
  std_symbol("log", LOG);
  std_symbol("mag", MAG);
  std_symbol("mod", MOD);
  std_symbol("multiply", MULTIPLY);
  std_symbol("not", NOT);
  std_symbol("nroots", NROOTS);
  std_symbol("number", NUMBER);
  std_symbol("numerator", NUMERATOR);
  std_symbol("operator", OPERATOR);
  std_symbol("or", OR);
  std_symbol("outer", OUTER);
  std_symbol("polar", POLAR);
  std_symbol("power", POWER);
  std_symbol("prime", PRIME);
  std_symbol("print", PRINT);
  std_symbol("product", PRODUCT);
  std_symbol("quote", QUOTE);
  std_symbol("quotient", QUOTIENT);
  std_symbol("rank", RANK);
  std_symbol("rationalize", RATIONALIZE);
  std_symbol("real", REAL);
  std_symbol("rect", YYRECT);
  std_symbol("roots", ROOTS);
  std_symbol("equals", SETQ);
  std_symbol("sgn", SGN);
  std_symbol("simplify", SIMPLIFY);
  std_symbol("sin", SIN);
  std_symbol("sinh", SINH);
  std_symbol("sqrt", SQRT);
  std_symbol("stop", STOP);
  std_symbol("subst", SUBST);
  std_symbol("sum", SUM);
  std_symbol("tan", TAN);
  std_symbol("tanh", TANH);
  std_symbol("taylor", TAYLOR);
  std_symbol("test", TEST);
  std_symbol("testeq", TESTEQ);
  std_symbol("testge", TESTGE);
  std_symbol("testgt", TESTGT);
  std_symbol("testle", TESTLE);
  std_symbol("testlt", TESTLT);
  std_symbol("transpose", TRANSPOSE);
  std_symbol("unit", UNIT);
  std_symbol("zero", ZERO);
  std_symbol("nil", NIL);
  std_symbol("autoexpand", AUTOEXPAND);
  std_symbol("bake", BAKE);
  std_symbol("last", LAST);
  std_symbol("trace", TRACE);
  std_symbol("tty", TTY);
  std_symbol("~", YYE);
  std_symbol("$DRAWX", DRAWX);
  std_symbol("$METAA", METAA);
  std_symbol("$METAB", METAB);
  std_symbol("$METAX", METAX);
  std_symbol("$SECRETX", SECRETX);
  std_symbol("pi", PI);
  std_symbol("a", SYMBOL_A);
  std_symbol("b", SYMBOL_B);
  std_symbol("c", SYMBOL_C);
  std_symbol("d", SYMBOL_D);
  std_symbol("i", SYMBOL_I);
  std_symbol("j", SYMBOL_J);
  std_symbol("n", SYMBOL_N);
  std_symbol("r", SYMBOL_R);
  std_symbol("s", SYMBOL_S);
  std_symbol("t", SYMBOL_T);
  std_symbol("x", SYMBOL_X);
  std_symbol("y", SYMBOL_Y);
  std_symbol("z", SYMBOL_Z);
  std_symbol("$C1", C1);
  std_symbol("$C2", C2);
  std_symbol("$C3", C3);
  std_symbol("$C4", C4);
  std_symbol("$C5", C5);
  std_symbol("$C6", C6);
  push_integer(0);
  zero = pop();
  push_integer(1);
  one = pop();
  push_symbol(POWER);
  print1(stack[tos - 1]);
  push_integer(-1);
  print1(stack[tos - 1]);
  push_rational(1, 2);
  print1(stack[tos - 1]);
  list(3);
  print1(stack[tos - 1]);
  imaginaryunit = pop();
  return defn();
};

defn_str = ["e=exp(1)", "i=sqrt(-1)", "autoexpand=1", "trange=(-pi,pi)", "xrange=(-10,10)", "yrange=(-10,10)", "last=0", "trace=0", "tty=0", "cross(u,v)=(u[2]*v[3]-u[3]*v[2],u[3]*v[1]-u[1]*v[3],u[1]*v[2]-u[2]*v[1])", "curl(v)=(d(v[3],y)-d(v[2],z),d(v[1],z)-d(v[3],x),d(v[2],x)-d(v[1],y))", "div(v)=d(v[1],x)+d(v[2],y)+d(v[3],z)", "ln(x)=log(x)"];

defn = function() {
  var ac, definitionOfInterest, i, n, ref1, results;
  i = 0;
  n = defn_str.length;
  results = [];
  for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    definitionOfInterest = defn_str[i];
    scan(definitionOfInterest);
    console.log("... evaling " + definitionOfInterest);
    console.log("top of stack:");
    print1(stack[tos - 1]);
    Eval();
    results.push(pop());
  }
  return results;
};

Eval_inner = function() {
  var results;
  p1 = cdr(p1);
  push(car(p1));
  Eval();
  p1 = cdr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    Eval();
    inner();
    results.push(p1 = cdr(p1));
  }
  return results;
};

inner = function() {
  save();
  p2 = pop();
  p1 = pop();
  if (istensor(p1) && istensor(p2)) {
    inner_f();
  } else {
    push(p1);
    push(p2);
    if (istensor(p1)) {
      tensor_times_scalar();
    } else if (istensor(p2)) {
      scalar_times_tensor();
    } else {
      multiply();
    }
  }
  return restore();
};

inner_f = function() {
  var a, ac, ad, ae, af, ag, ah, ai, ak, b, bk, c, i, j, k, n, ndim, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
  i = 0;
  n = p1.tensor.dim[p1.tensor.ndim - 1];
  if (n !== p2.tensor.dim[0]) {
    stop("inner: tensor dimension check");
  }
  ndim = p1.tensor.ndim + p2.tensor.ndim - 2;
  if (ndim > MAXDIM) {
    stop("inner: rank of result exceeds maximum");
  }
  a = p1.tensor.elem;
  b = p2.tensor.elem;
  ak = 1;
  for (i = ac = 0, ref1 = p1.tensor.ndim - 1; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    ak *= p1.tensor.dim[i];
  }
  bk = 1;
  for (i = ad = 1, ref2 = p2.tensor.ndim; 1 <= ref2 ? ad < ref2 : ad > ref2; i = 1 <= ref2 ? ++ad : --ad) {
    bk *= p2.tensor.dim[i];
  }
  p3 = alloc_tensor(ak * bk);
  c = p3.tensor.elem;
  for (i = ae = 0, ref3 = ak; 0 <= ref3 ? ae < ref3 : ae > ref3; i = 0 <= ref3 ? ++ae : --ae) {
    for (j = af = 0, ref4 = n; 0 <= ref4 ? af < ref4 : af > ref4; j = 0 <= ref4 ? ++af : --af) {
      if (iszero(a[i * n + j])) {
        continue;
      }
      for (k = ag = 0, ref5 = bk; 0 <= ref5 ? ag < ref5 : ag > ref5; k = 0 <= ref5 ? ++ag : --ag) {
        push(a[i * n + j]);
        push(b[j * bk + k]);
        multiply();
        push(c[i * bk + k]);
        add();
        c[i * bk + k] = pop();
      }
    }
  }
  if (ndim === 0) {
    return push(p3.tensor.elem[0]);
  } else {
    p3.tensor.ndim = ndim;
    j = 0;
    for (i = ah = 0, ref6 = p1.tensor.ndim - 1; 0 <= ref6 ? ah < ref6 : ah > ref6; i = 0 <= ref6 ? ++ah : --ah) {
      p3.tensor.dim[i] = p1.tensor.dim[i];
      j = i;
    }
    for (i = ai = 0, ref7 = p2.tensor.ndim - 1; 0 <= ref7 ? ai < ref7 : ai > ref7; i = 0 <= ref7 ? ++ai : --ai) {
      p3.tensor.dim[j + i] = p2.tensor.dim[i + 1];
    }
    return push(p3);
  }
};

s = ["inner(a,b)", "a*b", "inner(a,(b1,b2))", "(a*b1,a*b2)", "inner((a1,a2),b)", "(a1*b,a2*b)", "inner(((a11,a12),(a21,a22)),(x1,x2))", "(a11*x1+a12*x2,a21*x1+a22*x2)", "inner((1,2),(3,4))", "11", "inner(inner((1,2),((3,4),(5,6))),(7,8))", "219", "inner((1,2),inner(((3,4),(5,6)),(7,8)))", "219", "inner((1,2),((3,4),(5,6)),(7,8))", "219"];


/*
void
test_inner(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}

#endif
 */

iszero = function(p) {
  var ac, i, ref1;
  i = 0;
  switch (p.k) {
    case NUM:
      if (MZERO(p.q.a)) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d === 0.0) {
        return 1;
      }
      break;
    case TENSOR:
      for (i = ac = 0, ref1 = p.tensor.nelem; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
        if (!iszero(p.tensor.elem[i])) {
          return 0;
        }
      }
      return 1;
  }
  return 0;
};

isnegativenumber = function(p) {
  switch (p.k) {
    case NUM:
      if (MSIGN(p.q.a) === -1) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d < 0.0) {
        return 1;
      }
  }
  return 0;
};

isplusone = function(p) {
  switch (p.k) {
    case NUM:
      if (MEQUAL(p.q.a, 1) && MEQUAL(p.q.b, 1)) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d === 1.0) {
        return 1;
      }
  }
  return 0;
};

isminusone = function(p) {
  switch (p.k) {
    case NUM:
      if (MEQUAL(p.q.a, -1) && MEQUAL(p.q.b, 1)) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d === -1.0) {
        return 1;
      }
  }
  return 0;
};

isinteger = function(p) {
  if (p.k === NUM && MEQUAL(p.q.b, 1)) {
    return 1;
  } else {
    return 0;
  }
};

isnonnegativeinteger = function(p) {
  if (isrational(p) && MEQUAL(p.q.b, 1) && MSIGN(p.q.a) === 1) {
    return 1;
  } else {
    return 0;
  }
};

isposint = function(p) {
  if (isinteger(p) && MSIGN(p.q.a) === 1) {
    return 1;
  } else {
    return 0;
  }
};

ispoly = function(p, x) {
  if (Find(p, x)) {
    return ispoly_expr(p, x);
  } else {
    return 0;
  }
};

ispoly_expr = function(p, x) {
  if (car(p) === symbol(ADD)) {
    p = cdr(p);
    while (iscons(p)) {
      if (!ispoly_term(car(p), x)) {
        return 0;
      }
      p = cdr(p);
    }
    return 1;
  } else {
    return ispoly_term(p, x);
  }
};

ispoly_term = function(p, x) {
  if (car(p) === symbol(MULTIPLY)) {
    p = cdr(p);
    while (iscons(p)) {
      if (!ispoly_factor(car(p), x)) {
        return 0;
      }
      p = cdr(p);
    }
    return 1;
  } else {
    return ispoly_factor(p, x);
  }
};

ispoly_factor = function(p, x) {
  if (equal(p, x)) {
    return 1;
  }
  if (car(p) === symbol(POWER) && equal(cadr(p), x)) {
    if (isposint(caddr(p))) {
      return 1;
    } else {
      return 0;
    }
  }
  if (Find(p, x)) {
    return 0;
  } else {
    return 1;
  }
};

isnegativeterm = function(p) {
  if (isnegativenumber(p)) {
    return 1;
  } else if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {
    return 1;
  } else {
    return 0;
  }
};

isimaginarynumber = function(p) {
  if ((car(p) === symbol(MULTIPLY) && length(p) === 3 && isnum(cadr(p)) && equal(caddr(p), imaginaryunit)) || equal(p, imaginaryunit)) {
    return 1;
  } else {
    return 0;
  }
};

iscomplexnumber = function(p) {
  if ((car(p) === symbol(ADD) && length(p) === 3 && isnum(cadr(p)) && isimaginarynumber(caddr(p))) || isimaginarynumber(p)) {
    return 1;
  } else {
    return 0;
  }
};

iseveninteger = function(p) {
  if (isinteger(p) && (p.q.a[0] & 1) === 0) {
    return 1;
  } else {
    return 0;
  }
};

isnegative = function(p) {
  if (car(p) === symbol(ADD) && isnegativeterm(cadr(p))) {
    return 1;
  } else if (isnegativeterm(p)) {
    return 1;
  } else {
    return 0;
  }
};

issymbolic = function(p) {
  if (issymbol(p)) {
    return 1;
  } else {
    while (iscons(p)) {
      if (issymbolic(car(p))) {
        return 1;
      }
      p = cdr(p);
    }
    return 0;
  }
};

isintegerfactor = function(p) {
  if (isinteger(p) || car(p) === symbol(POWER) && isinteger(cadr(p)) && isinteger(caddr(p))) {
    return 1;
  } else {
    return 0;
  }
};

isoneover = function(p) {
  if (car(p) === symbol(POWER) && isminusone(caddr(p))) {
    return 1;
  } else {
    return 0;
  }
};

isfraction = function(p) {
  if (p.k === NUM && !MEQUAL(p.q.b, 1)) {
    return 1;
  } else {
    return 0;
  }
};

equaln = function(p, n) {
  switch (p.k) {
    case NUM:
      if (MEQUAL(p.q.a, n) && MEQUAL(p.q.b, 1)) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d === n) {
        return 1;
      }
  }
  return 0;
};

equalq = function(p, a, b) {
  switch (p.k) {
    case NUM:
      if (MEQUAL(p.q.a, a) && MEQUAL(p.q.b, b)) {
        return 1;
      }
      break;
    case DOUBLE:
      if (p.d === a / b) {
        return 1;
      }
  }
  return 0;
};

isoneoversqrttwo = function(p) {
  if (car(p) === symbol(POWER) && equaln(cadr(p), 2) && equalq(caddr(p), -1, 2)) {
    return 1;
  } else {
    return 0;
  }
};

isminusoneoversqrttwo = function(p) {
  if (car(p) === symbol(MULTIPLY) && equaln(cadr(p), -1) && isoneoversqrttwo(caddr(p)) && length(p) === 3) {
    return 1;
  } else {
    return 0;
  }
};

isfloating = function(p) {
  if (p.k === DOUBLE) {
    return 1;
  }
  while (iscons(p)) {
    if (isfloating(car(p))) {
      return 1;
    }
    p = cdr(p);
  }
  return 0;
};

isimaginaryunit = function(p) {
  if (equal(p, imaginaryunit)) {
    return 1;
  } else {
    return 0;
  }
};

isquarterturn = function(p) {
  var minussign, n;
  n = 0;
  minussign = 0;
  if (car(p) !== symbol(MULTIPLY)) {
    return 0;
  }
  if (equal(cadr(p), imaginaryunit)) {
    if (caddr(p) !== symbol(PI)) {
      return 0;
    }
    if (length(p) !== 3) {
      return 0;
    }
    return 2;
  }
  if (!isnum(cadr(p))) {
    return 0;
  }
  if (!equal(caddr(p), imaginaryunit)) {
    return 0;
  }
  if (cadddr(p) !== symbol(PI)) {
    return 0;
  }
  if (length(p) !== 4) {
    return 0;
  }
  push(cadr(p));
  push_integer(2);
  multiply();
  n = pop_integer();
  if (n === 0x80000000) {
    return 0;
  }
  if (n < 1) {
    minussign = 1;
    n = -n;
  }
  switch (n % 4) {
    case 0:
      n = 1;
      break;
    case 1:
      if (minussign) {
        n = 4;
      } else {
        n = 3;
      }
      break;
    case 2:
      n = 2;
      break;
    case 3:
      if (minussign) {
        n = 3;
      } else {
        n = 4;
      }
  }
  return n;
};

isnpi = function(p) {
  var doNothing, n;
  n = 0;
  if (p === symbol(PI)) {
    return 2;
  }
  if (car(p) === symbol(MULTIPLY) && isnum(cadr(p)) && caddr(p) === symbol(PI) && length(p) === 3) {
    doNothing = 0;
  } else {
    return 0;
  }
  push(cadr(p));
  push_integer(2);
  multiply();
  n = pop_integer();
  if (n === 0x80000000) {
    return 0;
  }
  if (n < 0) {
    n = 4 - (-n) % 4;
  } else {
    n = 1 + (n - 1) % 4;
  }
  return n;
};

list = function(n) {
  var ac, i, ref1, results;
  i = 0;
  push(symbol(NIL));
  results = [];
  for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    results.push(cons());
  }
  return results;
};

Eval_log = function() {
  push(cadr(p1));
  Eval();
  return logarithm();
};

logarithm = function() {
  save();
  yylog();
  return restore();
};

yylog = function() {
  var d;
  d = 0.0;
  p1 = pop();
  if (p1 === symbol(E)) {
    push_integer(1);
    return;
  }
  if (equaln(p1, 1)) {
    push_integer(0);
    return;
  }
  if (isnegativenumber(p1)) {
    push(p1);
    negate();
    logarithm();
    push(imaginaryunit);
    push_symbol(PI);
    multiply();
    add();
    return;
  }
  if (isdouble(p1)) {
    d = log(p1.d);
    push_double(d);
    return;
  }
  if (isfraction(p1)) {
    push(p1);
    numerator();
    logarithm();
    push(p1);
    denominator();
    logarithm();
    subtract();
    return;
  }
  if (car(p1) === symbol(POWER)) {
    push(caddr(p1));
    push(cadr(p1));
    logarithm();
    multiply();
    return;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    push_integer(0);
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      logarithm();
      add();
      p1 = cdr(p1);
    }
    return;
  }
  push_symbol(LOG);
  push(p1);
  return list(2);
};

s = ["log(1)", "0", "log(exp(1))", "1", "log(exp(x))", "x", "exp(log(x))", "x", "log(x^2)", "2*log(x)", "log(1/x)", "-log(x)", "log(a^b)", "b*log(a)", "log(2)", "log(2)", "log(2.0)", "0.693147", "float(log(2))", "0.693147", "log(a*b)", "log(a)+log(b)", "log(1/3)+log(3)", "0", "log(-1)", "i*pi", "log(-1.0)", "i*pi"];


/*
void
test_log(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}

#endif
 */

madd = function(a, b) {
  return a.add(b);
};

msub = function(a, b) {
  return a.subtract(b);
};

addf = function(a, b) {
  return a.add(b);
};

subf = function(a, b) {
  return a.subtract(b);
};

ucmp = function(a, b) {
  return a.compareAbs(b);
};

test_madd = function() {
  var ac, ad, i, j, m;
  i = 0;
  console.log("test madd\n");
  m = mtotal;
  for (i = ac = -100; ac < 100; i = ++ac) {
    for (j = ad = -100; ad < 100; j = ++ad) {
      test_maddf(i, j, i + j);
    }
  }
  return logout("ok\n");
};

test_maddf = function(na, nb, nc) {
  var a, b, c, d;
  a = mint(na);
  b = mint(nb);
  c = mint(nc);
  d = madd(a, b);
  if (mcmp(c, d) === 0) {
    return;
  } else {
    throw new Error("test_maddf");
  }
  logout(logbuf);
  return errout();
};

test_msub = function() {
  var ac, ad, i, j, m;
  i = 0;
  logout("test msub\n");
  m = mtotal;
  for (i = ac = -100; ac <= 100; i = ++ac) {
    for (j = ad = -100; ad <= 100; j = ++ad) {
      test_msubf(i, j, i - j);
    }
  }
  if (m !== mtotal) {
    logout("memory leak\n");
    errout();
  }
  return logout("ok\n");
};

test_msubf = function(na, nb, nc) {
  var a, b, c, d;
  a = mint(na);
  b = mint(nb);
  c = mint(nc);
  d = msub(a, b);
  if (mcmp(c, d) === 0) {
    return;
  }
  logout(logbuf);
  return errout();
};

mcmp = function(a, b) {
  return a.compare(b);
};

mcmpint = function(a, n) {
  var b, t;
  b = bigInt(n);
  t = mcmp(a, b);
  return t;
};


/*
#if SELFTEST

void
test_mcmp(void)
{
	int i, j, k;
	unsigned int *x, *y;
	logout("testing mcmp\n");
	for (i = -1000; i < 1000; i++) {
		x = mint(i);
		for (j = -1000; j < 1000; j++) {
			y = mint(j);
			k = mcmp(x, y);
			if (i == j && k != 0) {
				logout("failed\n");
				errout();
			}
			if (i < j && k != -1) {
				logout("failed\n");
				errout();
			}
			if (i > j && k != 1) {
				logout("failed\n");
				errout();
			}
			mfree(y);
		}
		mfree(x);
	}
	logout("ok\n");
}

#endif
 */

mgcd = function(u, v) {
  return bigInt.gcd(u, v);
};

test_mgcd = function() {
  var a, ac, ad, b, c, d, i, j;
  logout("testing mgcd\n");
  for (i = ac = 1; ac < 100; i = ++ac) {
    a = mint(i);
    for (j = ad = 1; ad < 100; j = ++ad) {
      b = mint(j);
      c = mgcd(a, b);
      d = egcd(a, b);
      if (mcmp(c, d) !== 0) {
        throw new Error("test_mgcd failed");
      }
    }
  }
  return logout("ok\n");
};

egcd = function(a, b) {
  var c, sign;
  sign = 0;
  if (MZERO(b)) {
    stop("divide by zero");
  }
  if (MZERO(a)) {
    return b;
  }
  sign = MSIGN(b);
  while (!MZERO(b)) {
    c = mmod(a, b);
    a = b;
    b = c;
  }
  setSignTo(a, sign);
  return a;
};

new_string = function(s) {
  save();
  p1 = new U();
  p1.k = STR;
  p1.str = s;
  push(p1);
  return restore();
};

out_of_memory = function() {
  return stop("out of memory");
};

push_zero_matrix = function(i, j) {
  push(alloc_tensor(i * j));
  stack[tos - 1].tensor.ndim = 2;
  stack[tos - 1].tensor.dim[0] = i;
  return stack[tos - 1].tensor.dim[1] = j;
};

push_identity_matrix = function(n) {
  var ac, i, ref1;
  push_zero_matrix(n, n);
  i = 0;
  for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    stack[tos - 1].tensor.elem[i * n + i] = one;
  }
  if (stack[tos - 1].tensor.nelem !== stack[tos - 1].tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
};

push_cars = function(p) {
  var results;
  results = [];
  while (iscons(p)) {
    push(car(p));
    results.push(p = cdr(p));
  }
  return results;
};

peek = function() {
  save();
  p1 = pop();
  push(p1);
  printline(p1);
  return restore();
};

peek2 = function() {
  print_lisp(stack[tos - 2]);
  return print_lisp(stack[tos - 1]);
};

equal = function(p1, p2) {
  if (cmp_expr(p1, p2) === 0) {
    return 1;
  } else {
    return 0;
  }
};

lessp = function(p1, p2) {
  if (cmp_expr(p1, p2) < 0) {
    return 1;
  } else {
    return 0;
  }
};

sign = function(n) {
  if (n < 0) {
    return -1;
  } else if (n > 0) {
    return 1;
  } else {
    return 0;
  }
};

cmp_expr = function(p1, p2) {
  var n;
  n = 0;
  if (p1 === p2) {
    return 0;
  }
  if (p1 === symbol(NIL)) {
    return -1;
  }
  if (p2 === symbol(NIL)) {
    return 1;
  }
  if (isnum(p1) && isnum(p2)) {
    return sign(compare_numbers(p1, p2));
  }
  if (isnum(p1)) {
    return -1;
  }
  if (isnum(p2)) {
    return 1;
  }
  if (isstr(p1) && isstr(p2)) {
    return sign(p1.str.localeCompare(p2.str));
  }
  if (isstr(p1)) {
    return -1;
  }
  if (isstr(p2)) {
    return 1;
  }
  if (issymbol(p1) && issymbol(p2)) {
    return sign(get_printname(p1).localeCompare(get_printname(p2)));
  }
  if (issymbol(p1)) {
    return -1;
  }
  if (issymbol(p2)) {
    return 1;
  }
  if (istensor(p1) && istensor(p2)) {
    return compare_tensors(p1, p2);
  }
  if (istensor(p1)) {
    return -1;
  }
  if (istensor(p2)) {
    return 1;
  }
  while (iscons(p1) && iscons(p2)) {
    n = cmp_expr(car(p1), car(p2));
    if (n !== 0) {
      return n;
    }
    p1 = cdr(p1);
    p2 = cdr(p2);
  }
  if (iscons(p2)) {
    return -1;
  }
  if (iscons(p1)) {
    return 1;
  }
  return 0;
};

length = function(p) {
  var n;
  n = 0;
  while (iscons(p)) {
    p = cdr(p);
    n++;
  }
  return n;
};

unique = function(p) {
  save();
  p1 = symbol(NIL);
  p2 = symbol(NIL);
  unique_f(p);
  if (p2 !== symbol(NIL)) {
    p1 = symbol(NIL);
  }
  p = p1;
  restore();
  return p;
};

unique_f = function(p) {
  if (isstr(p)) {
    if (p1 === symbol(NIL)) {
      p1 = p;
    } else if (p !== p1) {
      p2 = p;
    }
    return;
  }
  while (iscons(p)) {
    unique_f(car(p));
    if (p2 !== symbol(NIL)) {
      return;
    }
    p = cdr(p);
  }
};


/*
void
check_endianess(void)
{
	int tmp = 1;
	if (((char *) &tmp)[0] == 1 && Y_LITTLE_ENDIAN == 0) {
		printf("Please change Y_LITTLE_ENDIAN to 1 in defs.h and recompile.\n");
		Exit(1);
	}
	if (((char *) &tmp)[0] == 0 && Y_LITTLE_ENDIAN != 0) {
		printf("Please change Y_LITTLE_ENDIAN to 0 in defs.h and recompile.\n");
		Exit(1);
	}
}
 */

ssqrt = function() {
  push_rational(1, 2);
  return power();
};

yyexpand = function() {
  var x;
  x = expanding;
  expanding = 1;
  Eval();
  return expanding = x;
};

exponential = function() {
  push_symbol(E);
  swap();
  return power();
};

square = function() {
  push_integer(2);
  return power();
};

__cmp = function(p1, p2) {
  console.log("__cmp(p1, p2) likely to be mangled");
  return cmp_expr(p1, p2);
};

sort_stack = function(n) {
  console.log("!!! sort_stack not yet translated");
  return qsort(stack[tos - n], n, aaa, __cmp);
};

mmul = function(a, b) {
  return a.multiply(b);
};

mdiv = function(a, b) {
  return a.divide(b);
};


/*
static void
addf(unsigned int *a, unsigned int *b, int len)
{
	int i;
	long long t = 0; # can be signed or unsigned 
	for (i = 0; i < len; i++) {
		t += (long long) a[i] + b[i];
		a[i] = (unsigned int) t;
		t >>= 32;
	}
}

// a = a - b

static void
subf(unsigned int *a, unsigned int *b, int len)
{
	int i;
	long long t = 0; # must be signed
	for (i = 0; i < len; i++) {
		t += (long long) a[i] - b[i];
		a[i] = (unsigned int) t;
		t >>= 32;
	}
}

// a = b * c

// 0xffffffff + 0xffffffff * 0xffffffff == 0xffffffff00000000

static void
mulf(unsigned int *a, unsigned int *b, int len, unsigned int c)
{
	int i;
	unsigned long long t = 0; # must be unsigned
	for (i = 0; i < len; i++) {
		t += (unsigned long long) b[i] * c;
		a[i] = (unsigned int) t;
		t >>= 32;
	}
	a[i] = (unsigned int) t;
}
 */

mmod = function(a, b) {
  return a.mod(b);
};


/*
void
mdivrem(unsigned int **q, unsigned int **r, unsigned int *a, unsigned int *b)
{
	int alen, blen, i, n;
	unsigned int c, *t, *x, *y;
	unsigned long long jj, kk;

	if (MZERO(b))
		stop("divide by zero");

	if (MZERO(a)) {
		*q = mint(0);
		*r = mint(0);
		return;
	}

	alen = MLENGTH(a);
	blen = MLENGTH(b);

	n = alen - blen;

	if (n < 0) {
		*q = mint(0);
		*r = mcopy(a);
		return;
	}

	x = mnew(alen + 1);

	for (i = 0; i < alen; i++)
		x[i] = a[i];

	x[i] = 0;

	y = mnew(n + 1);

	t = mnew(blen + 1);

	kk = (unsigned long long) b[blen - 1] + 1;

	for (i = 0; i <= n; i++) {

		y[n - i] = 0;

		for (;;) {

			 * estimate the partial quotient

			if (little_endian()) {
				((unsigned int *) &jj)[0] = x[alen - i - 1];
				((unsigned int *) &jj)[1] = x[alen - i - 0];
			} else {
				((unsigned int *) &jj)[1] = x[alen - i - 1];
				((unsigned int *) &jj)[0] = x[alen - i - 0];
			}

			c = (int) (jj / kk);

			if (c == 0) {
				if (ge(x + n - i, b, blen)) { # see note 1
					y[n - i]++;
					subf(x + n - i, b, blen);
				}
				break;
			}

			y[n - i] += c;
			mulf(t, b, blen, c);
			subf(x + n - i, t, blen + 1);
		}
	}

	mfree(t);

	 * length of quotient

	for (i = n; i > 0; i--)
		if (y[i])
			break;

	if (i == 0 && y[0] == 0) {
		mfree(y);
		y = mint(0);
	} else {
		MLENGTH(y) = i + 1;
		MSIGN(y) = MSIGN(a) * MSIGN(b);
	}

	 * length of remainder

	for (i = blen - 1; i > 0; i--)
		if (x[i])
			break;

	if (i == 0 && x[0] == 0) {
		mfree(x);
		x = mint(0);
	} else {
		MLENGTH(x) = i + 1;
		MSIGN(x) = MSIGN(a);
	}

	*q = y;
	*r = x;
}
 */

test_mmul = function() {
  var ac, ad, i, j, m;
  i = 0;
  j = 0;
  m = 0;
  logout("test mmul\n");
  for (i = ac = -100; ac <= 100; i = ++ac) {
    for (j = ad = -100; ad <= 100; j = ++ad) {
      test_mmulf(i, j, i * j);
    }
  }
  return logout("ok\n");
};

test_mmulf = function(na, nb, nc) {
  var a, b, c, d;
  a = mint(na);
  b = mint(nb);
  c = mint(nc);
  d = mmul(a, b);
  if (mcmp(c, d) === 0) {

  } else {
    throw new Error("test_mmulf error");
  }
};

test_mdiv = function() {
  var ac, ad, expectedResult, i, j, m;
  i = 0;
  j = 0;
  m = 0;
  logout("test mdiv\n");
  for (i = ac = -100; ac <= 100; i = ++ac) {
    for (j = ad = -100; ad <= 100; j = ++ad) {
      if (j) {
        if (i / j > 0) {
          expectedResult = Math.floor(i / j);
        } else {
          expectedResult = Math.ceil(i / j);
        }
        test_mdivf(i, j, expectedResult);
      }
    }
  }
  return logout("ok\n");
};

test_mdivf = function(na, nb, nc) {
  var a, b, c, d;
  a = mint(na);
  b = mint(nb);
  c = mint(nc);
  d = mdiv(a, b);
  if (mcmp(c, d) === 0) {

  } else {
    debugger;
    throw new Error("test_mdivf error");
  }
};

test_mmod = function() {
  var ac, ad, i, j, m;
  i = 0;
  j = 0;
  m = 0;
  logout("test mmod\n");
  for (i = ac = -100; ac <= 100; i = ++ac) {
    for (j = ad = -100; ad <= 100; j = ++ad) {
      if (j) {
        test_mmodf(i, j, i % j);
      }
    }
  }
  return logout("ok\n");
};

test_mmodf = function(na, nb, nc) {
  var a, b, c, d;
  a = mint(na);
  b = mint(nb);
  c = mint(nc);
  d = mmod(a, b);
  if (mcmp(c, d) === 0) {

  } else {
    throw new Error("test_mmodf error");
  }
};

mpow = function(a, n) {
  return a.pow(n);
};

test_mpow = function() {
  var a, ac, ad, b, c, i, j, x;
  logout("testing mpow\n");
  for (i = ac = -10; ac < 10; i = ++ac) {
    a = mint(i);
    x = 1;
    for (j = ad = 0; ad < 10; j = ++ad) {
      b = mpow(a, j);
      c = mint(x);
      if (mcmp(b, c) !== 0) {
        throw new Error("failed test_mpow");
      }
      x *= i;
    }
  }
  return logout("ok\n");
};

mprime = function(n) {
  return n.isProbablePrime();
};

test_mprime = function() {
  var ac, i, k, m, n, t;
  i = 0;
  k = 0;
  m = 0;
  t = 0;
  logout("test mprime\n");
  k = 0;
  for (i = ac = 0; ac < 10000; i = ++ac) {
    n = mint(i);
    t = mprime(n);
    if (i === primetab[k]) {
      if (t === 0) {
        throw new Error("failed for prime number " + i);
      }
      k++;
    } else if (t === 1) {
      throw new Error("failed for composite number " + i);
    }
  }
  return logout("ok\n");
};

mroot = function(n, index) {
  var ac, i, j, k, ref1, x, y;
  n = n.abs();
  i = 0;
  j = 0;
  k = 0;
  if (index === 0) {
    stop("root index is zero");
  }
  k = 0;
  while (n.shiftRight(k) > 0) {
    k++;
  }
  if (k === 0) {
    return mint(0);
  }
  k = Math.floor((k - 1) / index);
  j = Math.floor(k / 32 + 1);
  x = bigInt(j);
  for (i = ac = 0, ref1 = j; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    x = x.and(bigInt(1).shiftLeft(i).not());
  }
  while (k >= 0) {
    x = x.or(bigInt(1).shiftLeft(k));
    y = mpow(x, index);
    switch (mcmp(y, n)) {
      case 0:
        return x;
      case 1:
        x = x.and(bigInt(1).shiftLeft(k).not());
    }
    k--;
  }
  return 0;
};

test_mroot = function() {
  var a, ac, ad, ae, b, c, i, j, mem;
  i = 0;
  j = 0;
  mem = 0;
  logout("testing mroot\n");
  for (i = ac = 0; ac < 10; i = ++ac) {
    a = mint(i);
    for (j = ad = 1; ad < 10; j = ++ad) {
      logout(i + " " + j);
      b = mpow(a, j);
      c = mroot(b, j);
      if (c === 0 || mcmp(a, c) !== 0) {
        debugger;
        throw new Error("failed test_mroot");
      }
    }
  }
  logout("mroot small numbers ok\n");
  a = mint(12345);
  for (i = ae = 1; ae < 10; i = ++ae) {
    logout(i);
    b = mpow(a, i);
    c = mroot(b, i);
    if (c === 0 || mcmp(a, c) !== 0) {
      throw new Error("failed");
    }
  }
  logout("mroot big numbers ok\n");
  return logout("mroot all ok\n");
};

multiply = function() {
  if (esc_flag) {
    stop("escape key stop");
  }
  if (isnum(stack[tos - 2]) && isnum(stack[tos - 1])) {
    return multiply_numbers();
  } else {
    save();
    yymultiply();
    return restore();
  }
};

yymultiply = function() {
  var ac, h, i, n, ref1, ref2;
  h = 0;
  i = 0;
  n = 0;
  p2 = pop();
  p1 = pop();
  h = tos;
  if (iszero(p1) || iszero(p2)) {
    push(zero);
    return;
  }
  if (expanding && isadd(p1)) {
    p1 = cdr(p1);
    push(zero);
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      multiply();
      add();
      p1 = cdr(p1);
    }
    return;
  }
  if (expanding && isadd(p2)) {
    p2 = cdr(p2);
    push(zero);
    while (iscons(p2)) {
      push(p1);
      push(car(p2));
      multiply();
      add();
      p2 = cdr(p2);
    }
    return;
  }
  if (!istensor(p1) && istensor(p2)) {
    push(p1);
    push(p2);
    scalar_times_tensor();
    return;
  }
  if (istensor(p1) && !istensor(p2)) {
    push(p1);
    push(p2);
    tensor_times_scalar();
    return;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    p1 = cdr(p1);
  } else {
    push(p1);
    list(1);
    p1 = pop();
  }
  if (car(p2) === symbol(MULTIPLY)) {
    p2 = cdr(p2);
  } else {
    push(p2);
    list(1);
    p2 = pop();
  }
  if (isnum(car(p1)) && isnum(car(p2))) {
    push(car(p1));
    push(car(p2));
    multiply_numbers();
    p1 = cdr(p1);
    p2 = cdr(p2);
  } else if (isnum(car(p1))) {
    push(car(p1));
    p1 = cdr(p1);
  } else if (isnum(car(p2))) {
    push(car(p2));
    p2 = cdr(p2);
  } else {
    push(one);
  }
  parse_p1();
  parse_p2();
  while (iscons(p1) && iscons(p2)) {
    if (caar(p1) === symbol(OPERATOR) && caar(p2) === symbol(OPERATOR)) {
      push_symbol(OPERATOR);
      push(cdar(p1));
      push(cdar(p2));
      append();
      cons();
      p1 = cdr(p1);
      p2 = cdr(p2);
      parse_p1();
      parse_p2();
      continue;
    }
    switch (cmp_expr(p3, p4)) {
      case -1:
        push(car(p1));
        p1 = cdr(p1);
        parse_p1();
        break;
      case 1:
        push(car(p2));
        p2 = cdr(p2);
        parse_p2();
        break;
      case 0:
        combine_factors(h);
        p1 = cdr(p1);
        p2 = cdr(p2);
        parse_p1();
        parse_p2();
        break;
      default:
        stop("internal error 2");
    }
  }
  while (iscons(p1)) {
    push(car(p1));
    p1 = cdr(p1);
  }
  while (iscons(p2)) {
    push(car(p2));
    p2 = cdr(p2);
  }
  __normalize_radical_factors(h);
  if (expanding) {
    for (i = ac = ref1 = h, ref2 = tos; ref1 <= ref2 ? ac < ref2 : ac > ref2; i = ref1 <= ref2 ? ++ac : --ac) {
      if (isadd(stack[i])) {
        multiply_all(tos - h);
        return;
      }
    }
  }
  n = tos - h;
  if (n === 1) {
    return;
  }
  if (isrational(stack[h]) && equaln(stack[h], 1)) {
    if (n === 2) {
      p7 = pop();
      pop();
      push(p7);
    } else {
      stack[h] = symbol(MULTIPLY);
      list(n);
    }
    return;
  }
  list(n);
  p7 = pop();
  push_symbol(MULTIPLY);
  push(p7);
  return cons();
};

parse_p1 = function() {
  p3 = car(p1);
  p5 = one;
  if (car(p3) === symbol(POWER)) {
    p5 = caddr(p3);
    return p3 = cadr(p3);
  }
};

parse_p2 = function() {
  p4 = car(p2);
  p6 = one;
  if (car(p4) === symbol(POWER)) {
    p6 = caddr(p4);
    return p4 = cadr(p4);
  }
};

combine_factors = function(h) {
  push(p4);
  push(p5);
  push(p6);
  add();
  power();
  p7 = pop();
  if (isnum(p7)) {
    push(stack[h]);
    push(p7);
    multiply_numbers();
    return stack[h] = pop();
  } else if (car(p7) === symbol(MULTIPLY)) {
    if (isnum(cadr(p7)) && cdddr(p7) === symbol(NIL)) {
      push(stack[h]);
      push(cadr(p7));
      multiply_numbers();
      stack[h] = pop();
      return push(caddr(p7));
    } else {
      return push(p7);
    }
  } else {
    return push(p7);
  }
};

gp = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, -6, -7, -8, -3, -4, -5, 13, 14, 15, -16, 9, 10, 11, -12], [0, 0, 6, -1, -11, 10, -2, -15, 14, 12, -5, 4, -9, 16, -8, 7, -13], [0, 0, 7, 11, -1, -9, 15, -2, -13, 5, 12, -3, -10, 8, 16, -6, -14], [0, 0, 8, -10, 9, -1, -14, 13, -2, -4, 3, 12, -11, -7, 6, 16, -15], [0, 0, 3, 2, 15, -14, 1, 11, -10, 16, -8, 7, 13, 12, -5, 4, 9], [0, 0, 4, -15, 2, 13, -11, 1, 9, 8, 16, -6, 14, 5, 12, -3, 10], [0, 0, 5, 14, -13, 2, 10, -9, 1, -7, 6, 16, 15, -4, 3, 12, 11], [0, 0, 13, 12, -5, 4, 16, -8, 7, -1, -11, 10, -3, -2, -15, 14, -6], [0, 0, 14, 5, 12, -3, 8, 16, -6, 11, -1, -9, -4, 15, -2, -13, -7], [0, 0, 15, -4, 3, 12, -7, 6, 16, -10, 9, -1, -5, -14, 13, -2, -8], [0, 0, 16, -9, -10, -11, -13, -14, -15, -3, -4, -5, 1, -6, -7, -8, 2], [0, 0, 9, -16, 8, -7, -12, 5, -4, -2, -15, 14, 6, -1, -11, 10, 3], [0, 0, 10, -8, -16, 6, -5, -12, 3, 15, -2, -13, 7, 11, -1, -9, 4], [0, 0, 11, 7, -6, -16, 4, -3, -12, -14, 13, -2, 8, -10, 9, -1, 5], [0, 0, 12, 13, 14, 15, 9, 10, 11, -6, -7, -8, -2, -3, -4, -5, -1]];

combine_gammas = function(h) {
  var n;
  n = gp[Math.floor(p1.gamma)][Math.floor(p2.gamma)];
  if (n < 0) {
    n = -n;
    push(stack[h]);
    negate();
    stack[h] = pop();
  }
  if (n > 1) {
    return push(_gamma[n]);
  }
};

multiply_noexpand = function() {
  var x;
  x = expanding;
  expanding = 0;
  multiply();
  return expanding = x;
};

multiply_all = function(n) {
  var ac, h, i, ref1;
  i = 0;
  if (n === 1) {
    return;
  }
  if (n === 0) {
    push(one);
    return;
  }
  h = tos - n;
  push(stack[h]);
  for (i = ac = 1, ref1 = n; 1 <= ref1 ? ac < ref1 : ac > ref1; i = 1 <= ref1 ? ++ac : --ac) {
    push(stack[h + i]);
    multiply();
  }
  stack[h] = pop();
  return tos = h + 1;
};

multiply_all_noexpand = function(n) {
  var x;
  x = expanding;
  expanding = 0;
  multiply_all(n);
  return expanding = x;
};

divide = function() {
  if (isnum(stack[tos - 2]) && isnum(stack[tos - 1])) {
    return divide_numbers();
  } else {
    inverse();
    return multiply();
  }
};

inverse = function() {
  if (isnum(stack[tos - 1])) {
    return invert_number();
  } else {
    push_integer(-1);
    return power();
  }
};

reciprocate = function() {
  if (isnum(stack[tos - 1])) {
    return invert_number();
  } else {
    push_integer(-1);
    return power();
  }
};

negate = function() {
  if (isnum(stack[tos - 1])) {
    return negate_number();
  } else {
    push_integer(-1);
    return multiply();
  }
};

negate_expand = function() {
  var x;
  x = expanding;
  expanding = 1;
  negate();
  return expanding = x;
};

negate_noexpand = function() {
  var x;
  x = expanding;
  expanding = 0;
  negate();
  return expanding = x;
};

__normalize_radical_factors = function(h) {
  var ac, ad, ae, i, ref1, ref2, ref3, ref4, ref5, ref6;
  i = 0;
  if (isplusone(stack[h]) || isminusone(stack[h]) || isdouble(stack[h])) {
    return;
  }
  for (i = ac = ref1 = h + 1, ref2 = tos; ref1 <= ref2 ? ac < ref2 : ac > ref2; i = ref1 <= ref2 ? ++ac : --ac) {
    if (__is_radical_number(stack[i])) {
      break;
    }
  }
  if (i === tos) {
    return;
  }
  save();
  push(stack[h]);
  mp_numerator();
  p1 = pop();
  for (i = ad = ref3 = h + 1, ref4 = tos; ref3 <= ref4 ? ad < ref4 : ad > ref4; i = ref3 <= ref4 ? ++ad : --ad) {
    if (isplusone(p1) || isminusone(p1)) {
      break;
    }
    if (!__is_radical_number(stack[i])) {
      continue;
    }
    p3 = cadr(stack[i]);
    p4 = caddr(stack[i]);
    if (!isnegativenumber(p4)) {
      continue;
    }
    push(p1);
    push(p3);
    divide();
    p5 = pop();
    if (!isinteger(p5)) {
      continue;
    }
    p1 = p5;
    push_symbol(POWER);
    push(p3);
    push(one);
    push(p4);
    add();
    list(3);
    stack[i] = pop();
  }
  push(stack[h]);
  mp_denominator();
  p2 = pop();
  for (i = ae = ref5 = h + 1, ref6 = tos; ref5 <= ref6 ? ae < ref6 : ae > ref6; i = ref5 <= ref6 ? ++ae : --ae) {
    if (isplusone(p2)) {
      break;
    }
    if (!__is_radical_number(stack[i])) {
      continue;
    }
    p3 = cadr(stack[i]);
    p4 = caddr(stack[i]);
    if (isnegativenumber(p4)) {
      continue;
    }
    push(p2);
    push(p3);
    divide();
    p5 = pop();
    if (!isinteger(p5)) {
      continue;
    }
    p2 = p5;
    push_symbol(POWER);
    push(p3);
    push(p4);
    push(one);
    subtract();
    list(3);
    stack[i] = pop();
  }
  push(p1);
  push(p2);
  divide();
  stack[h] = pop();
  return restore();
};

__is_radical_number = function(p) {
  if (car(p) === symbol(POWER) && isnum(cadr(p)) && isnum(caddr(p)) && !isminusone(cadr(p))) {
    return 1;
  } else {
    return 0;
  }
};

s = ["0*a", "0", "a*0", "0", "1*a", "a", "a*1", "a", "a*a", "a^2", "a^2*a", "a^3", "a*a^2", "a^3", "a^2*a^2", "a^4", "2^a*2^(3-a)", "8", "sqrt(2)/2", "2^(-1/2)", "2/sqrt(2)", "2^(1/2)", "-sqrt(2)/2", "-1/(2^(1/2))", "2^(1/2-a)*2^a/10", "1/(5*2^(1/2))", "i/4", "1/4*i", "1/(4 i)", "-1/4*i", "1.0 pi 1/2", "0.5*pi", "1.0 1/2 pi", "0.5*pi"];

isspace = function(s) {
  if (s == null) {
    return false;
  }
  return s === ' ' || s === '\t' || s === '\n' || s === '\v' || s === '\f' || s === '\r';
};

isdigit = function(str) {
  if (str == null) {
    return false;
  }
  return /^\d+$/.test(str);
};

isalpha = function(str) {
  if (str == null) {
    return false;
  }
  if (str == null) {
    debugger;
  }
  return str.search(/[^A-Za-z\s]/) === -1;
};

isalnum = function(str) {
  if (str == null) {
    return false;
  }
  return isalpha(str) || isdigit(str);
};


/* Power function

	Input:		push	Base

			push	Exponent

	Output:		Result on stack
 */

Eval_power = function() {
  push(cadr(p1));
  Eval();
  push(caddr(p1));
  Eval();
  return power();
};

power = function() {
  save();
  yypower();
  return restore();
};

yypower = function() {
  var n;
  n = 0;
  p2 = pop();
  p1 = pop();
  if (isrational(p1) && isrational(p2)) {
    push(p1);
    push(p2);
    qpow();
    return;
  }
  if (isnum(p1) && isnum(p2)) {
    push(p1);
    push(p2);
    dpow();
    return;
  }
  if (istensor(p1)) {
    power_tensor();
    return;
  }
  if (p1 === symbol(E) && car(p2) === symbol(LOG)) {
    push(cadr(p2));
    return;
  }
  if (p1 === symbol(E) && isdouble(p2)) {
    push_double(exp(p2.d));
    return;
  }
  if (equal(p1, one) || iszero(p2)) {
    push(one);
    return;
  }
  if (equal(p2, one)) {
    push(p1);
    return;
  }
  if (car(p1) === symbol(MULTIPLY)) {
    p1 = cdr(p1);
    push(car(p1));
    push(p2);
    power();
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      power();
      multiply();
      p1 = cdr(p1);
    }
    return;
  }
  if (car(p1) === symbol(POWER)) {
    push(cadr(p1));
    push(caddr(p1));
    push(p2);
    multiply();
    power();
    return;
  }
  if (expanding && isadd(p1) && isnum(p2)) {
    push(p2);
    n = pop_integer();
    if (n > 1 && n !== 0x80000000) {
      power_sum(n);
      return;
    }
  }
  if (trigmode === 1 && car(p1) === symbol(SIN) && iseveninteger(p2)) {
    push_integer(1);
    push(cadr(p1));
    cosine();
    push_integer(2);
    power();
    subtract();
    push(p2);
    push_rational(1, 2);
    multiply();
    power();
    return;
  }
  if (trigmode === 2 && car(p1) === symbol(COS) && iseveninteger(p2)) {
    push_integer(1);
    push(cadr(p1));
    sine();
    push_integer(2);
    power();
    subtract();
    push(p2);
    push_rational(1, 2);
    multiply();
    power();
    return;
  }
  if (iscomplexnumber(p1)) {
    if (isinteger(p2)) {
      push(p1);
      conjugate();
      p3 = pop();
      push(p3);
      push(p3);
      push(p1);
      multiply();
      divide();
      push(p2);
      negate();
      power();
      return;
    }
    if (isnum(p2)) {
      push(p1);
      mag();
      push(p2);
      power();
      push_integer(-1);
      push(p1);
      arg();
      push(p2);
      multiply();
      push(symbol(PI));
      divide();
      power();
      multiply();
      return;

      /*
      			push(p1);
      			mag();
      			push(p2);
      			power();
      			push(symbol(E));
      			push(p1);
      			arg();
      			push(p2);
      			multiply();
      			push(imaginaryunit);
      			multiply();
      			power();
      			multiply();
       */
    }
  }
  if (simplify_polar()) {
    return;
  }
  push_symbol(POWER);
  push(p1);
  push(p2);
  return list(3);
};

power_sum = function(n) {
  var a, ac, ad, ae, i, j, k, ref1, ref2, ref3;
  a = [];
  i = 0;
  j = 0;
  k = 0;
  k = length(p1) - 1;
  push_frame(k * (n + 1));
  p1 = cdr(p1);
  for (i = ac = 0, ref1 = k; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    for (j = ad = 0, ref2 = n; 0 <= ref2 ? ad <= ref2 : ad >= ref2; j = 0 <= ref2 ? ++ad : --ad) {
      push(car(p1));
      push_integer(j);
      power();
      stack[frame + i * (n + 1) + j] = pop();
    }
    p1 = cdr(p1);
  }
  push_integer(n);
  factorial();
  p1 = pop();
  for (i = ae = 0, ref3 = k; 0 <= ref3 ? ae < ref3 : ae > ref3; i = 0 <= ref3 ? ++ae : --ae) {
    a[i] = 0;
  }
  push(zero);
  multinomial_sum(k, n, a, 0, n);
  return pop_frame(k * (n + 1));
};

multinomial_sum = function(k, n, a, i, m) {
  var ac, ad, ae, j, ref1, ref2, ref3;
  j = 0;
  if (i < k - 1) {
    for (j = ac = 0, ref1 = m; 0 <= ref1 ? ac <= ref1 : ac >= ref1; j = 0 <= ref1 ? ++ac : --ac) {
      a[i] = j;
      multinomial_sum(k, n, a, i + 1, m - j);
    }
    return;
  }
  a[i] = m;
  push(p1);
  for (j = ad = 0, ref2 = k; 0 <= ref2 ? ad < ref2 : ad > ref2; j = 0 <= ref2 ? ++ad : --ad) {
    push_integer(a[j]);
    factorial();
    divide();
  }
  for (j = ae = 0, ref3 = k; 0 <= ref3 ? ae < ref3 : ae > ref3; j = 0 <= ref3 ? ++ae : --ae) {
    push(stack[frame + j * (n + 1) + a[j]]);
    multiply();
  }
  return add();
};

simplify_polar = function() {
  var doNothing, n;
  n = 0;
  n = isquarterturn(p2);
  switch (n) {
    case 0:
      doNothing = 1;
      break;
    case 1:
      push_integer(1);
      return 1;
    case 2:
      push_integer(-1);
      return 1;
    case 3:
      push(imaginaryunit);
      return 1;
    case 4:
      push(imaginaryunit);
      negate();
      return 1;
  }
  if (car(p2) === symbol(ADD)) {
    p3 = cdr(p2);
    while (iscons(p3)) {
      n = isquarterturn(car(p3));
      if (n) {
        break;
      }
      p3 = cdr(p3);
    }
    switch (n) {
      case 0:
        return 0;
      case 1:
        push_integer(1);
        break;
      case 2:
        push_integer(-1);
        break;
      case 3:
        push(imaginaryunit);
        break;
      case 4:
        push(imaginaryunit);
        negate();
    }
    push(p2);
    push(car(p3));
    subtract();
    exponential();
    multiply();
    return 1;
  }
  return 0;
};

s = ["2^(1/2)", "2^(1/2)", "2^(3/2)", "2*2^(1/2)", "(-2)^(1/2)", "i*2^(1/2)", "3^(4/3)", "3*3^(1/3)", "3^(-4/3)", "1/(3*3^(1/3))", "3^(5/3)", "3*3^(2/3)", "3^(2/3)-9^(1/3)", "0", "3^(10/3)", "27*3^(1/3)", "3^(-10/3)", "1/(27*3^(1/3))", "(1/3)^(10/3)", "1/(27*3^(1/3))", "(1/3)^(-10/3)", "27*3^(1/3)", "27^(2/3)", "9", "27^(-2/3)", "1/9", "102^(1/2)", "2^(1/2)*3^(1/2)*17^(1/2)", "32^(1/3)", "2*2^(2/3)", "9999^(1/2)", "3*11^(1/2)*101^(1/2)", "10000^(1/3)", "10*2^(1/3)*5^(1/3)", "sqrt(1000000)", "1000", "sqrt(-1000000)", "1000*i", "sqrt(2^60)", "1073741824", "6^(1/3) 3^(2/3)", "3*2^(1/3)", "1/(2+3*i)", "2/13-3/13*i", "1/(2+3*i)^2", "-5/169-12/169*i", "(-1+3i)/(2-i)", "-1+i", "(0.0)^(0.0)", "1", "(-4.0)^(1.5)", "-8*i", "(-4.0)^(0.5)", "2*i", "(-4.0)^(-0.5)", "-0.5*i", "(-4.0)^(-1.5)", "0.125*i", "(1+i)^2", "2*i", "(1+i)^(-2)", "-1/2*i", "(1+i)^(1/2)", "(-1)^(1/8)*2^(1/4)", "(1+i)^(-1/2)", "-(-1)^(7/8)/(2^(1/4))", "(1+i)^(0.5)", "1.09868+0.45509*i", "(1+i)^(-0.5)", "0.776887-0.321797*i", "exp(i*pi/2)", "i", "exp(i*pi)", "-1", "exp(i*3*pi/2)", "-i", "exp(i*2*pi)", "1", "exp(i*5*pi/2)", "i", "exp(i*3*pi)", "-1", "exp(i*7*pi/2)", "-i", "exp(i*4*pi)", "1", "exp(A+i*pi/2)", "i*exp(A)", "exp(A+i*pi)", "-exp(A)", "exp(A+i*3*pi/2)", "-i*exp(A)", "exp(A+i*2*pi)", "exp(A)", "exp(A+i*5*pi/2)", "i*exp(A)", "exp(A+i*3*pi)", "-exp(A)", "exp(A+i*7*pi/2)", "-i*exp(A)", "exp(A+i*4*pi)", "exp(A)", "exp(-i*pi/2)", "-i", "exp(-i*pi)", "-1", "exp(-i*3*pi/2)", "i", "exp(-i*2*pi)", "1", "exp(-i*5*pi/2)", "-i", "exp(-i*3*pi)", "-1", "exp(-i*7*pi/2)", "i", "exp(-i*4*pi)", "1", "exp(A-i*pi/2)", "-i*exp(A)", "exp(A-i*pi)", "-exp(A)", "exp(A-i*3*pi/2)", "i*exp(A)", "exp(A-i*2*pi)", "exp(A)", "exp(A-i*5*pi/2)", "-i*exp(A)", "exp(A-i*3*pi)", "-exp(A)", "exp(A-i*7*pi/2)", "i*exp(A)", "exp(A-i*4*pi)", "exp(A)"];


/*
test_power(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}
 */

print_str = function(s) {
  return console.log(s);
};

printline = function(p) {
  return print_expr(p);
};

print_expr = function(p) {
  var results;
  if (isadd(p)) {
    p = cdr(p);
    if (sign_of_term(car(p)) === '-') {
      print_str("-");
    }
    print_term(car(p));
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      if (sign_of_term(car(p)) === '+') {
        if (test_flag === 0) {
          print_str(" + ");
        } else {
          print_str("+");
        }
      } else {
        if (test_flag === 0) {
          print_str(" - ");
        } else {
          print_str("-");
        }
      }
      print_term(car(p));
      results.push(p = cdr(p));
    }
    return results;
  } else {
    if (sign_of_term(p) === '-') {
      print_str("-");
    }
    return print_term(p);
  }
};

sign_of_term = function(p) {
  if (car(p) === symbol(MULTIPLY) && isnum(cadr(p)) && lessp(cadr(p), zero)) {
    return '-';
  } else if (isnum(p) && lessp(p, zero)) {
    return '-';
  } else {
    return '+';
  }
};

print_term = function(p) {
  var results;
  if (car(p) === symbol(MULTIPLY) && any_denominators(p)) {
    print_a_over_b(p);
    return;
  }
  if (car(p) === symbol(MULTIPLY)) {
    p = cdr(p);
    if (isminusone(car(p))) {
      p = cdr(p);
    }
    print_factor(car(p));
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      print_multiply_sign();
      print_factor(car(p));
      results.push(p = cdr(p));
    }
    return results;
  } else {
    return print_factor(p);
  }
};

print_factor = function(p) {
  if (isnum(p)) {
    print_number(p);
    return;
  }
  if (isstr(p)) {
    print_str(p.str);
    return;
  }
  if (istensor(p)) {
    print_tensor(p);
    return;
  }
  if (isadd(p) || car(p) === symbol(MULTIPLY)) {
    print_str("(");
    print_expr(p);
    print_str(")");
    return;
  }
  if (car(p) === symbol(POWER)) {
    if (cadr(p) === symbol(E)) {
      print_str("exp(");
      print_expr(caddr(p));
      print_str(")");
      return;
    }
    if (isminusone(caddr(p))) {
      if (test_flag === 0) {
        print_str("1 / ");
      } else {
        print_str("1/");
      }
      if (iscons(cadr(p))) {
        print_str("(");
        print_expr(cadr(p));
        print_str(")");
      } else {
        print_expr(cadr(p));
      }
      return;
    }
    if (isadd(cadr(p)) || caadr(p) === symbol(MULTIPLY) || caadr(p) === symbol(POWER) || isnegativenumber(cadr(p))) {
      print_str("(");
      print_expr(cadr(p));
      print_str(")");
    } else if (isnum(cadr(p)) && (lessp(cadr(p), zero) || isfraction(cadr(p)))) {
      print_str("(");
      print_factor(cadr(p));
      print_str(")");
    } else {
      print_factor(cadr(p));
    }
    if (test_flag === 0) {
      print_str(power_str);
    } else {
      print_str("^");
    }
    if (iscons(caddr(p)) || isfraction(caddr(p)) || (isnum(caddr(p)) && lessp(caddr(p), zero))) {
      print_str("(");
      print_expr(caddr(p));
      print_str(")");
    } else {
      print_factor(caddr(p));
    }
    return;
  }
  if (car(p) === symbol(INDEX) && issymbol(cadr(p))) {
    print_index_function(p);
    return;
  }
  if (car(p) === symbol(FACTORIAL)) {
    print_factorial_function(p);
    return;
  }
  if (iscons(p)) {
    print_factor(car(p));
    p = cdr(p);
    print_str("(");
    if (iscons(p)) {
      print_expr(car(p));
      p = cdr(p);
      while (iscons(p)) {
        if (test_flag === 0) {
          print_str(",");
        } else {
          print_str(",");
        }
        print_expr(car(p));
        p = cdr(p);
      }
    }
    print_str(")");
    return;
  }
  if (p === symbol(DERIVATIVE)) {
    return print_char('d');
  } else if (p === symbol(E)) {
    return print_str("exp(1)");
  } else if (p === symbol(PI)) {
    return print_str("pi");
  } else {
    return print_str(get_printname(p));
  }
};

print1 = function(p, accumulator) {
  var topLevelCall;
  topLevelCall = false;
  if (accumulator == null) {
    topLevelCall = true;
    accumulator = "";
  }
  switch (p.k) {
    case CONS:
      accumulator += "(";
      accumulator = print1(car(p), accumulator);
      p = cdr(p);
      while (iscons(p)) {
        accumulator += " ";
        accumulator = print1(car(p), accumulator);
        p = cdr(p);
      }
      if (p !== symbol(NIL)) {
        accumulator += " . ";
        accumulator = print1(p, accumulator);
      }
      accumulator += ")";
      break;
    case STR:
      accumulator += p.str;
      break;
    case NUM:
    case DOUBLE:
      accumulator = print_number(p, accumulator);
      break;
    case SYM:
      accumulator += get_printname(p);
      break;
    default:
      accumulator += "<tensor>";
  }
  if (topLevelCall) {
    return console.log(accumulator);
  } else {
    return accumulator;
  }
};

print_multiply_sign = function() {
  if (test_flag === 0) {
    return print_str(" ");
  } else {
    return print_str("*");
  }
};

is_denominator = function(p) {
  if (car(p) === symbol(POWER) && cadr(p) !== symbol(E) && isnegativeterm(caddr(p))) {
    return 1;
  } else {
    return 0;
  }
};

any_denominators = function(p) {
  var q;
  p = cdr(p);
  while (iscons(p)) {
    q = car(p);
    if (is_denominator(q)) {
      return 1;
    }
    p = cdr(p);
  }
  return 0;
};

qadd = function() {
  var a, ab, b, ba, c;
  save();
  p2 = pop();
  p1 = pop();
  ab = mmul(p1.q.a, p2.q.b);
  ba = mmul(p1.q.b, p2.q.a);
  a = madd(ab, ba);
  if (MZERO(a)) {
    push(zero);
    restore();
    return;
  }
  b = mmul(p1.q.b, p2.q.b);
  c = mgcd(a, b);
  makeSignSameAs(c, b);
  p1 = new U();
  p1.k = NUM;
  p1.q.a = mdiv(a, c);
  p1.q.b = mdiv(b, c);
  push(p1);
  return restore();
};

qdiv = function() {
  var aa, bb, c;
  save();
  p2 = pop();
  p1 = pop();
  if (MZERO(p2.q.a)) {
    stop("divide by zero");
  }
  if (MZERO(p1.q.a)) {
    push(zero);
    restore();
    return;
  }
  aa = mmul(p1.q.a, p2.q.b);
  bb = mmul(p1.q.b, p2.q.a);
  c = mgcd(aa, bb);
  makeSignSameAs(c, bb);
  p1 = new U();
  p1.k = NUM;
  p1.q.a = mdiv(aa, c);
  p1.q.b = mdiv(bb, c);
  push(p1);
  return restore();
};

qmul = function() {
  var aa, bb, c;
  save();
  p2 = pop();
  p1 = pop();
  if (MZERO(p1.q.a) || MZERO(p2.q.a)) {
    push(zero);
    restore();
    return;
  }
  aa = mmul(p1.q.a, p2.q.a);
  bb = mmul(p1.q.b, p2.q.b);
  c = mgcd(aa, bb);
  makeSignSameAs(c, bb);
  p1 = new U();
  p1.k = NUM;
  p1.q.a = mdiv(aa, c);
  p1.q.b = mdiv(bb, c);
  push(p1);
  return restore();
};

qpow = function() {
  save();
  qpowf();
  return restore();
};

qpowf = function() {
  var a, b, expo, t, x, y;
  expo = 0;
  p2 = pop();
  p1 = pop();
  if (isplusone(p1) || iszero(p2)) {
    push_integer(1);
    return;
  }
  if (iszero(p1)) {
    if (isnegativenumber(p2)) {
      stop("divide by zero");
    }
    push(zero);
    return;
  }
  if (isplusone(p2)) {
    push(p1);
    return;
  }
  if (isinteger(p2)) {
    push(p2);
    expo = pop_integer();
    if (expo === 0x80000000) {
      push_symbol(POWER);
      push(p1);
      push(p2);
      list(3);
      return;
    }
    x = mpow(p1.q.a, Math.abs(expo));
    y = mpow(p1.q.b, Math.abs(expo));
    if (expo < 0) {
      t = x;
      x = y;
      y = t;
      makeSignSameAs(x, y);
      makePositive(y);
    }
    p3 = new U();
    p3.k = NUM;
    p3.q.a = x;
    p3.q.b = y;
    push(p3);
    return;
  }
  if (isminusone(p1)) {
    push(p2);
    normalize_angle();
    return;
  }
  if (isnegativenumber(p1)) {
    push(p1);
    negate();
    push(p2);
    qpow();
    push_integer(-1);
    push(p2);
    qpow();
    multiply();
    return;
  }
  if (!isinteger(p1)) {
    push(p1);
    mp_numerator();
    push(p2);
    qpow();
    push(p1);
    mp_denominator();
    push(p2);
    negate();
    qpow();
    multiply();
    return;
  }
  if (is_small_integer(p1)) {
    push(p1);
    push(p2);
    quickfactor();
    return;
  }
  if (!p2.q.a.isSmall || !p2.q.b.isSmall) {
    push_symbol(POWER);
    push(p1);
    push(p2);
    list(3);
    return;
  }
  a = p2.q.a[0];
  b = p2.q.b[0];
  x = mroot(p1.q.a, b);
  if (x === 0) {
    push_symbol(POWER);
    push(p1);
    push(p2);
    list(3);
    return;
  }
  y = mpow(x, a);
  p3 = new U();
  p3.k = NUM;
  if (p2.q.a.isNegative()) {
    p3.q.a = bigInt(1);
    p3.q.b = y;
  } else {
    p3.q.a = y;
    p3.q.b = bigInt(1);
  }
  return push(p3);
};

normalize_angle = function() {
  save();
  p1 = pop();
  if (isinteger(p1)) {
    if (p1.q.a[0] & 1) {
      push_integer(-1);
    } else {
      push_integer(1);
    }
    restore();
    return;
  }
  push(p1);
  bignum_truncate();
  p2 = pop();
  if (isnegativenumber(p1)) {
    push(p2);
    push_integer(-1);
    add();
    p2 = pop();
  }
  push(p1);
  push(p2);
  subtract();
  p3 = pop();
  push_symbol(POWER);
  push_integer(-1);
  push(p3);
  list(3);
  if (p2.q.a[0] & 1) {
    negate();
  }
  return restore();
};

is_small_integer = function(p) {
  return p.q.a.isSmall;
};

quickfactor = function() {
  var ac, h, i, n, ref1;
  save();
  p2 = pop();
  p1 = pop();
  h = tos;
  push(p1);
  factor_small_number();
  n = tos - h;
  s = h;
  for (i = ac = 0, ref1 = n; ac < ref1; i = ac += 2) {
    push(stack[s + i]);
    push(stack[s + i + 1]);
    push(p2);
    multiply();
    quickpower();
  }
  multiply_all(tos - h - n);
  p1 = pop();
  tos = h;
  push(p1);
  return restore();
};

quickpower = function() {
  var expo;
  expo = 0;
  save();
  p2 = pop();
  p1 = pop();
  push(p2);
  bignum_truncate();
  p3 = pop();
  push(p2);
  push(p3);
  subtract();
  p4 = pop();
  if (!iszero(p4)) {
    push_symbol(POWER);
    push(p1);
    push(p4);
    list(3);
  }
  push(p3);
  expo = pop_integer();
  if (expo === 0x80000000) {
    push_symbol(POWER);
    push(p1);
    push(p3);
    list(3);
    restore();
    return;
  }
  if (expo === 0) {
    restore();
    return;
  }
  push(p1);
  bignum_power_number(expo);
  return restore();
};

test_quickfactor = function() {
  var ac, base, expo, h, i, j;
  i = 0;
  logout("testing quickfactor\n");
  for (i = ac = 2; ac < 10001; i = ++ac) {
    base = i;
    push_integer(base);
    push_integer(1);
    quickfactor();
    h = tos;
    j = 0;
    while (base > 1) {
      expo = 0;
      while (base % primetab[j] === 0) {
        base /= primetab[j];
        expo++;
      }
      if (expo) {
        push_integer(primetab[j]);
        push_integer(expo);
        quickpower();
      }
      j++;
    }
    multiply_all(tos - h);
    p2 = pop();
    p1 = pop();
    if (!equal(p1, p2)) {
      logout("failed\n");
      print_lisp(p1);
      print_lisp(p2);
      errout();
    }
  }
  return logout("ok\n");
};

DEBUG = 0;

Eval_rationalize = function() {
  push(cadr(p1));
  Eval();
  return rationalize();
};

rationalize = function() {
  var x;
  x = expanding;
  save();
  yyrationalize();
  restore();
  return expanding = x;
};

yyrationalize = function() {
  p1 = pop();
  if (istensor(p1)) {
    __rationalize_tensor();
    return;
  }
  expanding = 0;
  if (car(p1) !== symbol(ADD)) {
    push(p1);
    return;
  }
  if (DEBUG) {
    printf("rationalize: this is the input expr:\n");
    printline(p1);
  }
  push(one);
  multiply_denominators(p1);
  p2 = pop();
  if (DEBUG) {
    printf("rationalize: this is the common denominator:\n");
    printline(p2);
  }
  push(zero);
  p3 = cdr(p1);
  while (iscons(p3)) {
    push(p2);
    push(car(p3));
    multiply();
    add();
    p3 = cdr(p3);
  }
  if (DEBUG) {
    printf("rationalize: original expr times common denominator:\n");
    printline(stack[tos - 1]);
  }
  Condense();
  if (DEBUG) {
    printf("rationalize: after factoring:\n");
    printline(stack[tos - 1]);
  }
  push(p2);
  divide();
  if (DEBUG) {
    printf("rationalize: after dividing by common denom. (and we're done):\n");
    return printline(stack[tos - 1]);
  }
};

multiply_denominators = function(p) {
  var results;
  if (car(p) === symbol(ADD)) {
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      multiply_denominators_term(car(p));
      results.push(p = cdr(p));
    }
    return results;
  } else {
    return multiply_denominators_term(p);
  }
};

multiply_denominators_term = function(p) {
  var results;
  if (car(p) === symbol(MULTIPLY)) {
    p = cdr(p);
    results = [];
    while (iscons(p)) {
      multiply_denominators_factor(car(p));
      results.push(p = cdr(p));
    }
    return results;
  } else {
    return multiply_denominators_factor(p);
  }
};

multiply_denominators_factor = function(p) {
  if (car(p) !== symbol(POWER)) {
    return;
  }
  push(p);
  p = caddr(p);
  if (isnegativenumber(p)) {
    inverse();
    __lcm();
    return;
  }
  if (car(p) === symbol(MULTIPLY) && isnegativenumber(cadr(p))) {
    inverse();
    __lcm();
    return;
  }
  return pop();
};

__rationalize_tensor = function() {
  var ac, i, n, ref1;
  i = 0;
  push(p1);
  Eval();
  p1 = pop();
  if (!istensor(p1)) {
    push(p1);
    return;
  }
  n = p1.tensor.nelem;
  for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    push(p1.tensor.elem[i]);
    rationalize();
    p1.tensor.elem[i] = pop();
  }
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  return push(p1);
};

s = ["rationalize(a/b+c/d)", "(a*d+b*c)/(b*d)", "rationalize(t*y/(t+y)+2*t^2*y*(2*t+y)^(-2))", "t*y*(6*t^2+y^2+6*t*y)/((t+y)*(2*t+y)^2)", "rationalize(x^(-2*a)+x^(-4*a))", "(1+x^(2*a))/(x^(4*a))", "rationalize(x^(1/3)+x^(2/3))", "x^(1/3)*(1+x^(1/3))"];


/*
void
test_rationalize(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}

#endif
 */

__lcm = function() {
  save();
  p1 = pop();
  p2 = pop();
  push(p1);
  push(p2);
  multiply();
  push(p1);
  push(p2);
  gcd();
  divide();
  return restore();
};

stop = function(s) {
  debugger;
  console.log("Stop: ");
  console.log(s);
  return console.log("\n");
};

inited = false;

run = function(stringToBeRun) {
  var i, indexOfPartRemainingToBeParsed, n, results;
  stringToBeRun = stringToBeRun;
  if (stringToBeRun === "selftest") {
    selftest();
    return;
  }
  if (!inited) {
    inited = true;
    init();
  }
  i = 0;
  n = 0;
  indexOfPartRemainingToBeParsed = 0;
  results = [];
  while (1.) {
    n = scan(stringToBeRun.substring(indexOfPartRemainingToBeParsed));
    p1 = pop();
    check_stack();
    if (n === 0) {
      break;
    }
    indexOfPartRemainingToBeParsed += n;
    push(p1);
    top_level_eval();
    p2 = pop();
    check_stack();
    if (p2 === symbol(NIL)) {
      continue;
    }
    if (isstr(p2)) {
      console.log(p2.str);
      console.log("\n");
      continue;
    }
    results.push(display(p2));
  }
  return results;
};

check_stack = function() {
  if (tos !== 0) {
    stop("stack error");
  }
  if (frame !== TOS) {
    return stop("frame error");
  }
};

echo_input = function(s) {
  console.log(s);
  return console.log("\n");
};

top_level_eval = function() {
  var doNothing;
  console.log("#### top level eval");
  save();
  trigmode = 0;
  p1 = symbol(AUTOEXPAND);
  if (iszero(get_binding(p1))) {
    expanding = 0;
  } else {
    expanding = 1;
  }
  p1 = pop();
  push(p1);
  Eval();
  p2 = pop();
  if (p2 === symbol(NIL)) {
    push(p2);
    restore();
    return;
  }
  set_binding(symbol(LAST), p2);
  if (!iszero(get_binding(symbol(BAKE)))) {
    push(p2);
    bake();
    p2 = pop();
  }
  if ((p1 === symbol(SYMBOL_I) || p1 === symbol(SYMBOL_J)) && isimaginaryunit(p2)) {
    doNothing = 0;
  } else if (isimaginaryunit(get_binding(symbol(SYMBOL_J)))) {
    push(p2);
    push(imaginaryunit);
    push_symbol(SYMBOL_J);
    subst();
    p2 = pop();
  } else if (isimaginaryunit(get_binding(symbol(SYMBOL_I)))) {
    push(p2);
    push(imaginaryunit);
    push_symbol(SYMBOL_I);
    subst();
    p2 = pop();
  }
  push(p2);
  return restore();
};

check_esc_flag = function() {
  if (esc_flag) {
    return stop("esc key");
  }
};

T_INTEGER = 1001;

T_DOUBLE = 1002;

T_SYMBOL = 1003;

T_FUNCTION = 1004;

T_NEWLINE = 1006;

T_STRING = 1007;

T_GTEQ = 1008;

T_LTEQ = 1009;

T_EQ = 1010;

token = "";

newline_flag = 0;

meta_mode = 0;

input_str = 0;

scan_str = 0;

token_str = 0;

token_buf = 0;

scanned = "";

scan = function(s) {
  console.log("#### scanning " + s);
  scanned = s;
  meta_mode = 0;
  expanding++;
  input_str = 0;
  scan_str = 0;
  get_next_token();
  if (token === "") {
    push(symbol(NIL));
    expanding--;
    return 0;
  }
  scan_stmt();
  expanding--;
  return token_str - input_str;
};

scan_meta = function(s) {
  meta_mode = 1;
  expanding++;
  input_str = 0;
  scan_str = 0;
  get_next_token();
  if (token === "") {
    push(symbol(NIL));
    expanding--;
    return 0;
  }
  scan_stmt();
  expanding--;
  return token_str - input_str;
};

scan_stmt = function() {
  scan_relation();
  if (token === '=') {
    get_next_token();
    push_symbol(SETQ);
    swap();
    scan_relation();
    return list(3);
  }
};

scan_relation = function() {
  scan_expression();
  switch (token) {
    case T_EQ:
      push_symbol(TESTEQ);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
    case T_LTEQ:
      push_symbol(TESTLE);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
    case T_GTEQ:
      push_symbol(TESTGE);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
    case '<':
      push_symbol(TESTLT);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
    case '>':
      push_symbol(TESTGT);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
  }
};

scan_expression = function() {
  var h;
  h = tos;
  switch (token) {
    case '+':
      get_next_token();
      scan_term();
      break;
    case '-':
      get_next_token();
      scan_term();
      negate();
      break;
    default:
      scan_term();
  }
  while (newline_flag === 0 && (token === '+' || token === '-')) {
    if (token === '+') {
      get_next_token();
      scan_term();
    } else {
      get_next_token();
      scan_term();
      negate();
    }
  }
  if (tos - h > 1) {
    list(tos - h);
    push_symbol(ADD);
    swap();
    return cons();
  }
};

is_factor = function() {
  switch (token) {
    case '*':
    case '/':
      return 1;
    case '(':
    case T_SYMBOL:
    case T_FUNCTION:
    case T_INTEGER:
    case T_DOUBLE:
    case T_STRING:
      if (newline_flag) {
        scan_str = token_str;
        return 0;
      } else {
        return 1;
      }
  }
  return 0;
};

scan_term = function() {
  var h;
  h = tos;
  scan_power();
  if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {
    pop();
  }
  while (is_factor()) {
    if (token === '*') {
      get_next_token();
      scan_power();
    } else if (token === '/') {
      get_next_token();
      scan_power();
      inverse();
    } else {
      scan_power();
    }
    if (tos > h + 1 && isnum(stack[tos - 2]) && isnum(stack[tos - 1])) {
      multiply();
    }
    if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {
      pop();
    }
  }
  if (h === tos) {
    return push_integer(1);
  } else if (tos - h > 1) {
    list(tos - h);
    push_symbol(MULTIPLY);
    swap();
    return cons();
  }
};

scan_power = function() {
  scan_factor();
  if (token === '^') {
    get_next_token();
    push_symbol(POWER);
    swap();
    scan_power();
    return list(3);
  }
};

scan_factor = function() {
  var h, results;
  h = tos;
  if (token === '(') {
    scan_subexpr();
  } else if (token === T_SYMBOL) {
    scan_symbol();
  } else if (token === T_FUNCTION) {
    scan_function_call();
  } else if (token === T_INTEGER) {
    bignum_scan_integer(token_buf);
    get_next_token();
  } else if (token === T_DOUBLE) {
    bignum_scan_float(token_buf);
    get_next_token();
  } else if (token === T_STRING) {
    scan_string();
  } else {
    error("syntax error");
  }
  if (token === '[') {
    get_next_token();
    push_symbol(INDEX);
    swap();
    scan_expression();
    while (token === ',') {
      get_next_token();
      scan_expression();
    }
    if (token !== ']') {
      error("] expected");
    }
    get_next_token();
    list(tos - h);
  }
  results = [];
  while (token === '!') {
    get_next_token();
    push_symbol(FACTORIAL);
    swap();
    results.push(list(2));
  }
  return results;
};

scan_symbol = function() {
  if (token !== T_SYMBOL) {
    error("symbol expected");
  }
  if (meta_mode && strlen(token_buf) === 1) {
    switch (token_buf[0]) {
      case 'a':
        push(symbol(METAA));
        break;
      case 'b':
        push(symbol(METAB));
        break;
      case 'x':
        push(symbol(METAX));
        break;
      default:
        push(usr_symbol(token_buf));
    }
  } else {
    push(usr_symbol(token_buf));
  }
  return get_next_token();
};

scan_string = function() {
  new_string(token_buf);
  return get_next_token();
};

scan_function_call = function() {
  var n, p;
  n = 1;
  p = new U();
  p = usr_symbol(token_buf);
  push(p);
  get_next_token();
  get_next_token();
  if (token !== ')') {
    scan_stmt();
    n++;
    while (token === ',') {
      get_next_token();
      scan_stmt();
      n++;
    }
  }
  if (token !== ')') {
    error(") expected");
  }
  get_next_token();
  return list(n);
};

scan_subexpr = function() {
  var n;
  n = 0;
  if (token !== '(') {
    error("( expected");
  }
  get_next_token();
  scan_stmt();
  if (token === ',') {
    n = 1;
    while (token === ',') {
      get_next_token();
      scan_stmt();
      n++;
    }
    build_tensor(n);
  }
  if (token !== ')') {
    error(") expected");
  }
  return get_next_token();
};

error = function(errmsg) {
  console.log('\n');
  while (input_str !== scan_str) {
    if ((scanned[input_str] === '\n' || scanned[input_str] === '\r') && input_str + 1 === scan_str) {
      break;
    }
    console.log(scanned[input_str++]);
  }
  console.log(" ? ");
  while (scanned[input_str] && (scanned[input_str] !== '\n' && scanned[input_str] !== '\r')) {
    console.log(scanned[input_str]);
  }
  console.log('\n');
  return stop(errmsg);
};

build_tensor = function(n) {
  var ac, i, ref1;
  i = 0;
  save();
  p2 = alloc_tensor(n);
  p2.tensor.ndim = 1;
  p2.tensor.dim[0] = n;
  for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    p2.tensor.elem[i] = stack[tos - n + i];
  }
  if (p2.tensor.nelem !== p2.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  tos -= n;
  push(p2);
  return restore();
};

get_next_token = function() {
  newline_flag = 0;
  while (1.) {
    get_token();
    if (token !== T_NEWLINE) {
      break;
    }
    newline_flag = 1;
  }
  return console.log("get_next_token token: " + token);
};

get_token = function() {
  while (isspace(scanned[scan_str])) {
    if (scanned[scan_str] === '\n' || scanned[scan_str] === '\r') {
      token = T_NEWLINE;
      scan_str++;
      return;
    }
    scan_str++;
  }
  token_str = scan_str;
  if (scan_str === scanned.length) {
    token = "";
    return;
  }
  if (isdigit(scanned[scan_str]) || scanned[scan_str] === '.') {
    while (isdigit(scanned[scan_str])) {
      scan_str++;
    }
    if (scanned[scan_str] === '.') {
      scan_str++;
      while (isdigit(scanned[scan_str])) {
        scan_str++;
      }
      if (scanned[scan_str] === 'e' && (scan_str[1] === '+' || scan_str[1] === '-' || isdigit(scan_str[1]))) {
        scan_str += 2;
        while (isdigit(scanned[scan_str])) {
          scan_str++;
        }
      }
      token = T_DOUBLE;
    } else {
      token = T_INTEGER;
    }
    update_token_buf(token_str, scan_str);
    return;
  }
  if (isalpha(scanned[scan_str])) {
    while (isalnum(scanned[scan_str])) {
      scan_str++;
    }
    if (scanned[scan_str] === '(') {
      token = T_FUNCTION;
    } else {
      token = T_SYMBOL;
    }
    update_token_buf(token_str, scan_str);
    return;
  }
  if (scanned[scan_str] === '"') {
    scan_str++;
    while (scanned[scan_str] !== '"') {
      if (scan_str === scanned.length || scanned[scan_str] === '\n' || scanned[scan_str] === '\r') {
        error("runaway string");
      }
      scan_str++;
    }
    scan_str++;
    token = T_STRING;
    update_token_buf(token_str + 1, scan_str - 1);
    return;
  }
  if (scanned[scan_str] === '#' || scanned[scan_str] === '-' && scan_str[1] === '-') {
    while (scanned[scan_str] && scanned[scan_str] !== '\n' && scanned[scan_str] !== '\r') {
      scan_str++;
    }
    if (scanned[scan_str]) {
      scan_str++;
    }
    token = T_NEWLINE;
    return;
  }
  if (scanned[scan_str] === '=' && scan_str[1] === '=') {
    scan_str += 2;
    token = T_EQ;
    return;
  }
  if (scanned[scan_str] === '<' && scan_str[1] === '=') {
    scan_str += 2;
    token = T_LTEQ;
    return;
  }
  if (scanned[scan_str] === '>' && scan_str[1] === '=') {
    scan_str += 2;
    token = T_GTEQ;
    return;
  }
  return token = scanned[scan_str++];
};

update_token_buf = function(a, b) {
  return token_buf = scanned.substring(a, b);
};

testString = ["a^^b", "a^^ ? b\nStop: syntax error", "(a+b", "(a+b ? \nStop: ) expected", "quote(1/(x*log(a*x)))", "1/(x*log(a*x))", "\"hello", "\"hello ? \nStop: runaway string", "a+\nb+\nc+", "a+\nb+\nc+ ? \nStop: syntax error", "2+2\n(3+3)", "4\n6", "1\n-1", "1\n-1", "1\n+1", "1\n1"];

test_scan = function() {
  var a;
  return a = 0;
};

selftest = function() {
  test_low_level();
  test_multiply();
  test_scan();
  test_power();
  test_factor_number();
  test_test();
  test_tensor();
  test_bake();
  test_abs();
  test_adj();
  test_arg();
  test_besselj();
  test_bessely();
  test_ceiling();
  test_choose();
  test_circexp();
  test_clock();
  test_cofactor();
  test_condense();
  test_contract();
  test_defint();
  test_denominator();
  test_derivative();
  test_dirac();
  test_erf();
  test_erfc();
  test_expand();
  test_expcos();
  test_expsin();
  test_factorpoly();
  test_float();
  test_floor();
  test_gamma();
  test_gcd();
  test_imag();
  test_inner();
  test_lcm();
  test_log();
  test_mag();
  test_mod();
  test_nroots();
  test_numerator();
  test_outer();
  test_polar();
  test_quotient();
  test_rationalize();
  test_real();
  test_rect();
  test_sgn();
  test_taylor();
  test_transpose();
  test_zero();
  test_hermite();
  test_laguerre();
  test_legendre();
  test_binomial();
  test_divisors();
  test_coeff();
  test_sin();
  test_cos();
  test_tan();
  test_sinh();
  test_cosh();
  test_tanh();
  test_arcsin();
  test_arcsinh();
  test_arccos();
  test_arccosh();
  test_arctan();
  test_arctanh();
  test_index();
  test_isprime();
  test_integral();
  test_simplify();
  test_roots();
  test_eigen();
  mini_test();
  return console.log("OK, all tests passed.");
};

logout = function(s) {
  return console.log(s);
};

test = function(s) {
  var ac, i, ref1, resultFromRun, t;
  i = 0;
  t = "";
  test_flag = 1;
  run("clear");
  run("e=quote(e)");
  for (i = ac = 0, ref1 = s.length / 2; ac < ref1; i = ac += 2) {
    console.log(s[i]);
    if (s[i][0] === '#') {
      continue;
    }
    out_count = 0;
    resultFromRun = run(s[i]);
    if (resultFromRun === s[i + 1]) {
      continue;
    }
    console.log("expected to get the following result:\n");
    console.log(s[i + 1]);
    console.log("got this result instead:\n");
    console.log(resultFromRun);
  }
  return test_flag = 0;
};

test_low_level = function() {
  run("clear");
  test_madd();
  test_msub();
  test_mmul();
  test_mdiv();
  test_mmod();
  test_mprime();
  test_mgcd();
  test_mpow();
  test_mroot();
  return test_quickfactor();
};

Eval_simplify = function() {
  push(cadr(p1));
  Eval();
  return simplify();
};

simplify = function() {
  save();
  simplify_main();
  return restore();
};

simplify_main = function() {
  debugger;
  p1 = pop();
  if (istensor(p1)) {
    simplify_tensor();
    return;
  }
  if (Find(p1, symbol(FACTORIAL))) {
    push(p1);
    simfac();
    p2 = pop();
    push(p1);
    rationalize();
    simfac();
    p3 = pop();
    if (count(p2) < count(p3)) {
      p1 = p2;
    } else {
      p1 = p3;
    }
  }
  f1();
  f2();
  f3();
  f4();
  f5();
  f9();
  return push(p1);
};

simplify_tensor = function() {
  var ac, ad, i, ref1, ref2;
  i = 0;
  p2 = alloc_tensor(p1.tensor.nelem);
  p2.tensor.ndim = p1.tensor.ndim;
  for (i = ac = 0, ref1 = p1.tensor.ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    p2.tensor.dim[i] = p1.tensor.dim[i];
  }
  for (i = ad = 0, ref2 = p1.tensor.nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
    push(p1.tensor.elem[i]);
    simplify();
    p2.tensor.elem[i] = pop();
  }
  if (p2.tensor.nelem !== p2.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  if (iszero(p2)) {
    p2 = zero;
  }
  return push(p2);
};

count = function(p) {
  var n;
  if (iscons(p)) {
    n = 0;
    while (iscons(p)) {
      n += count(car(p)) + 1;
      p = cdr(p);
    }
  } else {
    n = 1;
  }
  return n;
};

f1 = function() {
  if (car(p1) !== symbol(ADD)) {
    return;
  }
  push(p1);
  rationalize();
  p2 = pop();
  if (count(p2) < count(p1)) {
    return p1 = p2;
  }
};

f2 = function() {
  if (car(p1) !== symbol(ADD)) {
    return;
  }
  push(p1);
  Condense();
  p2 = pop();
  if (count(p2) <= count(p1)) {
    return p1 = p2;
  }
};

f3 = function() {
  push(p1);
  rationalize();
  negate();
  rationalize();
  negate();
  rationalize();
  p2 = pop();
  if (count(p2) < count(p1)) {
    return p1 = p2;
  }
};

f4 = function() {
  if (iszero(p1)) {
    return;
  }
  push(p1);
  rationalize();
  inverse();
  rationalize();
  inverse();
  rationalize();
  p2 = pop();
  if (count(p2) < count(p1)) {
    return p1 = p2;
  }
};

simplify_trig = function() {
  save();
  p1 = pop();
  f5();
  push(p1);
  return restore();
};

f5 = function() {
  if (Find(p1, symbol(SIN)) === 0 && Find(p1, symbol(COS)) === 0) {
    return;
  }
  p2 = p1;
  trigmode = 1;
  push(p2);
  Eval();
  p3 = pop();
  trigmode = 2;
  push(p2);
  Eval();
  p4 = pop();
  trigmode = 0;
  if (count(p4) < count(p3) || nterms(p4) < nterms(p3)) {
    p3 = p4;
  }
  if (count(p3) < count(p1) || nterms(p3) < nterms(p1)) {
    return p1 = p3;
  }
};

f9 = function() {
  if (car(p1) !== symbol(ADD)) {
    return;
  }
  push_integer(0);
  p2 = cdr(p1);
  while (iscons(p2)) {
    push(car(p2));
    simplify();
    add();
    p2 = cdr(p2);
  }
  p2 = pop();
  if (count(p2) < count(p1)) {
    return p1 = p2;
  }
};

nterms = function(p) {
  if (car(p) !== symbol(ADD)) {
    return 1;
  } else {
    return length(p) - 1;
  }
};

s = ["simplify(A)", "A", "simplify(A+B)", "A+B", "simplify(A B)", "A*B", "simplify(A^B)", "A^B", "simplify(A/(A+B)+B/(A+B))", "1", "simplify((A-B)/(B-A))", "-1", "A=((A11,A12),(A21,A22))", "", "simplify(det(A) inv(A) - adj(A))", "0", "A=quote(A)", "", "simplify(-3 exp(-1/3 r + i phi) cos(theta) / sin(theta)", " + 3 exp(-1/3 r + i phi) cos(theta) sin(theta)", " + 3 exp(-1/3 r + i phi) cos(theta)^3 / sin(theta))", "0", "simplify((A^2 C^2 + A^2 D^2 + B^2 C^2 + B^2 D^2)/(A^2+B^2)/(C^2+D^2))", "1", "simplify(d(arctan(y/x),y))", "x/(x^2+y^2)", "simplify(d(arctan(y/x),x))", "-y/(x^2+y^2)", "simplify(1-sin(x)^2)", "cos(x)^2", "simplify(1-cos(x)^2)", "sin(x)^2", "simplify(sin(x)^2-1)", "-cos(x)^2", "simplify(cos(x)^2-1)", "-sin(x)^2", "simplify(n!/n)-(n-1)!", "0", "simplify(n/n!)-1/(n-1)!", "0", "simplify(rationalize((n+k+1)/(n+k+1)!))-1/(n+k)!", "0", "simplify(condense((n+1)*n!))-(n+1)!", "0", "simplify(1/((n+1)*n!))-1/(n+1)!", "0", "simplify((n+1)!/n!)-n-1", "0", "simplify(n!/(n+1)!)-1/(n+1)", "0", "simplify(binomial(n+1,k)/binomial(n,k))", "(1+n)/(1-k+n)", "simplify(binomial(n,k)/binomial(n+1,k))", "(1-k+n)/(1+n)", "F(nn,kk)=kk*binomial(nn,kk)", "", "simplify((F(n,k)+F(n,k-1))/F(n+1,k))-n/(n+1)", "0", "F=quote(F)", "", "simplify((n+1)/(n+1)!)-1/n!", "0", "simplify(a*b+a*c)", "a*(b+c)", "x=simplify(a*b+a*c)", "", "x", "a*b+a*c"];


/*
void
test_simplify(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}

#endif
 */

Eval_sin = function() {
  push(cadr(p1));
  Eval();
  return sine();
};

sine = function() {
  save();
  p1 = pop();
  if (car(p1) === symbol(ADD)) {
    sine_of_angle_sum();
  } else {
    sine_of_angle();
  }
  return restore();
};

sine_of_angle_sum = function() {
  p2 = cdr(p1);
  while (iscons(p2)) {
    p4 = car(p2);
    if (isnpi(p4)) {
      push(p1);
      push(p4);
      subtract();
      p3 = pop();
      push(p3);
      sine();
      push(p4);
      cosine();
      multiply();
      push(p3);
      cosine();
      push(p4);
      sine();
      multiply();
      add();
      return;
    }
    p2 = cdr(p2);
  }
  return sine_of_angle();
};

sine_of_angle = function() {
  var d, n;
  if (car(p1) === symbol(ARCSIN)) {
    push(cadr(p1));
    return;
  }
  if (isdouble(p1)) {
    d = sin(p1.d);
    if (fabs(d) < 1e-10) {
      d = 0.0;
    }
    push_double(d);
    return;
  }
  if (isnegative(p1)) {
    push(p1);
    negate();
    sine();
    negate();
    return;
  }
  if (car(p1) === symbol(ARCTAN)) {
    push(cadr(p1));
    push_integer(1);
    push(cadr(p1));
    push_integer(2);
    power();
    add();
    push_rational(-1, 2);
    power();
    multiply();
    return;
  }
  push(p1);
  push_integer(180);
  multiply();
  push_symbol(PI);
  divide();
  n = pop_integer();
  if (n < 0) {
    push(symbol(SIN));
    push(p1);
    list(2);
    return;
  }
  switch (n % 360) {
    case 0:
    case 180:
      return push_integer(0);
    case 30:
    case 150:
      return push_rational(1, 2);
    case 210:
    case 330:
      return push_rational(-1, 2);
    case 45:
    case 135:
      push_rational(1, 2);
      push_integer(2);
      push_rational(1, 2);
      power();
      return multiply();
    case 225:
    case 315:
      push_rational(-1, 2);
      push_integer(2);
      push_rational(1, 2);
      power();
      return multiply();
    case 60:
    case 120:
      push_rational(1, 2);
      push_integer(3);
      push_rational(1, 2);
      power();
      return multiply();
    case 240:
    case 300:
      push_rational(-1, 2);
      push_integer(3);
      push_rational(1, 2);
      power();
      return multiply();
    case 90:
      return push_integer(1);
    case 270:
      return push_integer(-1);
    default:
      push(symbol(SIN));
      push(p1);
      return list(2);
  }
};

s = ["sin(x)", "sin(x)", "sin(-x)", "-sin(x)", "sin(b-a)", "-sin(a-b)", "f(a,x)=1+sin(float(a/360*2*pi))-float(x)+sin(a/360*2*pi)-x", "", "f(0,0)", "1", "f(90,1)", "1", "f(180,0)", "1", "f(270,-1)", "1", "f(360,0)", "1", "f(-90,-1)", "1", "f(-180,0)", "1", "f(-270,1)", "1", "f(-360,0)", "1", "f(45,sqrt(2)/2)", "1", "f(135,sqrt(2)/2)", "1", "f(225,-sqrt(2)/2)", "1", "f(315,-sqrt(2)/2)", "1", "f(-45,-sqrt(2)/2)", "1", "f(-135,-sqrt(2)/2)", "1", "f(-225,sqrt(2)/2)", "1", "f(-315,sqrt(2)/2)", "1", "f(30,1/2)", "1", "f(150,1/2)", "1", "f(210,-1/2)", "1", "f(330,-1/2)", "1", "f(-30,-1/2)", "1", "f(-150,-1/2)", "1", "f(-210,1/2)", "1", "f(-330,1/2)", "1", "f(60,sqrt(3)/2)", "1", "f(120,sqrt(3)/2)", "1", "f(240,-sqrt(3)/2)", "1", "f(300,-sqrt(3)/2)", "1", "f(-60,-sqrt(3)/2)", "1", "f(-120,-sqrt(3)/2)", "1", "f(-240,sqrt(3)/2)", "1", "f(-300,sqrt(3)/2)", "1", "f=quote(f)", "", "sin(arcsin(x))", "x", "sin(1/12*pi)", "sin(1/12*pi)", "sin(arctan(4/3))", "4/5", "sin(-arctan(4/3))", "-4/5", "sin(x-8/2*pi)", "sin(x)", "sin(x-7/2*pi)", "cos(x)", "sin(x-6/2*pi)", "-sin(x)", "sin(x-5/2*pi)", "-cos(x)", "sin(x-4/2*pi)", "sin(x)", "sin(x-3/2*pi)", "cos(x)", "sin(x-2/2*pi)", "-sin(x)", "sin(x-1/2*pi)", "-cos(x)", "sin(x+0/2*pi)", "sin(x)", "sin(x+1/2*pi)", "cos(x)", "sin(x+2/2*pi)", "-sin(x)", "sin(x+3/2*pi)", "-cos(x)", "sin(x+4/2*pi)", "sin(x)", "sin(x+5/2*pi)", "cos(x)", "sin(x+6/2*pi)", "-sin(x)", "sin(x+7/2*pi)", "-cos(x)", "sin(x+8/2*pi)", "sin(x)"];


/*

void
test_sin(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}

#endif
 */

tos = 0;

push = function(p) {
  if (p == null) {
    debugger;
  }
  if (tos >= frame) {
    stop("stack overflow");
  }
  return stack[tos++] = p;
};

pop = function() {
  var elementToBeReturned;
  if (tos === 0) {
    debugger;
    stop("stack underflow");
  }
  if (stack[tos - 1] == null) {
    debugger;
  }
  elementToBeReturned = stack[--tos];
  return elementToBeReturned;
};

push_frame = function(n) {
  var ac, i, ref1, results;
  i = 0;
  frame -= n;
  if (frame < tos) {
    debugger;
    stop("frame overflow, circular reference?");
  }
  results = [];
  for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    results.push(stack[frame + i] = symbol(NIL));
  }
  return results;
};

pop_frame = function(n) {
  frame += n;
  if (frame > TOS) {
    return stop("frame underflow");
  }
};

save = function() {
  frame -= 10;
  if (frame < tos) {
    debugger;
    stop("frame overflow, circular reference?");
  }
  stack[frame + 0] = p0;
  stack[frame + 1] = p1;
  stack[frame + 2] = p2;
  stack[frame + 3] = p3;
  stack[frame + 4] = p4;
  stack[frame + 5] = p5;
  stack[frame + 6] = p6;
  stack[frame + 7] = p7;
  stack[frame + 8] = p8;
  return stack[frame + 9] = p9;
};

restore = function() {
  if (frame > TOS - 10) {
    stop("frame underflow");
  }
  p0 = stack[frame + 0];
  p1 = stack[frame + 1];
  p2 = stack[frame + 2];
  p3 = stack[frame + 3];
  p4 = stack[frame + 4];
  p5 = stack[frame + 5];
  p6 = stack[frame + 6];
  p7 = stack[frame + 7];
  p8 = stack[frame + 8];
  p9 = stack[frame + 9];
  return frame += 10;
};

swap = function() {
  var p, q;
  p = pop();
  q = pop();
  push(p);
  return push(q);
};

dupl = function() {
  var p;
  p = pop();
  push(p);
  return push(p);
};


/*
	Substitute new expr for old expr in expr.

	Input:	push	expr

		push	old expr

		push	new expr

	Output:	Result on stack
 */

subst = function() {
  var ac, ad, i, ref1, ref2;
  i = 0;
  save();
  p3 = pop();
  p2 = pop();
  if (p2 === symbol(NIL) || p3 === symbol(NIL)) {
    restore();
    return;
  }
  p1 = pop();
  if (istensor(p1)) {
    p4 = alloc_tensor(p1.tensor.nelem);
    p4.tensor.ndim = p1.tensor.ndim;
    for (i = ac = 0, ref1 = p1.tensor.ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      p4.tensor.dim[i] = p1.tensor.dim[i];
    }
    for (i = ad = 0, ref2 = p1.tensor.nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
      push(p1.tensor.elem[i]);
      push(p2);
      push(p3);
      subst();
      p4.tensor.elem[i] = pop();
      if (p4.tensor.nelem !== p4.tensor.elem.length) {
        console.log("something wrong in tensor dimensions");
        debugger;
      }
    }
    push(p4);
  } else if (equal(p1, p2)) {
    push(p3);
  } else if (iscons(p1)) {
    push(car(p1));
    push(p2);
    push(p3);
    subst();
    push(cdr(p1));
    push(p2);
    push(p3);
    subst();
    cons();
  } else {
    push(p1);
  }
  return restore();
};

std_symbol = function(s, n) {
  var p;
  p = symtab[n];
  if (p == null) {
    debugger;
  }
  return p.printname = s;
};

usr_symbol = function(s) {
  var ac, i, p, ref1;
  i = 0;
  for (i = ac = 0, ref1 = NSYM; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    if (symtab[i].printname === "") {
      break;
    }
    if (s === symtab[i].printname) {
      return symtab[i];
    }
  }
  if (i === NSYM) {
    stop("symbol table overflow");
  }
  p = symtab[i];
  p.printname = s;
  return p;
};

get_printname = function(p) {
  if (p.k !== SYM) {
    stop("symbol error");
  }
  return p.printname;
};

set_binding = function(p, q) {
  var indexFound;
  if (p.k !== SYM) {
    stop("symbol error");
  }
  indexFound = symtab.indexOf(p);
  if (symtab.indexOf(p, indexFound + 1) !== -1) {
    console.log("ops, more than one element!");
  }
  console.log("lookup >> set_binding lookup " + indexFound);
  binding[indexFound] = q;
  return arglist[indexFound] = symbol(NIL);
};

get_binding = function(p) {
  var indexFound;
  if (p.k !== SYM) {
    stop("symbol error");
  }
  indexFound = symtab.indexOf(p);
  if (symtab.indexOf(p, indexFound + 1) !== -1) {
    console.log("ops, more than one element!");
  }
  console.log("lookup >> get_binding lookup " + indexFound);
  if (indexFound === 162) {
    debugger;
  }
  return binding[indexFound];
};

set_binding_and_arglist = function(p, q, r) {
  var indexFound;
  if (p.k !== SYM) {
    stop("symbol error");
  }
  indexFound = symtab.indexOf(p);
  if (symtab.indexOf(p, indexFound + 1) !== -1) {
    console.log("ops, more than one element!");
  }
  console.log("lookup >> set_binding_and_arglist lookup " + indexFound);
  binding[indexFound] = q;
  return arglist[indexFound] = r;
};

get_arglist = function(p) {
  var indexFound;
  if (p.k !== SYM) {
    stop("symbol error");
  }
  indexFound = symtab.indexOf(p);
  if (symtab.indexOf(p, indexFound + 1) !== -1) {
    console.log("ops, more than one element!");
  }
  console.log("lookup >> get_arglist lookup " + indexFound);
  return arglist[indexFound];
};

lookupsTotal = 0;

symnum = function(p) {
  var indexFound;
  lookupsTotal++;
  if (p.k !== SYM) {
    stop("symbol error");
  }
  indexFound = symtab.indexOf(p);
  if (symtab.indexOf(p, indexFound + 1) !== -1) {
    console.log("ops, more than one element!");
  }
  console.log("lookup >> symnum lookup " + indexFound + " lookup # " + lookupsTotal);
  return indexFound;
};

push_symbol = function(k) {
  return push(symtab[k]);
};

clear_symbols = function() {
  var ac, i, ref1, results;
  i = 0;
  results = [];
  for (i = ac = 0, ref1 = NSYM; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    binding[i] = symtab[i];
    results.push(arglist[i] = symbol(NIL));
  }
  return results;
};

Eval_tensor = function() {
  var a, ac, ad, b, i, ndim, nelem, ref1, ref2;
  i = 0;
  ndim = 0;
  nelem = 0;
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  nelem = p1.tensor.nelem;
  ndim = p1.tensor.ndim;
  p2 = alloc_tensor(nelem);
  p2.tensor.ndim = ndim;
  for (i = ac = 0, ref1 = ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    p2.tensor.dim[i] = p1.tensor.dim[i];
  }
  a = p1.tensor.elem;
  b = p2.tensor.elem;
  if (p2.tensor.nelem !== p2.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  for (i = ad = 0, ref2 = nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
    push(a[i]);
    Eval();
    b[i] = pop();
  }
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  if (p2.tensor.nelem !== p2.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  push(p2);
  return promote_tensor();
};

tensor_plus_tensor = function() {
  var a, ac, ad, ae, b, c, i, ndim, nelem, ref1, ref2, ref3;
  i = 0;
  ndim = 0;
  nelem = 0;
  save();
  p2 = pop();
  p1 = pop();
  ndim = p1.tensor.ndim;
  if (ndim !== p2.tensor.ndim) {
    push(symbol(NIL));
    restore();
    return;
  }
  for (i = ac = 0, ref1 = ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    if (p1.tensor.dim[i] !== p2.tensor.dim[i]) {
      push(symbol(NIL));
      restore();
      return;
    }
  }
  nelem = p1.tensor.nelem;
  p3 = alloc_tensor(nelem);
  p3.tensor.ndim = ndim;
  for (i = ad = 0, ref2 = ndim; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
    p3.tensor.dim[i] = p1.tensor.dim[i];
  }
  a = p1.tensor.elem;
  b = p2.tensor.elem;
  c = p3.tensor.elem;
  for (i = ae = 0, ref3 = nelem; 0 <= ref3 ? ae < ref3 : ae > ref3; i = 0 <= ref3 ? ++ae : --ae) {
    push(a[i]);
    push(b[i]);
    add();
    c[i] = pop();
  }
  push(p3);
  return restore();
};

tensor_times_scalar = function() {
  var a, ac, ad, b, i, ndim, nelem, ref1, ref2;
  i = 0;
  ndim = 0;
  nelem = 0;
  save();
  p2 = pop();
  p1 = pop();
  ndim = p1.tensor.ndim;
  nelem = p1.tensor.nelem;
  p3 = alloc_tensor(nelem);
  p3.tensor.ndim = ndim;
  for (i = ac = 0, ref1 = ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    p3.tensor.dim[i] = p1.tensor.dim[i];
  }
  a = p1.tensor.elem;
  b = p3.tensor.elem;
  for (i = ad = 0, ref2 = nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
    push(a[i]);
    push(p2);
    multiply();
    b[i] = pop();
  }
  push(p3);
  return restore();
};

scalar_times_tensor = function() {
  var a, ac, ad, b, i, ndim, nelem, ref1, ref2;
  i = 0;
  ndim = 0;
  nelem = 0;
  save();
  p2 = pop();
  p1 = pop();
  ndim = p2.tensor.ndim;
  nelem = p2.tensor.nelem;
  p3 = alloc_tensor(nelem);
  p3.tensor.ndim = ndim;
  for (i = ac = 0, ref1 = ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    p3.tensor.dim[i] = p2.tensor.dim[i];
  }
  a = p2.tensor.elem;
  b = p3.tensor.elem;
  for (i = ad = 0, ref2 = nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
    push(p1);
    push(a[i]);
    multiply();
    b[i] = pop();
  }
  push(p3);
  return restore();
};

is_square_matrix = function(p) {
  if (istensor(p) && p.tensor.ndim === 2 && p.tensor.dim[0] === p.tensor.dim[1]) {
    return 1;
  } else {
    return 0;
  }
};

d_tensor_tensor = function() {
  var a, ac, ad, ae, b, c, i, j, ndim, nelem, ref1, ref2, ref3;
  i = 0;
  j = 0;
  ndim = 0;
  nelem = 0;
  ndim = p1.tensor.ndim;
  nelem = p1.tensor.nelem;
  if (ndim + 1 >= MAXDIM) {
    push_symbol(DERIVATIVE);
    push(p1);
    push(p2);
    list(3);
    return;
  }
  p3 = alloc_tensor(nelem * p2.tensor.nelem);
  p3.tensor.ndim = ndim + 1;
  for (i = ac = 0, ref1 = ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    p3.tensor.dim[i] = p1.tensor.dim[i];
  }
  p3.tensor.dim[ndim] = p2.tensor.dim[0];
  a = p1.tensor.elem;
  b = p2.tensor.elem;
  c = p3.tensor.elem;
  for (i = ad = 0, ref2 = nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
    for (j = ae = 0, ref3 = p2.tensor.nelem; 0 <= ref3 ? ae < ref3 : ae > ref3; j = 0 <= ref3 ? ++ae : --ae) {
      push(a[i]);
      push(b[j]);
      derivative();
      c[i * p2.tensor.nelem + j] = pop();
    }
  }
  return push(p3);
};

d_scalar_tensor = function() {
  var a, ac, b, i, ref1;
  p3 = alloc_tensor(p2.tensor.nelem);
  p3.tensor.ndim = 1;
  p3.tensor.dim[0] = p2.tensor.dim[0];
  a = p2.tensor.elem;
  b = p3.tensor.elem;
  for (i = ac = 0, ref1 = p2.tensor.nelem; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    push(p1);
    push(a[i]);
    derivative();
    b[i] = pop();
  }
  return push(p3);
};

d_tensor_scalar = function() {
  var a, ac, ad, b, i, ref1, ref2;
  i = 0;
  p3 = alloc_tensor(p1.tensor.nelem);
  p3.tensor.ndim = p1.tensor.ndim;
  for (i = ac = 0, ref1 = p1.tensor.ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    p3.tensor.dim[i] = p1.tensor.dim[i];
  }
  a = p1.tensor.elem;
  b = p3.tensor.elem;
  for (i = ad = 0, ref2 = p1.tensor.nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
    push(a[i]);
    push(p2);
    derivative();
    b[i] = pop();
  }
  return push(p3);
};

compare_tensors = function(p1, p2) {
  var ac, ad, i, ref1, ref2;
  i = 0;
  if (p1.tensor.ndim < p2.tensor.ndim) {
    return -1;
  }
  if (p1.tensor.ndim > p2.tensor.ndim) {
    return 1;
  }
  for (i = ac = 0, ref1 = p1.tensor.ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    if (p1.tensor.dim[i] < p2.tensor.dim[i]) {
      return -1;
    }
    if (p1.tensor.dim[i] > p2.tensor.dim[i]) {
      return 1;
    }
  }
  for (i = ad = 0, ref2 = p1.tensor.nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
    if (equal(p1.tensor.elem[i], p2.tensor.elem[i])) {
      continue;
    }
    if (lessp(p1.tensor.elem[i], p2.tensor.elem[i])) {
      return -1;
    } else {
      return 1;
    }
  }
  return 0;
};

power_tensor = function() {
  var ac, ad, i, k, n, ref1, ref2, results;
  i = 0;
  k = 0;
  n = 0;
  k = p1.tensor.ndim - 1;
  if (p1.tensor.dim[0] !== p1.tensor.dim[k]) {
    push_symbol(POWER);
    push(p1);
    push(p2);
    list(3);
    return;
  }
  push(p2);
  n = pop_integer();
  if (n === 0x80000000) {
    push_symbol(POWER);
    push(p1);
    push(p2);
    list(3);
    return;
  }
  if (n === 0) {
    if (p1.tensor.ndim !== 2) {
      stop("power(tensor,0) with tensor rank not equal to 2");
    }
    n = p1.tensor.dim[0];
    p1 = alloc_tensor(n * n);
    p1.tensor.ndim = 2;
    p1.tensor.dim[0] = n;
    p1.tensor.dim[1] = n;
    for (i = ac = 0, ref1 = n; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
      p1.tensor.elem[n * i + i] = one;
    }
    if (p1.tensor.nelem !== p1.tensor.elem.length) {
      console.log("something wrong in tensor dimensions");
      debugger;
    }
    push(p1);
    return;
  }
  if (n < 0) {
    n = -n;
    push(p1);
    inv();
    p1 = pop();
  }
  push(p1);
  results = [];
  for (i = ad = 1, ref2 = n; 1 <= ref2 ? ad < ref2 : ad > ref2; i = 1 <= ref2 ? ++ad : --ad) {
    push(p1);
    inner();
    if (iszero(stack[tos - 1])) {
      break;
    } else {
      results.push(void 0);
    }
  }
  return results;
};

copy_tensor = function() {
  var ac, ad, i, ref1, ref2;
  i = 0;
  save();
  p1 = pop();
  p2 = alloc_tensor(p1.tensor.nelem);
  p2.tensor.ndim = p1.tensor.ndim;
  for (i = ac = 0, ref1 = p1.tensor.ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    p2.tensor.dim[i] = p1.tensor.dim[i];
  }
  for (i = ad = 0, ref2 = p1.tensor.nelem; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
    p2.tensor.elem[i] = p1.tensor.elem[i];
  }
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  if (p2.tensor.nelem !== p2.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  push(p2);
  return restore();
};

promote_tensor = function() {
  var ac, ad, ae, af, ag, i, j, k, ndim, nelem, ref1, ref2, ref3, ref4, ref5;
  i = 0;
  j = 0;
  k = 0;
  nelem = 0;
  ndim = 0;
  save();
  p1 = pop();
  if (!istensor(p1)) {
    push(p1);
    restore();
    return;
  }
  p2 = p1.tensor.elem[0];
  for (i = ac = 1, ref1 = p1.tensor.nelem; 1 <= ref1 ? ac < ref1 : ac > ref1; i = 1 <= ref1 ? ++ac : --ac) {
    if (!compatible(p2, p1.tensor.elem[i])) {
      stop("Cannot promote tensor due to inconsistent tensor components.");
    }
  }
  if (!istensor(p2)) {
    push(p1);
    restore();
    return;
  }
  ndim = p1.tensor.ndim + p2.tensor.ndim;
  if (ndim > MAXDIM) {
    stop("tensor rank > 24");
  }
  nelem = p1.tensor.nelem * p2.tensor.nelem;
  p3 = alloc_tensor(nelem);
  p3.tensor.ndim = ndim;
  for (i = ad = 0, ref2 = p1.tensor.ndim; 0 <= ref2 ? ad < ref2 : ad > ref2; i = 0 <= ref2 ? ++ad : --ad) {
    p3.tensor.dim[i] = p1.tensor.dim[i];
  }
  for (j = ae = 0, ref3 = p2.tensor.ndim; 0 <= ref3 ? ae < ref3 : ae > ref3; j = 0 <= ref3 ? ++ae : --ae) {
    p3.tensor.dim[i + j] = p2.tensor.dim[j];
  }
  k = 0;
  for (i = af = 0, ref4 = p1.tensor.nelem; 0 <= ref4 ? af < ref4 : af > ref4; i = 0 <= ref4 ? ++af : --af) {
    p2 = p1.tensor.elem[i];
    for (j = ag = 0, ref5 = p2.tensor.nelem; 0 <= ref5 ? ag < ref5 : ag > ref5; j = 0 <= ref5 ? ++ag : --ag) {
      p3.tensor.elem[k++] = p2.tensor.elem[j];
    }
  }
  if (p2.tensor.nelem !== p2.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  if (p3.tensor.nelem !== p3.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  push(p3);
  return restore();
};

compatible = function(p, q) {
  var ac, i, ref1;
  if (!istensor(p) && !istensor(q)) {
    return 1;
  }
  if (!istensor(p) || !istensor(q)) {
    return 0;
  }
  if (p.tensor.ndim !== q.tensor.ndim) {
    return 0;
  }
  for (i = ac = 0, ref1 = p.tensor.ndim; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    if (p.tensor.dim[i] !== q.tensor.dim[i]) {
      return 0;
    }
  }
  return 1;
};

s = ["#test_tensor", "a=(1,2,3)", "", "b=(4,5,6)", "", "c=(7,8,9)", "", "rank((a,b,c))", "2", "(a,b,c)", "((1,2,3),(4,5,6),(7,8,9))", "((1,0),(0,0))", "((1,0),(0,0))", "a=quote(a)", "", "b=quote(b)", "", "c=quote(c)", ""];


/*
void
test_tensor(void)
{
	test(__FILE__, s, sizeof s / sizeof (char *));
}
 */

Eval_user_function = function() {
  debugger;
  var h;
  if (car(p1) === symbol(SYMBOL_D) && get_arglist(symbol(SYMBOL_D)) === symbol(NIL)) {
    Eval_derivative();
    return;
  }
  p3 = get_binding(car(p1));
  p4 = get_arglist(car(p1));
  p5 = cdr(p1);
  if (p3 === car(p1)) {
    h = tos;
    push(p3);
    p1 = p5;
    while (iscons(p1)) {
      push(car(p1));
      Eval();
      p1 = cdr(p1);
    }
    list(tos - h);
    return;
  }
  p1 = p4;
  p2 = p5;
  h = tos;
  while (iscons(p1) && iscons(p2)) {
    push(car(p1));
    push(car(p2));
    Eval();
    p1 = cdr(p1);
    p2 = cdr(p2);
  }
  list(tos - h);
  p6 = pop();
  push(p3);
  if (iscons(p6)) {
    push(p6);
    rewrite_args();
  }
  return Eval();
};

rewrite_args = function() {
  var h, n;
  n = 0;
  save();
  p2 = pop();
  p1 = pop();
  if (istensor(p1)) {
    n = rewrite_args_tensor();
    restore();
    return n;
  }
  if (iscons(p1)) {
    h = tos;
    push(car(p1));
    p1 = cdr(p1);
    while (iscons(p1)) {
      push(car(p1));
      push(p2);
      n += rewrite_args();
      p1 = cdr(p1);
    }
    list(tos - h);
    restore();
    return n;
  }
  if (!issymbol(p1)) {
    push(p1);
    restore();
    return 0;
  }
  p3 = p2;
  while (iscons(p3)) {
    if (p1 === car(p3)) {
      push(cadr(p3));
      restore();
      return 1;
    }
    p3 = cddr(p3);
  }
  p3 = get_binding(p1);
  push(p3);
  if (p1 !== p3) {
    push(p2);
    n = rewrite_args();
    if (n === 0) {
      pop();
      push(p1);
    }
  }
  restore();
  return n;
};

rewrite_args_tensor = function() {
  var ac, i, n, ref1;
  n = 0;
  i = 0;
  push(p1);
  copy_tensor();
  p1 = pop();
  for (i = ac = 0, ref1 = p1.tensor.nelem; 0 <= ref1 ? ac < ref1 : ac > ref1; i = 0 <= ref1 ? ++ac : --ac) {
    push(p1.tensor.elem[i]);
    push(p2);
    n += rewrite_args();
    p1.tensor.elem[i] = pop();
  }
  if (p1.tensor.nelem !== p1.tensor.elem.length) {
    console.log("something wrong in tensor dimensions");
    debugger;
  }
  push(p1);
  return n;
};
