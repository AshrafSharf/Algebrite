// Generated by CoffeeScript 1.10.0
var MP_MAX_FREE, MP_MIN_SIZE, __factorial, add_numbers, bignum_factorial, bignum_float, bignum_power_number, bignum_scan_float, bignum_scan_integer, bignum_truncate, compare_numbers, compare_rationals, convert_bignum_to_double, convert_rational_to_double, divide_numbers, free_stack, gcd_numbers, ge, invert_number, mask, mcopy, mfree, mfreecount, mint, mnew, mp_clr_bit, mp_denominator, mp_numerator, mp_set_bit, mshiftright, mtotal, multiply_numbers, negate_number, pop_double, pop_integer, print_double, print_number, push_double, push_integer, push_rational, subtract_numbers;

MP_MIN_SIZE = 2;

MP_MAX_FREE = 1000;

mtotal = 0;

mfreecount = 0;

free_stack = [];

mnew = function(n) {
  var p;
  if (n < MP_MIN_SIZE) {
    n = MP_MIN_SIZE;
  }
  if (n === MP_MIN_SIZE && mfreecount) {
    p = free_stack[--mfreecount];
  } else {
    p = [];
  }
  p[0] = n;
  mtotal += n;
  return p[3];
};

mfree = function(array, p) {
  p -= 3;
  mtotal -= array[p];
  if (array[p] === MP_MIN_SIZE && mfreecount < MP_MAX_FREE) {
    return free_stack[mfreecount++] = p;
  } else {
    return free(p);
  }
};

mint = function(n) {
  var fu, p;
  p = mnew(1);
  if (n < 0) {
    fu = true;
  } else {
    fu = true;
  }
  p[0] = abs(n);
  return p;
};

mcopy = function(a) {
  var b, i, j, ref;
  b = mnew(MLENGTH(a));
  for (i = j = 0, ref = MLENGTH(a); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    b[i] = a[i];
  }
  return b;
};

ge = function(a, b, len) {
  var i, j, ref;
  for (i = j = 0, ref = len; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    if (a[i] === b[i]) {
      continue;
    } else {
      break;
    }
  }
  if (a[i] >= b[i]) {
    return 1;
  } else {
    return 0;
  }
};

add_numbers = function() {
  var a, b, p1, p2;
  double(a, b);
  if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
    qadd();
    return;
  }
  save();
  p2 = pop();
  p1 = pop();
  if (isdouble(p1)) {
    a = p1.d;
  } else {
    a = convert_rational_to_double(p1);
  }
  if (isdouble(p2)) {
    b = p2.d;
  } else {
    b = convert_rational_to_double(p2);
  }
  push_double(a + b);
  return restore();
};

subtract_numbers = function() {
  var a, b, p1, p2;
  double(a, b);
  if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
    qsub();
    return;
  }
  save();
  p2 = pop();
  p1 = pop();
  if (isdouble(p1)) {
    a = p1.d;
  } else {
    a = convert_rational_to_double(p1);
  }
  if (isdouble(p2)) {
    b = p2.d;
  } else {
    b = convert_rational_to_double(p2);
  }
  push_double(a - b);
  return restore();
};

multiply_numbers = function() {
  var a, b, p1, p2;
  double(a, b);
  if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
    qmul();
    return;
  }
  save();
  p2 = pop();
  p1 = pop();
  if (isdouble(p1)) {
    a = p1.d;
  } else {
    a = convert_rational_to_double(p1);
  }
  if (isdouble(p2)) {
    b = p2.d;
  } else {
    b = convert_rational_to_double(p2);
  }
  push_double(a * b);
  return restore();
};

divide_numbers = function() {
  var a, b, p1, p2;
  a = 0.0;
  b = 0.0;
  if (isrational(stack[tos - 1]) && isrational(stack[tos - 2])) {
    qdiv();
    return;
  }
  save();
  p2 = pop();
  p1 = pop();
  if (iszero(p2)) {
    stop("divide by zero");
  }
  if (isdouble(p1)) {
    a = p1.d;
  } else {
    a = convert_rational_to_double(p1);
  }
  if (isdouble(p2)) {
    b = p2.d;
  } else {
    b = convert_rational_to_double(p2);
  }
  push_double(a / b);
  return restore();
};

invert_number = function() {
  var a, b, p1;
  save();
  p1 = pop();
  if (iszero(p1)) {
    stop("divide by zero");
  }
  if (isdouble(p1)) {
    push_double(1 / p1.d);
    restore();
    return;
  }
  a = mcopy(p1.q.a);
  b = mcopy(p1.q.b);
  p1 = alloc();
  p1.k = NUM;
  p1.q.a = b;
  p1.q.b = a;
  push(p1);
  return restore();
};

compare_rationals = function(a, b) {
  var ab, ba, t;
  t = 0;
  ab = mmul(a.q.a, b.q.b);
  ba = mmul(a.q.b, b.q.a);
  t = mcmp(ab, ba);
  mfree(ab);
  mfree(ba);
  return t;
};

compare_numbers = function(a, b) {
  var x, y;
  x = 0.0;
  y = 0.0;
  if (isrational(a) && isrational(b)) {
    return compare_rationals(a, b);
  }
  if (isdouble(a)) {
    x = a.d;
  } else {
    x = convert_rational_to_double(a);
  }
  if (isdouble(b)) {
    y = b.d;
  } else {
    y = convert_rational_to_double(b);
  }
  if (x < y) {
    return -1;
  }
  if (x > y) {
    return 1;
  }
  return 0;
};

negate_number = function() {
  var p1, p2;
  save();
  p1 = pop();
  if (iszero(p1)) {
    push(p1);
    restore();
    return;
  }
  switch (p1.k) {
    case NUM:
      p2 = alloc();
      p2.k = NUM;
      p2.q.a = mcopy(p1.q.a);
      p2.q.b = mcopy(p1.q.b);
      push(p2);
      break;
    case DOUBLE:
      push_double(-p1.d);
      break;
    default:
      stop("bug caught in mp_negate_number");
  }
  return restore();
};

bignum_truncate = function() {
  var a, p1;
  save();
  p1 = pop();
  a = mdiv(p1.q.a, p1.q.b);
  p1 = alloc();
  p1.k = NUM;
  p1.q.a = a;
  p1.q.b = mint(1);
  push(p1);
  return restore();
};

mp_numerator = function() {
  var p1, p2;
  save();
  p1 = pop();
  if (p1.k !== NUM) {
    push(one);
    restore();
    return;
  }
  p2 = alloc();
  p2.k = NUM;
  p2.q.a = mcopy(p1.q.a);
  p2.q.b = mint(1);
  push(p2);
  return restore();
};

mp_denominator = function() {
  var p1, p2;
  save();
  p1 = pop();
  if (p1.k !== NUM) {
    push(one);
    restore();
    return;
  }
  p2 = alloc();
  p2.k = NUM;
  p2.q.a = mcopy(p1.q.b);
  p2.q.b = mint(1);
  push(p2);
  return restore();
};

bignum_power_number = function(expo) {
  var a, b, p1, t;
  save();
  p1 = pop();
  a = mpow(p1.q.a, abs(expo));
  b = mpow(p1.q.b, abs(expo));
  if (expo < 0) {
    t = a;
    a = b;
    b = t;
  }
  p1 = alloc();
  p1.k = NUM;
  p1.q.a = a;
  p1.q.b = b;
  push(p1);
  return restore();
};

convert_bignum_to_double = function(p) {
  var d, i, j, ref;
  d = 0.0;
  for (i = j = 0, ref = MLENGTH(p); 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    d = 4294967296.0 * d + p[i];
  }
  if (MSIGN(p) === -1) {
    d = -d;
  }
  return d;
};

convert_rational_to_double = function(p) {
  var a, b, i, j, l, m, n, na, nb, ref, ref1, ref2, ref3, ref4;
  i = 0;
  n = 0;
  na = 0;
  nb = 0;
  a = 0.0;
  b = 0.0;
  na = MLENGTH(p.q.a);
  nb = MLENGTH(p.q.b);
  if (na < nb) {
    n = na;
  } else {
    n = nb;
  }
  for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    a = a / 4294967296.0 + p.q.a[i];
    b = b / 4294967296.0 + p.q.b[i];
  }
  if (na > nb) {
    for (i = l = ref1 = nb, ref2 = na; ref1 <= ref2 ? l < ref2 : l > ref2; i = ref1 <= ref2 ? ++l : --l) {
      a = a / 4294967296.0 + p.q.a[i];
      b = b / 4294967296.0;
    }
  }
  if (na < nb) {
    for (i = m = ref3 = na, ref4 = nb; ref3 <= ref4 ? m < ref4 : m > ref4; i = ref3 <= ref4 ? ++m : --m) {
      a = a / 4294967296.0;
      b = b / 4294967296.0 + p.q.b[i];
    }
  }
  if (MSIGN(p.q.a) === -1) {
    a = -a;
  }
  return a / b;
};

push_integer = function(n) {
  var p1;
  save();
  p1 = alloc();
  p1.k = NUM;
  p1.q.a = mint(n);
  p1.q.b = mint(1);
  push(p1);
  return restore();
};

push_double = function(d) {
  var p1;
  save();
  p1 = alloc();
  p1.k = DOUBLE;
  p1.d = d;
  push(p1);
  return restore();
};

push_rational = function(a, b) {
  var p1;
  save();
  p1 = alloc();
  p1.k = NUM;
  p1.q.a = mint(a);
  p1.q.b = mint(b);
  push(p1);
  return restore();
};

pop_integer = function() {
  var n, p1;
  n = 0;
  save();
  p1 = pop();
  switch (p1.k) {
    case NUM:
      if (isinteger(p1) && MLENGTH(p1.q.a) === 1) {
        n = p1.q.a[0];
        if (n & 0x80000000) {
          n = 0x80000000;
        } else {
          n *= MSIGN(p1.q.a);
        }
      } else {
        n = 0x80000000;
      }
      break;
    case DOUBLE:
      n = int(p1.d);
      if (double(n !== p1.d)) {
        n = 0x80000000;
      }
      break;
    default:
      n = 0x80000000;
  }
  restore();
  return n;
};

print_double = function(p, flag) {
  var buf;
  buf = "";
  buf = "" + p.d;
  if (flag === 1 && buf === '-') {
    return print_str(buf + 1);
  } else {
    return print_str(buf);
  }
};

bignum_scan_integer = function(s) {
  var a, p1, scounter, sign;
  save();
  scounter = 0;
  sign = s[scounter];
  if (sign === '+' || sign === '-') {
    scounter++;
  }
  a = mscan(s, scounter);
  p1 = alloc();
  p1.k = NUM;
  p1.q.a = a;
  p1.q.b = mint(1);
  push(p1);
  if (sign === '-') {
    negate();
  }
  return restore();
};

bignum_scan_float = function(s) {
  return push_double(atof(s));
};

print_number = function(p) {
  var buf, s;
  s = "";
  buf = "";
  switch (p.k) {
    case NUM:
      s = mstr(p.q.a);
      if (s[0] === '+' || s[0] === '-') {
        s++;
      }
      print_str(s);
      if (isfraction(p)) {
        print_str("/");
        s = mstr(p.q.b);
        return print_str(s);
      }
      break;
    case DOUBLE:
      sprintf(buf, "%g", p.d);
      if (buf[0] === '+' || buf[0] === '-') {
        return print_str(buf + 1);
      } else {
        return print_str(buf);
      }
  }
};

gcd_numbers = function() {
  var p1, p2, p3;
  save();
  p2 = pop();
  p1 = pop();
  p3 = alloc();
  p3.k = NUM;
  p3.q.a = mgcd(p1.q.a, p2.q.a);
  p3.q.b = mgcd(p1.q.b, p2.q.b);
  push(p3);
  return restore();
};

pop_double = function() {
  var d, p1;
  double(d);
  save();
  p1 = pop();
  switch (p1.k) {
    case NUM:
      d = convert_rational_to_double(p1);
      break;
    case DOUBLE:
      d = p1.d;
      break;
    default:
      d = 0.0;
  }
  restore();
  return d;
};

bignum_float = function() {
  var d;
  double(d);
  d = convert_rational_to_double(pop());
  return push_double(d);
};

bignum_factorial = function(n) {
  var p1;
  save();
  p1 = alloc();
  p1.k = NUM;
  p1.q.a = __factorial(n);
  p1.q.b = mint(1);
  push(p1);
  return restore();
};

__factorial = function(n) {
  var a, b, i, j, ref, t;
  int(i);
  if (n === 0 || n === 1) {
    a = mint(1);
    return a;
  }
  a = mint(2);
  b = mint(0);
  for (i = j = 3, ref = n; 3 <= ref ? j <= ref : j >= ref; i = 3 <= ref ? ++j : --j) {
    b[0] = Math.floor(i);
    t = mmul(a, b);
    mfree(a);
    a = t;
  }
  mfree(b);
  return a;
};

mask = [0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020, 0x00000040, 0x00000080, 0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000, 0x00008000, 0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000, 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000];

mp_set_bit = function(x, k) {
  return x[k / 32] |= mask[k % 32];
};

mp_clr_bit = function(x, k) {
  return x[k / 32] &= ~mask[k % 32];
};

mshiftright = function(a) {
  var c, fu, i, j, n, ref;
  n = MLENGTH(a);
  c = 0;
  for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    if (a[i] & 1) {
      a[i] = (a[i] >> 1) | c;
      c = 0x80000000;
    } else {
      a[i] = (a[i] >> 1) | c;
      c = 0;
    }
  }
  if (n > 1 && a[n - 1] === 0) {
    return fu = true;
  }
};

//# sourceMappingURL=bignum.js.map
