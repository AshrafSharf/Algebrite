// Generated by CoffeeScript 1.10.0
var EVAL, EVAL_EVAL, EVAL_binding, EVAL_check, EVAL_cons, EVAL_det, EVAL_dim, EVAL_divisors, EVAL_do, EVAL_dsolve, EVAL_exp, EVAL_factorial, EVAL_factorpoly, EVAL_hermite, EVAL_hilbert, EVAL_index, EVAL_inv, EVAL_invg, EVAL_isinteger, EVAL_multiply, EVAL_noexpand, EVAL_number, EVAL_operator, EVAL_predicate, EVAL_print, EVAL_quote, EVAL_rank, EVAL_setq, EVAL_sqrt, EVAL_stop, EVAL_subst, EVAL_sym, EVAL_unit, setq_indexed;

EVAL = function() {
  var p1;
  check_esc_flag();
  save();
  p1 = pop();
  switch (p1.k) {
    case CONS:
      EVAL_cons();
      break;
    case NUM:
      push(p1);
      break;
    case DOUBLE:
      push(p1);
      break;
    case STR:
      push(p1);
      break;
    case TENSOR:
      EVAL_tensor();
      break;
    case SYM:
      EVAL_sym();
      break;
    default:
      stop("atom?");
  }
  return restore();
};

EVAL_sym = function() {
  var p2;
  if (iskeyword(p1)) {
    push(p1);
    push(symbol(LAST));
    list(2);
    EVAL();
    return;
  }
  p2 = get_binding(p1);
  push(p2);
  if (p1 !== p2) {
    return EVAL();
  }
};

EVAL_cons = function() {
  if (!issymbol(car(p1))) {
    stop("cons?");
  }
  switch (symnum(car(p1))) {
    case ABS:
      return EVAL_abs();
    case ADD:
      return EVAL_add();
    case ADJ:
      return EVAL_adj();
    case AND:
      return EVAL_and();
    case ARCCOS:
      return EVAL_arccos();
    case ARCCOSH:
      return EVAL_arccosh();
    case ARCSIN:
      return EVAL_arcsin();
    case ARCSINH:
      return EVAL_arcsinh();
    case ARCTAN:
      return EVAL_arctan();
    case ARCTANH:
      return EVAL_arctanh();
    case ARG:
      return EVAL_arg();
    case ATOMIZE:
      return EVAL_atomize();
    case BESSELJ:
      return EVAL_besselj();
    case BESSELY:
      return EVAL_bessely();
    case BINDING:
      return EVAL_binding();
    case BINOMIAL:
      return EVAL_binomial();
    case CEILING:
      return EVAL_ceiling();
    case CHECK:
      return EVAL_check();
    case CHOOSE:
      return EVAL_choose();
    case CIRCEXP:
      return EVAL_circexp();
    case CLEAR:
      return EVAL_clear();
    case CLOCK:
      return EVAL_clock();
    case COEFF:
      return EVAL_coeff();
    case COFACTOR:
      return EVAL_cofactor();
    case CONDENSE:
      return EVAL_condense();
    case CONJ:
      return EVAL_conj();
    case CONTRACT:
      return EVAL_contract();
    case COS:
      return EVAL_cos();
    case COSH:
      return EVAL_cosh();
    case DECOMP:
      return EVAL_decomp();
    case DEGREE:
      return EVAL_degree();
    case DEFINT:
      return EVAL_defint();
    case DENOMINATOR:
      return EVAL_denominator();
    case DERIVATIVE:
      return EVAL_derivative();
    case DET:
      return EVAL_det();
    case DIM:
      return EVAL_dim();
    case DIRAC:
      return EVAL_dirac();
    case DISPLAY:
      return EVAL_display();
    case DIVISORS:
      return EVAL_divisors();
    case DO:
      return EVAL_do();
    case DOT:
      return EVAL_inner();
    case DRAW:
      return EVAL_draw();
    case DSOLVE:
      return EVAL_dsolve();
    case EIGEN:
      return EVAL_eigen();
    case EIGENVAL:
      return EVAL_eigenval();
    case EIGENVEC:
      return EVAL_eigenvec();
    case ERF:
      return EVAL_erf();
    case ERFC:
      return EVAL_erfc();
    case EVAL:
      return EVAL_EVAL();
    case EXP:
      return EVAL_exp();
    case EXPAND:
      return EVAL_expand();
    case EXPCOS:
      return EVAL_expcos();
    case EXPSIN:
      return EVAL_expsin();
    case FACTOR:
      return EVAL_factor();
    case FACTORIAL:
      return EVAL_factorial();
    case FACTORPOLY:
      return EVAL_factorpoly();
    case FILTER:
      return EVAL_filter();
    case FLOATF:
      return EVAL_float();
    case FLOOR:
      return EVAL_floor();
    case FOR:
      return EVAL_for();
    case GAMMA:
      return EVAL_gamma();
    case GCD:
      return EVAL_gcd();
    case HERMITE:
      return EVAL_hermite();
    case HILBERT:
      return EVAL_hilbert();
    case IMAG:
      return EVAL_imag();
    case INDEX:
      return EVAL_index();
    case INNER:
      return EVAL_inner();
    case INTEGRAL:
      return EVAL_integral();
    case INV:
      return EVAL_inv();
    case INVG:
      return EVAL_invg();
    case ISINTEGER:
      return EVAL_isinteger();
    case ISPRIME:
      return EVAL_isprime();
    case LAGUERRE:
      return EVAL_laguerre();
    case LCM:
      return EVAL_lcm();
    case LEADING:
      return EVAL_leading();
    case LEGENDRE:
      return EVAL_legendre();
    case LOG:
      return EVAL_log();
    case MAG:
      return EVAL_mag();
    case MOD:
      return EVAL_mod();
    case MULTIPLY:
      return EVAL_multiply();
    case NOT:
      return EVAL_not();
    case NROOTS:
      return EVAL_nroots();
    case NUMBER:
      return EVAL_number();
    case NUMERATOR:
      return EVAL_numerator();
    case OPERATOR:
      return EVAL_operator();
    case OR:
      return EVAL_or();
    case OUTER:
      return EVAL_outer();
    case POLAR:
      return EVAL_polar();
    case POWER:
      return EVAL_power();
    case PRIME:
      return EVAL_prime();
    case PRINT:
      return EVAL_display();
    case PRODUCT:
      return EVAL_product();
    case QUOTE:
      return EVAL_quote();
    case QUOTIENT:
      return EVAL_quotient();
    case RANK:
      return EVAL_rank();
    case RATIONALIZE:
      return EVAL_rationalize();
    case REAL:
      return EVAL_real();
    case YYRECT:
      return EVAL_rect();
    case ROOTS:
      return EVAL_roots();
    case SETQ:
      return EVAL_setq();
    case SGN:
      return EVAL_sgn();
    case SIMPLIFY:
      return EVAL_simplify();
    case SIN:
      return EVAL_sin();
    case SINH:
      return EVAL_sinh();
    case SQRT:
      return EVAL_sqrt();
    case STOP:
      return EVAL_stop();
    case SUBST:
      return EVAL_subst();
    case SUM:
      return EVAL_sum();
    case TAN:
      return EVAL_tan();
    case TANH:
      return EVAL_tanh();
    case TAYLOR:
      return EVAL_taylor();
    case TEST:
      return EVAL_test();
    case TESTEQ:
      return EVAL_testeq();
    case TESTGE:
      return EVAL_testge();
    case TESTGT:
      return EVAL_testgt();
    case TESTLE:
      return EVAL_testle();
    case TESTLT:
      return EVAL_testlt();
    case TRANSPOSE:
      return EVAL_transpose();
    case UNIT:
      return EVAL_unit();
    case ZERO:
      return EVAL_zero();
    default:
      return EVAL_user_function();
  }
};

EVAL_binding = function() {
  return push(get_binding(cadr(p1)));
};

EVAL_check = function() {
  var p1;
  push(cadr(p1));
  EVAL_predicate();
  p1 = pop();
  if (iszero(p1)) {
    stop("check(arg): arg is zero");
  }
  return push(symbol(NIL));
};

EVAL_det = function() {
  push(cadr(p1));
  EVAL();
  return det();
};

EVAL_dim = function() {
  var n, p2;
  int(n);
  push(cadr(p1));
  EVAL();
  p2 = pop();
  if (iscons(cddr(p1))) {
    push(caddr(p1));
    EVAL();
    n = pop_integer();
  } else {
    n = 1;
  }
  if (!istensor(p2)) {
    return push_integer(1);
  } else if (n < 1 || n > p2.tensor.ndim) {
    return push(p1);
  } else {
    return push_integer(p2.tensor.dim[n - 1]);
  }
};

EVAL_divisors = function() {
  push(cadr(p1));
  EVAL();
  return divisors();
};

EVAL_do = function() {
  var p1, results;
  push(car(p1));
  p1 = cdr(p1);
  results = [];
  while (iscons(p1)) {
    pop();
    push(car(p1));
    EVAL();
    results.push(p1 = cdr(p1));
  }
  return results;
};

EVAL_dsolve = function() {
  push(cadr(p1));
  EVAL();
  push(caddr(p1));
  EVAL();
  push(cadddr(p1));
  EVAL();
  return dsolve();
};

EVAL_EVAL = function() {
  var p1;
  push(cadr(p1));
  EVAL();
  p1 = cddr(p1);
  while (iscons(p1)) {
    push(car(p1));
    EVAL();
    push(cadr(p1));
    EVAL();
    subst();
    p1 = cddr(p1);
  }
  return EVAL();
};

EVAL_exp = function() {
  push(cadr(p1));
  EVAL();
  return exponential();
};

EVAL_factorial = function() {
  push(cadr(p1));
  EVAL();
  return factorial();
};

EVAL_factorpoly = function() {
  var p1, results;
  p1 = cdr(p1);
  push(car(p1));
  EVAL();
  p1 = cdr(p1);
  push(car(p1));
  EVAL();
  factorpoly();
  p1 = cdr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    EVAL();
    factorpoly();
    results.push(p1 = cdr(p1));
  }
  return results;
};

EVAL_hermite = function() {
  push(cadr(p1));
  EVAL();
  push(caddr(p1));
  EVAL();
  return hermite();
};

EVAL_hilbert = function() {
  push(cadr(p1));
  EVAL();
  return hilbert();
};

EVAL_index = function() {
  var h, p1;
  h = tos;
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    EVAL();
    p1 = cdr(p1);
  }
  return index_function(tos - h);
};

EVAL_inv = function() {
  push(cadr(p1));
  EVAL();
  return inv();
};

EVAL_invg = function() {
  push(cadr(p1));
  EVAL();
  return invg();
};

EVAL_isinteger = function() {
  var n, p1;
  push(cadr(p1));
  EVAL();
  p1 = pop();
  if (isrational(p1)) {
    if (isinteger(p1)) {
      push(one);
    } else {
      push(zero);
    }
    return;
  }
  if (isdouble(p1)) {
    n = int(p1.d);
    if (n === p1.d) {
      push(one);
    } else {
      push(zero);
    }
    return;
  }
  push_symbol(ISINTEGER);
  push(p1);
  return list(2);
};

EVAL_multiply = function() {
  var p1, results;
  push(cadr(p1));
  EVAL();
  p1 = cddr(p1);
  results = [];
  while (iscons(p1)) {
    push(car(p1));
    EVAL();
    multiply();
    results.push(p1 = cdr(p1));
  }
  return results;
};

EVAL_number = function() {
  var p1;
  push(cadr(p1));
  EVAL();
  p1 = pop();
  if (p1.k === NUM || p1.k === DOUBLE) {
    return push_integer(1);
  } else {
    return push_integer(0);
  }
};

EVAL_operator = function() {
  var h, p1;
  int(h = tos);
  push_symbol(OPERATOR);
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    EVAL();
    p1 = cdr(p1);
  }
  return list(tos - h);
};

EVAL_print = function() {
  var p1;
  p1 = cdr(p1);
  while (iscons(p1)) {
    push(car(p1));
    EVAL();
    if (equaln(get_binding(symbol(TTY)), 1)) {
      printline(pop());
    } else {
      display(pop());
    }
    p1 = cdr(p1);
  }
  return push(symbol(NIL));
};

EVAL_quote = function() {
  return push(cadr(p1));
};

EVAL_rank = function() {
  var p1;
  push(cadr(p1));
  EVAL();
  p1 = pop();
  if (istensor(p1)) {
    return push_integer(p1.tensor.ndim);
  } else {
    return push(zero);
  }
};

setq_indexed = function() {
  var h, p2, p3, p4;
  p4 = cadadr(p1);
  if (!issymbol(p4)) {
    stop("indexed assignment: error in symbol");
  }
  h = tos;
  push(caddr(p1));
  EVAL();
  p2 = cdadr(p1);
  while (iscons(p2)) {
    push(car(p2));
    EVAL();
    p2 = cdr(p2);
  }
  set_component(tos - h);
  p3 = pop();
  set_binding(p4, p3);
  return push(symbol(NIL));
};

EVAL_setq = function() {
  var p2;
  if (caadr(p1) === symbol(INDEX)) {
    setq_indexed();
    return;
  }
  if (iscons(cadr(p1))) {
    define_user_function();
    return;
  }
  if (!issymbol(cadr(p1))) {
    stop("symbol assignment: error in symbol");
  }
  push(caddr(p1));
  EVAL();
  p2 = pop();
  set_binding(cadr(p1), p2);
  return push(symbol(NIL));
};

EVAL_sqrt = function() {
  push(cadr(p1));
  EVAL();
  push_rational(1, 2);
  return power();
};

EVAL_stop = function() {
  return stop("user stop");
};

EVAL_subst = function() {
  push(cadddr(p1));
  EVAL();
  push(caddr(p1));
  EVAL();
  push(cadr(p1));
  EVAL();
  subst();
  return EVAL();
};

EVAL_unit = function() {
  var i, j, n, p1, ref;
  push(cadr(p1));
  EVAL();
  n = pop_integer();
  if (n < 2) {
    push(p1);
    return;
  }
  p1 = alloc_tensor(n * n);
  p1.tensor.ndim = 2;
  p1.tensor.dim[0] = n;
  p1.tensor.dim[1] = n;
  for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    p1.tensor.elem[n * i + i] = one;
  }
  return push(p1);
};

EVAL_noexpand = function() {
  var expanding, x;
  x = expanding;
  expanding = 0;
  EVAL();
  return expanding = x;
};

EVAL_predicate = function() {
  var p1;
  save();
  p1 = pop();
  if (car(p1) === symbol(SETQ)) {
    EVAL_testeq();
  } else {
    push(p1);
    EVAL();
  }
  return restore();
};

//# sourceMappingURL=eval.js.map
