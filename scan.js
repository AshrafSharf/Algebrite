// Generated by CoffeeScript 1.10.0
var T_DOUBLE, T_EQ, T_FUNCTION, T_GTEQ, T_INTEGER, T_LTEQ, T_NEWLINE, T_STRING, T_SYMBOL, build_tensor, error, get_next_token, get_token, input_str, is_factor, meta_mode, newline_flag, scan, scan_expression, scan_factor, scan_function_call, scan_meta, scan_power, scan_relation, scan_stmt, scan_str, scan_string, scan_subexpr, scan_symbol, scan_term, scanned, testString, test_scan, token, token_buf, token_str, update_token_buf;

T_INTEGER = 1001;

T_DOUBLE = 1002;

T_SYMBOL = 1003;

T_FUNCTION = 1004;

T_NEWLINE = 1006;

T_STRING = 1007;

T_GTEQ = 1008;

T_LTEQ = 1009;

T_EQ = 1010;

token = 0;

newline_flag = 0;

meta_mode = 0;

input_str = 0;

scan_str = 0;

token_str = 0;

token_buf = 0;

scanned = "";

scan = function(s) {
  scanned = s;
  meta_mode = 0;
  expanding++;
  input_str = 0;
  scan_str = 0;
  get_next_token();
  if (token === 0) {
    push(symbol(NIL));
    expanding--;
    return 0;
  }
  scan_stmt();
  expanding--;
  return token_str - input_str;
};

scan_meta = function(s) {
  meta_mode = 1;
  expanding++;
  input_str = 0;
  scan_str = 0;
  get_next_token();
  if (token === 0) {
    push(symbol(NIL));
    expanding--;
    return 0;
  }
  scan_stmt();
  expanding--;
  return token_str - input_str;
};

scan_stmt = function() {
  scan_relation();
  if (token === '=') {
    get_next_token();
    push_symbol(SETQ);
    swap();
    scan_relation();
    return list(3);
  }
};

scan_relation = function() {
  scan_expression();
  switch (token) {
    case T_EQ:
      push_symbol(TESTEQ);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
    case T_LTEQ:
      push_symbol(TESTLE);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
    case T_GTEQ:
      push_symbol(TESTGE);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
    case '<':
      push_symbol(TESTLT);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
    case '>':
      push_symbol(TESTGT);
      swap();
      get_next_token();
      scan_expression();
      return list(3);
  }
};

scan_expression = function() {
  var h;
  h = tos;
  switch (token) {
    case '+':
      get_next_token();
      scan_term();
      break;
    case '-':
      get_next_token();
      scan_term();
      negate();
      break;
    default:
      scan_term();
  }
  while (newline_flag === 0 && (token === '+' || token === '-')) {
    if (token === '+') {
      get_next_token();
      scan_term();
    } else {
      get_next_token();
      scan_term();
      negate();
    }
  }
  if (tos - h > 1) {
    list(tos - h);
    push_symbol(ADD);
    swap();
    return cons();
  }
};

is_factor = function() {
  switch (token) {
    case '*':
    case '/':
      return 1;
    case '(':
    case T_SYMBOL:
    case T_FUNCTION:
    case T_INTEGER:
    case T_DOUBLE:
    case T_STRING:
      if (newline_flag) {
        scan_str = token_str;
        return 0;
      } else {
        return 1;
      }
  }
  return 0;
};

scan_term = function() {
  var h;
  h = tos;
  scan_power();
  if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {
    pop();
  }
  while (is_factor()) {
    if (token === '*') {
      get_next_token();
      scan_power();
    } else if (token === '/') {
      get_next_token();
      scan_power();
      inverse();
    } else {
      scan_power();
    }
    if (tos > h + 1 && isnum(stack[tos - 2]) && isnum(stack[tos - 1])) {
      multiply();
    }
    if (tos > h && isrational(stack[tos - 1]) && equaln(stack[tos - 1], 1)) {
      pop();
    }
  }
  if (h === tos) {
    return push_integer(1);
  } else if (tos - h > 1) {
    list(tos - h);
    push_symbol(MULTIPLY);
    swap();
    return cons();
  }
};

scan_power = function() {
  scan_factor();
  if (token === '^') {
    get_next_token();
    push_symbol(POWER);
    swap();
    scan_power();
    return list(3);
  }
};

scan_factor = function() {
  var h, results;
  h = tos;
  if (token === '(') {
    scan_subexpr();
  } else if (token === T_SYMBOL) {
    scan_symbol();
  } else if (token === T_FUNCTION) {
    scan_function_call();
  } else if (token === T_INTEGER) {
    bignum_scan_integer(token_buf);
    get_next_token();
  } else if (token === T_DOUBLE) {
    bignum_scan_float(token_buf);
    get_next_token();
  } else if (token === T_STRING) {
    scan_string();
  } else {
    error("syntax error");
  }
  if (token === '[') {
    get_next_token();
    push_symbol(INDEX);
    swap();
    scan_expression();
    while (token === ',') {
      get_next_token();
      scan_expression();
    }
    if (token !== ']') {
      error("] expected");
    }
    get_next_token();
    list(tos - h);
  }
  results = [];
  while (token === '!') {
    get_next_token();
    push_symbol(FACTORIAL);
    swap();
    results.push(list(2));
  }
  return results;
};

scan_symbol = function() {
  if (token !== T_SYMBOL) {
    error("symbol expected");
  }
  if (meta_mode && strlen(token_buf) === 1) {
    switch (token_buf[0]) {
      case 'a':
        push(symbol(METAA));
        break;
      case 'b':
        push(symbol(METAB));
        break;
      case 'x':
        push(symbol(METAX));
        break;
      default:
        push(usr_symbol(token_buf));
    }
  } else {
    push(usr_symbol(token_buf));
  }
  return get_next_token();
};

scan_string = function() {
  new_string(token_buf);
  return get_next_token();
};

scan_function_call = function() {
  var n, p;
  n = 1;
  p = new U();
  p = usr_symbol(token_buf);
  push(p);
  get_next_token();
  get_next_token();
  if (token !== ')') {
    scan_stmt();
    n++;
    while (token === ',') {
      get_next_token();
      scan_stmt();
      n++;
    }
  }
  if (token !== ')') {
    error(") expected");
  }
  get_next_token();
  return list(n);
};

scan_subexpr = function() {
  var n;
  n = 0;
  if (token !== '(') {
    error("( expected");
  }
  get_next_token();
  scan_stmt();
  if (token === ',') {
    n = 1;
    while (token === ',') {
      get_next_token();
      scan_stmt();
      n++;
    }
    build_tensor(n);
  }
  if (token !== ')') {
    error(") expected");
  }
  return get_next_token();
};

error = function(errmsg) {
  console.log('\n');
  while (input_str !== scan_str) {
    if ((scanned[input_str] === '\n' || scanned[input_str] === '\r') && input_str + 1 === scan_str) {
      break;
    }
    console.log(scanned[input_str++]);
  }
  console.log(" ? ");
  while (scanned[input_str] && (scanned[input_str] !== '\n' && scanned[input_str] !== '\r')) {
    console.log(scanned[input_str]);
  }
  console.log('\n');
  return stop(errmsg);
};

build_tensor = function(n) {
  var i, j, p2, ref, s;
  i = 0;
  s = 0;
  save();
  s = stack + tos - n;
  p2 = alloc_tensor(n);
  p2.tensor.ndim = 1;
  p2.tensor.dim[0] = n;
  for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
    p2.tensor.elem[i] = s[i];
  }
  tos -= n;
  push(p2);
  return restore();
};

get_next_token = function() {
  var results;
  newline_flag = 0;
  results = [];
  while (1.) {
    get_token();
    if (token !== T_NEWLINE) {
      break;
    }
    results.push(newline_flag = 1);
  }
  return results;
};

get_token = function() {
  while (isspace(scanned[scan_str])) {
    if (scanned[scan_str] === '\n' || scanned[scan_str] === '\r') {
      token = T_NEWLINE;
      scan_str++;
      return;
    }
    scan_str++;
  }
  token_str = scan_str;
  if (scanned[scan_str] === 0) {
    token = 0;
    return;
  }
  if (isdigit(scanned[scan_str]) || scanned[scan_str] === '.') {
    while (isdigit(scanned[scan_str])) {
      scan_str++;
    }
    if (scanned[scan_str] === '.') {
      scan_str++;
      while (isdigit(scanned[scan_str])) {
        scan_str++;
      }
      if (scanned[scan_str] === 'e' && (scan_str[1] === '+' || scan_str[1] === '-' || isdigit(scan_str[1]))) {
        scan_str += 2;
        while (isdigit(scanned[scan_str])) {
          scan_str++;
        }
      }
      token = T_DOUBLE;
    } else {
      token = T_INTEGER;
    }
    update_token_buf(token_str, scan_str);
    return;
  }
  if (isalpha(scanned[scan_str])) {
    while (isalnum(scanned[scan_str])) {
      scan_str++;
    }
    if (scanned[scan_str] === '(') {
      token = T_FUNCTION;
    } else {
      token = T_SYMBOL;
    }
    update_token_buf(token_str, scan_str);
    return;
  }
  if (scanned[scan_str] === '"') {
    scan_str++;
    while (scanned[scan_str] !== '"') {
      if (scanned[scan_str] === 0 || scanned[scan_str] === '\n' || scanned[scan_str] === '\r') {
        error("runaway string");
      }
      scan_str++;
    }
    scan_str++;
    token = T_STRING;
    update_token_buf(token_str + 1, scan_str - 1);
    return;
  }
  if (scanned[scan_str] === '#' || scanned[scan_str] === '-' && scan_str[1] === '-') {
    while (scanned[scan_str] && scanned[scan_str] !== '\n' && scanned[scan_str] !== '\r') {
      scan_str++;
    }
    if (scanned[scan_str]) {
      scan_str++;
    }
    token = T_NEWLINE;
    return;
  }
  if (scanned[scan_str] === '=' && scan_str[1] === '=') {
    scan_str += 2;
    token = T_EQ;
    return;
  }
  if (scanned[scan_str] === '<' && scan_str[1] === '=') {
    scan_str += 2;
    token = T_LTEQ;
    return;
  }
  if (scanned[scan_str] === '>' && scan_str[1] === '=') {
    scan_str += 2;
    token = T_GTEQ;
    return;
  }
  return token = scanned[scan_str]++;
};

update_token_buf = function(a, b) {
  var n;
  int(n);
  if (token_buf) {
    free(token_buf);
  }
  n = int(b - a);
  if (token_buf === 0) {
    stop("malloc failure");
  }
  strncpy(token_buf, a, n);
  return token_buf[n] = 0;
};

testString = ["a^^b", "a^^ ? b\nStop: syntax error", "(a+b", "(a+b ? \nStop: ) expected", "quote(1/(x*log(a*x)))", "1/(x*log(a*x))", "\"hello", "\"hello ? \nStop: runaway string", "a+\nb+\nc+", "a+\nb+\nc+ ? \nStop: syntax error", "2+2\n(3+3)", "4\n6", "1\n-1", "1\n-1", "1\n+1", "1\n1"];

test_scan = function() {
  var a;
  return a = 0;
};

//# sourceMappingURL=scan.js.map
