// Generated by CoffeeScript 1.10.0
debugger;
var ABS, ADD, ADJ, AND, ARCCOS, ARCCOSH, ARCSIN, ARCSINH, ARCTAN, ARCTANH, ARG, ATOMIZE, AUTOEXPAND, BAKE, BESSELJ, BESSELY, BINDING, BINOMIAL, BUF, C1, C2, C3, C4, C5, C6, CEILING, CHECK, CHOOSE, CIRCEXP, CLEAR, CLOCK, COEFF, COFACTOR, CONDENSE, CONJ, CONS, CONTRACT, COS, COSH, DECOMP, DEFINT, DEGREE, DENOMINATOR, DERIVATIVE, DET, DIM, DIRAC, DISPLAY, DIVISORS, DO, DOT, DOUBLE, DRAW, DRAWX, DSOLVE, E, EIGEN, EIGENVAL, EIGENVEC, ERF, ERFC, EVAL, EXP, EXPAND, EXPCOS, EXPSIN, FACTOR, FACTORIAL, FACTORPOLY, FILTER, FLOATF, FLOOR, FOR, GAMMA, GCD, HERMITE, HILBERT, IMAG, INDEX, INNER, INTEGRAL, INV, INVG, ISINTEGER, ISPRIME, LAGUERRE, LAST, LCM, LEADING, LEGENDRE, LOG, MAG, MAXDIM, MAXPRIMETAB, MAX_PROGRAM_SIZE, MEQUAL, METAA, METAB, METAX, MLENGTH, MOD, MSIGN, MULTIPLY, MZERO, NIL, NOT, NROOTS, NSYM, NUM, NUMBER, NUMERATOR, OPERATOR, OR, OUTER, PI, POLAR, POWER, PRIME, PRINT, PRODUCT, QUOTE, QUOTIENT, RANK, RATIONALIZE, REAL, ROOTS, SECRETX, SELFTEST, SETQ, SGN, SIMPLIFY, SIN, SINH, SQRT, STOP, STR, SUBST, SUM, SYM, SYMBOL_A, SYMBOL_B, SYMBOL_C, SYMBOL_D, SYMBOL_I, SYMBOL_J, SYMBOL_N, SYMBOL_R, SYMBOL_S, SYMBOL_T, SYMBOL_X, SYMBOL_Y, SYMBOL_Z, TAN, TANH, TAYLOR, TENSOR, TEST, TESTEQ, TESTGE, TESTGT, TESTLE, TESTLT, TOS, TRACE, TRANSPOSE, TTY, U, UNIT, USR_SYMBOLS, YYE, YYRECT, ZERO, arglist, binding, caaddr, caadr, caar, cadaddr, cadadr, cadar, caddaddr, caddadr, caddar, caddddr, cadddr, caddr, cadr, car, cdaddr, cdadr, cdar, cddaddr, cddar, cdddaddr, cddddr, cdddr, cddr, cdr, cons, counter, display, draw_flag, draw_stop_return, endian, esc_flag, expanding, fmt_index, fmt_level, fmt_x, frame, imaginaryunit, isadd, iscons, isdouble, isfactorial, iskeyword, isnum, ispower, isrational, isstr, issymbol, istensor, logbuf, mtotal, one, out_buf, out_count, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, primetab, program_buf, rational, stack, symbol, symtab, tensor, test_flag, text_metric, tos, trigmode, verbosing, zero;

SELFTEST = 1;

NSYM = 1000;

cons = (function() {
  function cons() {}

  cons.prototype.car = null;

  cons.prototype.cdr = null;

  return cons;

})();

rational = (function() {
  function rational() {}

  rational.prototype.a = 0;

  rational.prototype.b = 0;

  return rational;

})();

U = (function() {
  function U() {}

  U.prototype.cons = null;

  U.prototype.printname = "";

  U.prototype.str = "";

  U.prototype.tensor = null;

  U.prototype.q = null;

  U.prototype.d = 0.0;

  U.prototype.k = 0;

  U.prototype.tag = 0;

  return U;

})();

CONS = 0;

NUM = 1;

DOUBLE = 2;

STR = 3;

TENSOR = 4;

SYM = 5;

counter = 0;

ABS = counter++;

ADD = counter++;

ADJ = counter++;

AND = counter++;

ARCCOS = counter++;

ARCCOSH = counter++;

ARCSIN = counter++;

ARCSINH = counter++;

ARCTAN = counter++;

ARCTANH = counter++;

ARG = counter++;

ATOMIZE = counter++;

BESSELJ = counter++;

BESSELY = counter++;

BINDING = counter++;

BINOMIAL = counter++;

CEILING = counter++;

CHECK = counter++;

CHOOSE = counter++;

CIRCEXP = counter++;

CLEAR = counter++;

CLOCK = counter++;

COEFF = counter++;

COFACTOR = counter++;

CONDENSE = counter++;

CONJ = counter++;

CONTRACT = counter++;

COS = counter++;

COSH = counter++;

DECOMP = counter++;

DEFINT = counter++;

DEGREE = counter++;

DENOMINATOR = counter++;

DERIVATIVE = counter++;

DET = counter++;

DIM = counter++;

DIRAC = counter++;

DISPLAY = counter++;

DIVISORS = counter++;

DO = counter++;

DOT = counter++;

DRAW = counter++;

DSOLVE = counter++;

EIGEN = counter++;

EIGENVAL = counter++;

EIGENVEC = counter++;

ERF = counter++;

ERFC = counter++;

EVAL = counter++;

EXP = counter++;

EXPAND = counter++;

EXPCOS = counter++;

EXPSIN = counter++;

FACTOR = counter++;

FACTORIAL = counter++;

FACTORPOLY = counter++;

FILTER = counter++;

FLOATF = counter++;

FLOOR = counter++;

FOR = counter++;

GAMMA = counter++;

GCD = counter++;

HERMITE = counter++;

HILBERT = counter++;

IMAG = counter++;

INDEX = counter++;

INNER = counter++;

INTEGRAL = counter++;

INV = counter++;

INVG = counter++;

ISINTEGER = counter++;

ISPRIME = counter++;

LAGUERRE = counter++;

LCM = counter++;

LEADING = counter++;

LEGENDRE = counter++;

LOG = counter++;

MAG = counter++;

MOD = counter++;

MULTIPLY = counter++;

NOT = counter++;

NROOTS = counter++;

NUMBER = counter++;

NUMERATOR = counter++;

OPERATOR = counter++;

OR = counter++;

OUTER = counter++;

POLAR = counter++;

POWER = counter++;

PRIME = counter++;

PRINT = counter++;

PRODUCT = counter++;

QUOTE = counter++;

QUOTIENT = counter++;

RANK = counter++;

RATIONALIZE = counter++;

REAL = counter++;

YYRECT = counter++;

ROOTS = counter++;

SETQ = counter++;

SGN = counter++;

SIMPLIFY = counter++;

SIN = counter++;

SINH = counter++;

SQRT = counter++;

STOP = counter++;

SUBST = counter++;

SUM = counter++;

TAN = counter++;

TANH = counter++;

TAYLOR = counter++;

TEST = counter++;

TESTEQ = counter++;

TESTGE = counter++;

TESTGT = counter++;

TESTLE = counter++;

TESTLT = counter++;

TRANSPOSE = counter++;

UNIT = counter++;

ZERO = counter++;

NIL = counter++;

AUTOEXPAND = counter++;

BAKE = counter++;

LAST = counter++;

TRACE = counter++;

TTY = counter++;

YYE = counter++;

DRAWX = counter++;

METAA = counter++;

METAB = counter++;

METAX = counter++;

SECRETX = counter++;

PI = counter++;

SYMBOL_A = counter++;

SYMBOL_B = counter++;

SYMBOL_C = counter++;

SYMBOL_D = counter++;

SYMBOL_I = counter++;

SYMBOL_J = counter++;

SYMBOL_N = counter++;

SYMBOL_R = counter++;

SYMBOL_S = counter++;

SYMBOL_T = counter++;

SYMBOL_X = counter++;

SYMBOL_Y = counter++;

SYMBOL_Z = counter++;

C1 = counter++;

C2 = counter++;

C3 = counter++;

C4 = counter++;

C5 = counter++;

C6 = counter++;

USR_SYMBOLS = counter++;

E = YYE;

TOS = 100000;

BUF = 10000;

MAX_PROGRAM_SIZE = 100001;

MAXPRIMETAB = 10000;

MAXDIM = 24;

tensor = (function() {
  function tensor() {}

  tensor.prototype.ndim = 0;

  tensor.prototype.dim = (function() {
    var i, ref, results;
    results = [];
    for (i = 0, ref = MAXDIM; 0 <= ref ? i <= ref : i >= ref; 0 <= ref ? i++ : i--) {
      results.push(0);
    }
    return results;
  })();

  tensor.prototype.nelem = 0;

  tensor.prototype.elem = null;

  return tensor;

})();

display = (function() {
  function display() {}

  display.prototype.h = 0;

  display.prototype.w = 0;

  display.prototype.n = 0;

  display.prototype.a = [];

  return display;

})();

text_metric = (function() {
  function text_metric() {}

  text_metric.prototype.ascent = 0;

  text_metric.prototype.descent = 0;

  text_metric.prototype.width = 0;

  return text_metric;

})();

tos = 0;

expanding = 0;

fmt_x = 0;

fmt_index = 0;

fmt_level = 0;

verbosing = 0;

primetab = [];

primetab[MAXPRIMETAB] = 0;

esc_flag = 0;

draw_flag = 0;

mtotal = 0;

trigmode = 0;

logbuf = "";

program_buf = "";

symtab = [];

binding = [];

arglist = [];

stack = [];

debugger;

frame = 0;

p0 = null;

p1 = null;

p2 = null;

p3 = null;

p4 = null;

p5 = null;

p6 = null;

p7 = null;

p8 = null;

p9 = null;

zero = null;

one = null;

imaginaryunit = null;

symtab = [];

out_buf = "";

out_count = 0;

test_flag = 0;

draw_stop_return = null;

endian = 0;

symbol = function(x) {
  return symtab[x];
};

iscons = function(p) {
  return p.k === CONS;
};

isrational = function(p) {
  return p.k === NUM;
};

isdouble = function(p) {
  return p.k === DOUBLE;
};

isnum = function(p) {
  return isrational(p) || isdouble(p);
};

isstr = function(p) {
  return p.k === STR;
};

istensor = function(p) {
  return p.k === TENSOR;
};

issymbol = function(p) {
  return p.k === SYM;
};

iskeyword = function(p) {
  return issymbol(p) && symnum(p) < NIL;
};

car = function(p) {
  if (iscons(p)) {
    return p.cons.car;
  } else {
    return symbol(NIL);
  }
};

cdr = function(p) {
  if (iscons(p)) {
    return p.cons.cdr;
  } else {
    return symbol(NIL);
  }
};

caar = function(p) {
  return car(car(p));
};

cadr = function(p) {
  return car(cdr(p));
};

cdar = function(p) {
  return cdr(car(p));
};

cddr = function(p) {
  return cdr(cdr(p));
};

caadr = function(p) {
  return car(car(cdr(p)));
};

caddr = function(p) {
  return car(cdr(cdr(p)));
};

cadar = function(p) {
  return car(cdr(car(p)));
};

cdadr = function(p) {
  return cdr(car(cdr(p)));
};

cddar = function(p) {
  return cdr(cdr(car(p)));
};

cdddr = function(p) {
  return cdr(cdr(cdr(p)));
};

caaddr = function(p) {
  return car(car(cdr(cdr(p))));
};

cadadr = function(p) {
  return car(cdr(car(cdr(p))));
};

caddar = function(p) {
  return car(cdr(cdr(car(p))));
};

cdaddr = function(p) {
  return cdr(car(cdr(cdr(p))));
};

cadddr = function(p) {
  return car(cdr(cdr(cdr(p))));
};

cddddr = function(p) {
  return cdr(cdr(cdr(cdr(p))));
};

caddddr = function(p) {
  return car(cdr(cdr(cdr(cdr(p)))));
};

cadaddr = function(p) {
  return car(cdr(car(cdr(cdr(p)))));
};

cddaddr = function(p) {
  return cdr(cdr(car(cdr(cdr(p)))));
};

caddadr = function(p) {
  return car(cdr(cdr(car(cdr(p)))));
};

cdddaddr = function(p) {
  return cdr(cdr(cdr(car(cdr(cdr(p))))));
};

caddaddr = function(p) {
  return car(cdr(cdr(car(cdr(cdr(p))))));
};

isadd = function(p) {
  return car(p) === symbol(ADD);
};

ispower = function(p) {
  return car(p) === symbol(POWER);
};

isfactorial = function(p) {
  return car(p) === symbol(FACTORIAL);
};

MSIGN = function(p) {
  return p[-2];
};

MLENGTH = function(p) {
  return p[-1];
};

MZERO = function(p) {
  return MLENGTH(p) === 1 && p[0] === 0;
};

MEQUAL = function(p, n) {
  return MLENGTH(p) === 1 && (long(long))(MSIGN(p) * p[0] === n);
};

//# sourceMappingURL=defs.js.map
